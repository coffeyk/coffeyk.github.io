{"version":3,"sources":["webpack:///./src/components/ui/RotationTable.tsx","webpack:///./src/parser/core/modules/Cooldowns.js","webpack:///./src/components/ui/TimeLineChart.js","webpack:///./src/parser/core/modules/GlobalCooldown.js","webpack:///./src/parser/core/modules/BuffWindow.tsx","webpack:///./node_modules/lodash/findLastIndex.js","webpack:///./src/parser/core/modules/Gauge/AbstractGauge.ts","webpack:///./src/parser/core/modules/Gauge/TimerGauge.ts","webpack:///./src/parser/core/modules/Gauge/Gauge.tsx","webpack:///./src/parser/core/modules/Gauge/CounterGauge.ts","webpack:///./src/parser/core/modules/Gauge/index.ts","webpack:///./node_modules/lodash/findLast.js"],"names":["RotationTable","React","Component","render","targets","notes","data","onGoto","headerTitle","this","props","compact","unstackable","celled","Header","Row","HeaderCell","collapsing","id","map","target","i","key","textAlign","header","note","Body","entry","start","targetAccessorResolver","accessor","targetsData","actual","expected","notesAccessorResolver","notesMap","TargetCell","Cell","positive","undefined","negative","end","rotation","style","marginRight","formatDuration","circular","size","icon","onClick","targetEntry","events","noteEntry","Cooldowns","Module","constructor","super","_cooldownGroups","_currentAction","_cooldowns","_groups","actions","_buildGroups","cooldownOrder","addHook","by","_onBeginCast","_onCast","_onComplete","groups","order","length","action","getAction","_buildGroup","content","name","group","merge","forEach","nestedGroups","opts","ItemGroup","showNested","timeline","addGroup","event","ability","guid","cooldown","startCooldown","cooldownGroup","startCooldownGroup","finishingCast","Object","keys","actionId","_addToTimeline","parseInt","cd","current","history","push","onGcd","use","shared","addItem","Item","type","timestamp","parser","fight","start_time","src","alt","getCooldown","originActionId","filter","sharedCooldown","currentFightDuration","currentTimestamp","resetCooldown","invulnTime","reduceCooldown","reduction","setInvulnTime","previousEndTimestamp","previousCooldown","isFirst","downtime","getDowntime","getCooldownRemaining","getTimeOnCooldown","considerInvulnTime","extension","reduce","time","status","getAdjustedTimeOnCooldown","duration","maximumDuration","handle","dependencies","DEFAULT_OPTIONS","aspectRatio","scales","xAxes","displayFormats","minute","second","millisecond","tooltipFormat","TimeLineChart","PureComponent","options","width","height","MIN_GCD","MAX_GCD","BASE_GCD","CASTER_TAX","DEBUG_LOG_SAVED_GCDS","GlobalCooldown","_castingEvent","_estimatedBaseGcd","_estimateGcdCount","_lastGcd","isInstant","gcds","gcdGroupId","normalise","byPlayer","hasBeginCast","relevantEvent","saveGcd","_debugLogSavedGcds","gcd","formatTimestamp","instant","taxed","casterTaxed","console","log","normalizedLength","speedMod","startTime","Group","_getGcdLength","title","estimate","getEstimate","statistics","add","SimpleStatistic","ATTACK","value","info","gcdInfo","speedmod","get","castTime","isCasterTaxed","gcdLength","Math","round","correctedCooldown","gcdRecast","normaliseWith","normalizedGcd","bound","lengths","math","mean","mode","max","min","getUptime","carry","cooldownRatio","BuffWindowState","e","a","getActionCountByIds","actionsById","includes","BuffWindowModule","arguments","buffWindows","lastBuffWindow","init","onCast","onApplyBuff","onRemoveBuff","onComplete","autoAttack","activeBuffWindow","considerAction","buffStatus","startNewBuffWindow","getBaselineExpectedGCDs","buffWindow","expectedGCDs","expectedPerWindow","changeExpectedGCDsClassLogic","reduceExpectedGCDsEndOfFight","windowDurationMillis","fightTimeRemaining","end_time","gcdEstimate","globalCooldown","ceil","getBaselineExpectedTrackedAction","changeExpectedTrackedActionClassLogic","getBuffWindowExpectedGCDs","getBuffWindowRequiredGCDsUsed","requiredGCDs","allowedGCDsById","getBuffWindowExpectedTrackedActions","getBuffWindowNotes","missedGCDs","sum","suggestions","TieredSuggestion","buffAction","suggestionContent","tiers","severityTiers","why","invalidGCDs","trackedActions","missedActions","trackedAction","trackedBadActions","badActions","output","rotationTargets","notesData","showName","rotationTableNotesColumnHeader","rotationData","windowStart","windowEnd","missedgcd","badgcd","show","rotationTableHeader","__decorate","dependency","__metadata","Data","prototype","Suggestions","Timeline","baseFindIndex","baseIteratee","toInteger","nativeMax","nativeMin","module","exports","array","predicate","fromIndex","index","AbstractGauge","_parser","Error","setParser","generateDataset","expectExist","TimerGauge","minimum","onExpiration","expirationCallback","maximum","chartOptions","chart","_addTimestampHook","_removeTimestampHook","lastKnownState","paused","remaining","delta","reset","set","refresh","expired","extend","pause","resume","hook","removeTimestampHook","addTimestampHook","endTime","relativeTimestamp","t","prev","y","chartY","timeDelta","label","color","dataSet","lineTension","chartColor","Color","backgroundColor","fade","toString","borderColor","setAddTimestampHook","setRemoveTimestampHook","Gauge","gauges","to","onDeath","gauge","bind","datasets","isDefined","CounterGauge","overCap","_value","initialValue","getValueAt","counter","modify","amount","diff","pushHistory","setMinimum","setBounds","setMaximum","NaN","pop","steppedLine","findLast","createFind"],"mappings":"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","file":"assets/2.16fb860a.js","sourcesContent":["import { Trans } from '@lingui/react';\nimport Rotation from 'components/ui/Rotation';\nimport React from 'react';\nimport { Button, Table } from 'semantic-ui-react';\nimport { formatDuration } from 'utilities';\nexport class RotationTable extends React.Component {\n    render() {\n        const { targets, notes, data, onGoto, headerTitle, } = this.props;\n        return <Table compact unstackable celled>\n\t\t\t<Table.Header>\n\t\t\t\t<Table.Row>\n\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t<strong><Trans id=\"core.ui.rotation-table.header.time\">Time</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(targets || []).map((target, i) => <Table.HeaderCell key={`target_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{target.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t\t<Table.HeaderCell>\n\t\t\t\t\t\t<strong>{(headerTitle) ? headerTitle : <Trans id=\"core.ui.rotation-table.header.rotation\">Rotation</Trans>}</strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(notes || []).map((note, i) => <Table.HeaderCell key={`note_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{note.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Header>\n\t\t\t<Table.Body>\n\t\t\t\t{data.map((entry) => <RotationTable.Row key={entry.start} onGoto={onGoto} targets={targets || []} notes={notes || []} {...entry}/>)}\n\t\t\t</Table.Body>\n\t\t</Table>;\n    }\n}\nRotationTable.targetAccessorResolver = (entry, target) => {\n    if (typeof target.accessor === 'string' && entry.targetsData != null) {\n        return entry.targetsData[target.accessor];\n    }\n    else if (typeof target.accessor === 'function') {\n        return target.accessor(entry);\n    }\n    else {\n        return {\n            actual: 0,\n            expected: 0,\n        };\n    }\n};\nRotationTable.notesAccessorResolver = (entry, note) => {\n    if (typeof note.accessor === 'string' && entry.notesMap != null) {\n        return entry.notesMap[note.accessor];\n    }\n    else if (typeof note.accessor === 'function') {\n        return note.accessor(entry);\n    }\n    else {\n        return null;\n    }\n};\nRotationTable.TargetCell = ({ actual, expected }) => <Table.Cell textAlign=\"center\" positive={expected === undefined ? false : actual >= expected} negative={expected === undefined ? false : actual < expected}>\n\t\t\t{actual}/{expected === undefined ? '-' : expected}\n\t\t</Table.Cell>;\nRotationTable.Row = ({ onGoto, targets, notes, notesMap, start, end, targetsData, rotation }) => <Table.Row>\n\t\t\t<Table.Cell textAlign=\"center\">\n\t\t\t\t<span style={{ marginRight: 5 }}>{formatDuration(start / 1000)}</span>\n\t\t\t\t{typeof onGoto === 'function' && <Button circular compact size=\"mini\" icon=\"time\" onClick={() => onGoto(start, end)}/>}\n\t\t\t</Table.Cell>\n\t\t\t{targets\n    .map(target => RotationTable.targetAccessorResolver({ start, end, targetsData, rotation }, target))\n    .map((targetEntry, i) => <RotationTable.TargetCell key={`target_${i}`} {...targetEntry}/>)}\n\t\t\t<Table.Cell>\n\t\t\t\t<Rotation events={rotation}/>\n\t\t\t</Table.Cell>\n\t\t\t{notes\n    .map(note => RotationTable.notesAccessorResolver({ start, end, targetsData, notesMap, rotation }, note))\n    .map((noteEntry, i) => <Table.Cell key={`notes_${i}`} textAlign=\"center\">\n\t\t\t\t\t\t\t{noteEntry}\n\t\t\t\t\t\t</Table.Cell>)}\n\t\t</Table.Row>;\n","import _ from 'lodash';\nimport Module from 'parser/core/Module';\nimport { ItemGroup, Item } from './Timeline';\nimport React from 'react';\n// Track the cooldowns on actions and shit\nexport default class Cooldowns extends Module {\n    constructor(...args) {\n        super(...args);\n        this._cooldownGroups = {};\n        this._currentAction = null;\n        this._cooldowns = {};\n        this._groups = {};\n        this._cooldownGroups = _.groupBy(this.data.actions, 'cooldownGroup');\n        // Pre-build groups for actions explicitly set by subclasses\n        this._buildGroups(this.constructor.cooldownOrder);\n        this.addHook('begincast', { by: 'player' }, this._onBeginCast);\n        this.addHook('cast', { by: 'player' }, this._onCast);\n        this.addHook('complete', this._onComplete);\n    }\n    _buildGroups(groups) {\n        // If there's no groups, noop\n        if (!groups) {\n            return;\n        }\n        const ids = groups.map((data, i) => {\n            const order = -(groups.length - i);\n            // If it's just an action id, build a group for it and stop\n            if (typeof data === 'number') {\n                const action = this.data.getAction(data);\n                this._buildGroup({\n                    id: data,\n                    content: action && action.name,\n                    order,\n                });\n                return data;\n            }\n            // Build the base group\n            const group = this._buildGroup({\n                id: data.name,\n                content: data.name,\n                order,\n            });\n            if (data.merge) {\n                // If it's a merge group, we only need to register our group for each of the IDs\n                data.actions.forEach(id => {\n                    this._groups[id] = group;\n                });\n            }\n            else {\n                // Otherwise, build nested groups for each action\n                group.nestedGroups = this._buildGroups(data.actions);\n            }\n            return data.name;\n        });\n        return ids;\n    }\n    _buildGroup(opts) {\n        const group = new ItemGroup({ showNested: false, ...opts });\n        this.timeline.addGroup(group);\n        this._groups[opts.id] = group;\n        return group;\n    }\n    // cooldown starts at the beginning of the casttime\n    // (though 99% of CD based abilities have no cast time)\n    // TODO: Should I be tracking pet CDs too? I mean, contagion/radiant are a thing.\n    _onBeginCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.cooldown == null) {\n            return;\n        }\n        this._currentAction = action;\n        this.startCooldown(action.id);\n        if (!_.isNil(action.cooldownGroup)) {\n            this.startCooldownGroup(action.id, action.cooldownGroup);\n        }\n    }\n    _onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.cooldown == null) {\n            return;\n        }\n        const finishingCast = this._currentAction && this._currentAction.id === action.id;\n        this._currentAction = null;\n        if (finishingCast) {\n            return;\n        }\n        this.startCooldown(action.id);\n        if (!_.isNil(action.cooldownGroup)) {\n            this.startCooldownGroup(action.id, action.cooldownGroup);\n        }\n    }\n    _onComplete() {\n        Object.keys(this._cooldowns).forEach(actionId => {\n            this._addToTimeline(parseInt(actionId, 10));\n        });\n    }\n    _addToTimeline(actionId) {\n        const cd = this._cooldowns[actionId];\n        if (!cd) {\n            return false;\n        }\n        // Clean out any 'current' cooldowns into the history\n        if (cd.current) {\n            cd.history.push(cd.current);\n            cd.current = null;\n        }\n        const action = this.data.getAction(actionId);\n        // If the action is on the GCD, GlobalCooldown will be managing its own group\n        if (!action || action.onGcd) {\n            return false;\n        }\n        // Ensure we've got a group for this item\n        if (!this._groups[actionId]) {\n            this._buildGroup({\n                id: actionId,\n                content: action.name,\n                order: actionId,\n            });\n        }\n        // Add CD info to the timeline\n        cd.history\n            .forEach(use => {\n            if (!use.shared) {\n                this._groups[actionId].addItem(new Item({\n                    type: 'background',\n                    start: use.timestamp - this.parser.fight.start_time,\n                    length: use.length,\n                    content: <img src={action.icon} alt={action.name}/>,\n                }));\n            }\n        });\n        return true;\n    }\n    getCooldown(actionId) {\n        return this._cooldowns[actionId] || {\n            current: null,\n            history: [],\n        };\n    }\n    startCooldownGroup(originActionId, cooldownGroup) {\n        const sharedCooldownActions = _.get(this._cooldownGroups, cooldownGroup, []);\n        sharedCooldownActions\n            .map(action => action.id)\n            .filter(id => id !== originActionId)\n            .forEach(id => this.startCooldown(id, true));\n    }\n    startCooldown(actionId, sharedCooldown = false) {\n        // TODO: handle shared CDs\n        const action = this.data.getAction(actionId);\n        if (!action) {\n            return;\n        }\n        // Get the current cooldown status, falling back to a new cooldown\n        const cd = this.getCooldown(actionId);\n        // If there's a current object, move it into the history\n        // TODO: handle errors on CD overlap\n        if (cd.current) {\n            const currentFightDuration = this.parser.currentTimestamp - this.parser.fight.start_time;\n            if (cd.current.timestamp < this.parser.fight.start_time && cd.current.length > currentFightDuration) {\n                // Pre-pull usage, reset the cooldown to prevent overlap on timeline since we don't know exactly when cooldown was used pre-pull\n                this.resetCooldown(actionId);\n            }\n            else {\n                cd.history.push(cd.current);\n            }\n        }\n        cd.current = {\n            timestamp: this.parser.currentTimestamp,\n            length: action.cooldown * 1000,\n            shared: sharedCooldown,\n            invulnTime: 0,\n        };\n        // Save the info back out (to ensure propagation if we've got a new info)\n        this._cooldowns[actionId] = cd;\n    }\n    reduceCooldown(actionId, reduction) {\n        const cd = this.getCooldown(actionId);\n        const currentTimestamp = this.parser.currentTimestamp;\n        // Check if current isn't current\n        if (cd.current && cd.current.timestamp + cd.current.length < currentTimestamp) {\n            cd.history.push(cd.current);\n            cd.current = null;\n        }\n        // TODO: Do I need to warn if they're reducing cooldown on something _with_ no cooldown?\n        if (cd.current === null) {\n            return;\n        }\n        // Reduce the CD\n        cd.current.length -= reduction * 1000;\n        // If the reduction would have made it come off CD earlier than now, reset it - the extra time reduction should be lost.\n        if (cd.current.timestamp + cd.current.length < currentTimestamp) {\n            this.resetCooldown(actionId);\n        }\n    }\n    setInvulnTime(actionId) {\n        const cd = this.getCooldown(actionId);\n        let previousEndTimestamp = this.parser.fight.start_time;\n        let previousCooldown = {};\n        let isFirst = true;\n        for (const cooldown of cd.history) {\n            if (isFirst) {\n                previousEndTimestamp = (cooldown.timestamp + cooldown.length);\n                isFirst = false;\n                previousCooldown = cooldown;\n            }\n            //We invuln time is the time the boss was invuln from when the CD came off CD and when it was next executed\n            previousCooldown.invulnTime = this.downtime.getDowntime(previousEndTimestamp, cooldown.timestamp);\n            previousEndTimestamp = (cooldown.timestamp + cooldown.length);\n            previousCooldown = cooldown;\n        }\n    }\n    resetCooldown(actionId) {\n        const cd = this.getCooldown(actionId);\n        // If there's nothing running, we can just stop\n        // TODO: need to warn?\n        if (cd.current === null) {\n            return;\n        }\n        // Fix up the length\n        cd.current.length = this.parser.currentTimestamp - cd.current.timestamp;\n        // Move the CD into the history\n        cd.history.push(cd.current);\n        cd.current = null;\n    }\n    getCooldownRemaining(actionId) {\n        const current = this.getCooldown(actionId).current;\n        if (!current) {\n            return 0;\n        }\n        return current.length - (this.parser.currentTimestamp - current.timestamp);\n    }\n    // TODO: Should this be here?\n    getTimeOnCooldown(actionId, considerInvulnTime = false, extension = 0) {\n        const cd = this.getCooldown(actionId);\n        const currentTimestamp = this.parser.currentTimestamp;\n        if (considerInvulnTime) {\n            this.setInvulnTime(actionId);\n        }\n        else {\n            cd.history.map(cooldown => {\n                cooldown.invulnTime = 0;\n            });\n        }\n        return cd.history.reduce((time, status) => time + this.getAdjustedTimeOnCooldown(status, currentTimestamp, extension), cd.current ? this.getAdjustedTimeOnCooldown(cd.current, currentTimestamp, extension) : 0);\n    }\n    getAdjustedTimeOnCooldown(cooldown, currentTimestamp, extension) {\n        // Doesn't count time on CD outside the bounds of the current fight, it'll throw calcs off\n        // Add to the length of the cooldown any invuln time for the boss\n        // Additionally account for any extension the caller allowed to the CD Length\n        const duration = currentTimestamp - cooldown.timestamp;\n        const maximumDuration = cooldown.length + cooldown.invulnTime + extension;\n        return _.clamp(duration, 0, maximumDuration);\n    }\n    get used() {\n        return Object.keys(this._cooldowns);\n    }\n}\nCooldowns.handle = 'cooldowns';\nCooldowns.dependencies = [\n    'data',\n    'downtime',\n    'timeline',\n];\n// Array used to sort cooldowns in the timeline. Elements should be either IDs for\n// top-level groups, or objects of the format {name: string, actions: array} for\n// nested groups. Actions not specified here will be sorted by their ID below.\n// Check the NIN and SMN modules for examples.\nCooldowns.cooldownOrder = [];\n","import _ from 'lodash';\nimport PropTypes from 'prop-types';\nimport React, { PureComponent } from 'react';\nimport { Line } from 'react-chartjs-2';\nconst DEFAULT_OPTIONS = {\n    aspectRatio: 3,\n    scales: {\n        xAxes: [{\n                type: 'time',\n                time: {\n                    displayFormats: {\n                        minute: 'm:ss',\n                        second: 'm:ss',\n                        millisecond: 'm:ss.SS',\n                    },\n                    // This tooltip format displays similar to a \"relative\" timestamp,\n                    // since react assumes UNIX epoch timestamps for the data.\n                    tooltipFormat: 'mm:ss.SSS',\n                },\n            }],\n    },\n};\nexport default class TimeLineChart extends PureComponent {\n    render() {\n        const options = _.merge({}, DEFAULT_OPTIONS, this.props.options || {});\n        return <Line data={this.props.data} options={options} \n        // Using this trash 'cus aspectRatio doesn't work with the react wrapper\n        width={options.aspectRatio} height={1}/>;\n    }\n}\nTimeLineChart.propTypes = {\n    data: PropTypes.object.isRequired,\n    options: PropTypes.object,\n};\n","import { t } from '@lingui/macro';\nimport { Trans } from '@lingui/react';\nimport math from 'mathjsCustom';\nimport React from 'react';\nimport Module from 'parser/core/Module';\nimport { Group, Item } from './Timeline';\nimport { SimpleStatistic } from './Statistics';\nconst MIN_GCD = 1500;\nconst MAX_GCD = 2500;\nconst BASE_GCD = 2500;\nconst CASTER_TAX = 100;\nconst DEBUG_LOG_SAVED_GCDS = false && process.env.NODE_ENV !== 'production';\n// NOTE: Caster tax refers to spells taking 0.1s longer than their tooltip claims if their cast time is at least as long as their recast time.\n// See https://www.reddit.com/r/ffxiv/comments/8s05rn/the_recast_time_on_your_tooltip_can_be_up_to_85/, specifically:\n//    There is also another issue that influences how long recast times actually take that isn’t as heavily influenced by fps but is still affected,\n//    which is animation delay that happen between casts, this means that if you have a spell with a cast time that is equal to or\n//    greater than the recast time you will end up taking longer between casts than the (re)cast time. The delay is around 100 ms at 100+ fps\nexport default class GlobalCooldown extends Module {\n    constructor(...args) {\n        super(...args);\n        this._castingEvent = null;\n        this._estimatedBaseGcd = null;\n        this._estimateGcdCount = -1;\n        this._lastGcd = {\n            isInstant: false,\n            event: null,\n        };\n        this.gcds = [];\n        this.gcdGroupId = 'gcd';\n        this.addHook('complete', this._onComplete);\n    }\n    // Using normalise so the estimate can be used throughout the parse\n    normalise(events) {\n        for (let i = 0; i < events.length; i++) {\n            const event = events[i];\n            // Only care about player GCDs\n            if (!this.parser.byPlayer(event) || !event.ability) {\n                continue;\n            }\n            const action = this.data.getAction(event.ability.guid);\n            if (!action || !action.onGcd) {\n                continue;\n            }\n            // eslint-disable-next-line default-case\n            switch (event.type) {\n                // wowa uses beginchannel for this...? need info for flamethrower/that ast skill/passage of arms\n                case 'begincast':\n                    // Can I check for cancels?\n                    this._castingEvent = event;\n                    break;\n                case 'cast':\n                    const hasBeginCast = this._castingEvent !== null && this._castingEvent.ability.guid === action.id;\n                    const relevantEvent = hasBeginCast ? this._castingEvent : event;\n                    this.saveGcd({ ...this._lastGcd }, relevantEvent.timestamp); // Save last gcd with current timestamp\n                    this._lastGcd.isInstant = !hasBeginCast;\n                    this._lastGcd.event = relevantEvent;\n                    this._castingEvent = null;\n                    break;\n            }\n        }\n        if (events.length) {\n            this.saveGcd({ ...this._lastGcd }, events[events.length - 1].timestamp);\n        }\n        this._debugLogSavedGcds();\n        return events;\n    }\n    _debugLogSavedGcds() {\n        if (!DEBUG_LOG_SAVED_GCDS) {\n            return;\n        }\n        // NOTE: Please sanity-check results when changing normalise or saveGcd. Good test cases include:\n        // - Attributing 1.5s and 2.2s to correct RDM melee gcds\n        // - Sub-0.5s speedmod for BLM fast-casts and correct Instant/CasterTaxed flagging\n        // - Correct timestamp for last event before long gaps (ie: Kefka normal)\n        this.gcds.forEach((gcd) => {\n            const timestamp = this.parser.formatTimestamp(gcd.timestamp);\n            const action = this.data.getAction(gcd.actionId);\n            const instant = gcd.isInstant ? ' Instant' : '';\n            const taxed = gcd.casterTaxed ? ' CasterTaxed' : '';\n            console.log(`${timestamp} ${action.name}[${gcd.length}|${gcd.normalizedLength}] Speedmod[${gcd.speedMod}]${instant}${taxed}`);\n        });\n    }\n    _onComplete() {\n        const startTime = this.parser.fight.start_time;\n        // Timeline output\n        // TODO: Look into adding items to groups? Maybe?\n        this.timeline.addGroup(new Group({\n            id: this.gcdGroupId,\n            content: 'GCD',\n            order: -99,\n        }));\n        this.gcds.forEach(gcd => {\n            const action = this.data.getAction(gcd.actionId);\n            if (!action) {\n                return;\n            }\n            this.timeline.addItem(new Item({\n                type: 'background',\n                start: gcd.timestamp - startTime,\n                length: this._getGcdLength(gcd),\n                title: action.name,\n                group: this.gcdGroupId,\n                content: <img src={action.icon} alt={action.name} title={action.name}/>,\n            }));\n        });\n        // Statistic box\n        const estimate = this.getEstimate(false);\n        this.statistics.add(new SimpleStatistic({\n            title: <Trans id=\"core.gcd.estimated-gcd\">Estimated GCD</Trans>,\n            icon: this.data.actions.ATTACK.icon,\n            value: this.parser.formatDuration(estimate),\n            info: (<Trans id=\"core.gcd.no-statistics\">\n\t\t\t\t\tUnfortunately, player statistics are not available from FF Logs. As such, the calculated GCD length is an <em>estimate</em>, and may well be incorrect. If it is reporting a GCD length <em>longer</em> than reality, you likely need to focus on keeping your GCD rolling.\n\t\t\t\t</Trans>),\n        }));\n    }\n    //saveGcd(event, isInstant) {\n    saveGcd(gcdInfo, timestamp) {\n        if (!gcdInfo.event) {\n            return;\n        }\n        const action = this.data.getAction(gcdInfo.event.ability.guid);\n        if (!action || !action.id) {\n            return;\n        }\n        let speedMod = this.speedmod.get(gcdInfo.event.timestamp);\n        let castTime = action.castTime;\n        // HACK NOTE TODO: Need to properly account for abilities that alter only the cast or recast of attacks.\n        // Thinking of moving this into a module like speedmod, that can be called with a timestamp to grab modified base castTime/cooldown values\n        const HACK_ASTRAL_UMBRAL_SPEED_SCALAR = 0.5;\n        if (speedMod <= HACK_ASTRAL_UMBRAL_SPEED_SCALAR) {\n            speedMod /= HACK_ASTRAL_UMBRAL_SPEED_SCALAR;\n            castTime *= HACK_ASTRAL_UMBRAL_SPEED_SCALAR;\n        }\n        let isCasterTaxed = false;\n        // GCD is only to two decimal places, so round it there. Storing in Ms.\n        // eslint-disable-next-line no-magic-numbers\n        let gcdLength = Math.round((timestamp - gcdInfo.event.timestamp) / 10) * 10;\n        if (!gcdInfo.isInstant && castTime >= action.cooldown) {\n            gcdLength -= CASTER_TAX;\n            isCasterTaxed = true;\n        }\n        const correctedCooldown = action.gcdRecast != null\n            ? action.gcdRecast\n            : action.cooldown;\n        const normaliseWith = gcdInfo.isInstant || castTime < correctedCooldown\n            ? correctedCooldown\n            : castTime;\n        const normalizedGcd = Math.round(gcdLength\n            * ((BASE_GCD / 1000) / normaliseWith)\n            * (1 / speedMod));\n        this.gcds.push({\n            timestamp: gcdInfo.event.timestamp,\n            length: gcdLength,\n            normalizedLength: normalizedGcd,\n            speedMod,\n            castTime,\n            cooldown: correctedCooldown,\n            casterTaxed: isCasterTaxed,\n            actionId: action.id,\n            isInstant: gcdInfo.isInstant,\n        });\n    }\n    getEstimate(bound = true) {\n        const gcdLength = this.gcds.length;\n        // If we don't have cache, need to recaculate it\n        if (this._estimatedBaseGcd === null || gcdLength !== this._estimateGcdCount) {\n            // Calculate the lengths of the GCD\n            const lengths = this.gcds.map(gcd => gcd.normalizedLength);\n            // Mode seems to get best results. Using mean in case there's multiple modes.\n            this._estimatedBaseGcd = lengths.length ? math.mean(math.mode(lengths)) : MAX_GCD;\n            this._estimateGcdCount = gcdLength;\n        }\n        // Bound the result if requested\n        if (bound) {\n            this._estimatedBaseGcd = Math.max(MIN_GCD, Math.min(MAX_GCD, this._estimatedBaseGcd));\n        }\n        return this._estimatedBaseGcd;\n    }\n    getUptime() {\n        return this.gcds.reduce((carry, gcd) => {\n            const duration = this._getGcdLength(gcd);\n            const downtime = this.downtime.getDowntime(gcd.timestamp, gcd.timestamp + duration);\n            return carry + duration - downtime;\n        }, 0);\n    }\n    _getGcdLength(gcd) {\n        let cooldown = (gcd.isInstant || gcd.castTime <= gcd.cooldown)\n            ? gcd.cooldown\n            : Math.max(gcd.castTime, gcd.cooldown);\n        cooldown *= 1000;\n        // Some actions are lower than or equal to min gcd, only adjust with ratios when they are not\n        if (cooldown > MIN_GCD) {\n            const cooldownRatio = this.getEstimate() / MAX_GCD;\n            cooldown = Math.max(MIN_GCD, cooldown * cooldownRatio * gcd.speedMod);\n        }\n        const duration = Math.round(cooldown + (gcd.casterTaxed ? CASTER_TAX : 0));\n        return duration;\n    }\n}\nGlobalCooldown.handle = 'gcd';\nGlobalCooldown.dependencies = [\n    // We need this to normalise before us\n    'precastAction',\n    'castTime',\n    'data',\n    'downtime',\n    'speedmod',\n    'statistics',\n    'timeline',\n];\nGlobalCooldown.title = t('core.gcd.title') `Global Cooldown`;\n","import { __decorate, __metadata } from \"tslib\";\nimport { t } from '@lingui/macro';\nimport { Plural, Trans } from '@lingui/react';\nimport { ActionLink } from 'components/ui/DbLink';\nimport { RotationTable } from 'components/ui/RotationTable';\nimport _ from 'lodash';\nimport Module, { dependency } from 'parser/core/Module';\nimport GlobalCooldown from 'parser/core/modules/GlobalCooldown';\nimport Suggestions, { TieredSuggestion } from 'parser/core/modules/Suggestions';\nimport Timeline from 'parser/core/modules/Timeline';\nimport React from 'react';\nimport { Data } from './Data';\nexport class BuffWindowState {\n    constructor(data, start) {\n        this.rotation = [];\n        this.data = data;\n        this.start = start;\n    }\n    get gcds() {\n        // TODO: Investigate removing the reliance on data here.\n        return this.rotation\n            .map(e => this.data.getAction(e.ability.guid))\n            .filter(a => a && a.onGcd)\n            .length;\n    }\n    getActionCountByIds(actionsById) {\n        return this.rotation\n            .filter(e => actionsById.includes(e.ability.guid))\n            .length;\n    }\n}\nexport class BuffWindowModule extends Module {\n    constructor() {\n        super(...arguments);\n        this.buffWindows = [];\n    }\n    get activeBuffWindow() {\n        const lastBuffWindow = _.last(this.buffWindows);\n        if (lastBuffWindow && lastBuffWindow.end == null) {\n            return lastBuffWindow;\n        }\n        return undefined;\n    }\n    init() {\n        this.addHook('cast', { by: 'player' }, this.onCast);\n        this.addHook('applybuff', { by: 'player' }, this.onApplyBuff);\n        this.addHook('removebuff', { by: 'player' }, this.onRemoveBuff);\n        this.addHook('complete', this.onComplete);\n    }\n    onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.autoAttack) {\n            // Disregard auto attacks for tracking rotations / events during buff windows\n            return;\n        }\n        if (this.activeBuffWindow && this.considerAction(action)) {\n            this.activeBuffWindow.rotation.push(event);\n        }\n    }\n    /**\n     * This method MAY be overridden to return true or false, indicating whether or not this action should be considered within the buff window\n     * If false is returned, the action will not be tracked AT ALL within the buff window, and will NOT appear within the Rotation column\n     * @param action\n     */\n    considerAction(action) {\n        return true;\n    }\n    onApplyBuff(event) {\n        if (!this.buffStatus || event.ability.guid !== this.buffStatus.id) {\n            return;\n        }\n        this.startNewBuffWindow(event.timestamp);\n    }\n    startNewBuffWindow(startTime) {\n        this.buffWindows.push(new BuffWindowState(this.data, startTime));\n    }\n    onRemoveBuff(event) {\n        if (!this.buffStatus || event.ability.guid !== this.buffStatus.id) {\n            return;\n        }\n        if (this.activeBuffWindow) {\n            this.activeBuffWindow.end = event.timestamp;\n        }\n    }\n    /**\n     * For consumers that have the same number of expected GCDs per window, this will use the expectedPerWindow property\n     *   on expectedGCDs as the baseline\n     * This method MAY be overridden if the logic of expected GCDs per window is variable\n     * @param buffWindow\n     */\n    getBaselineExpectedGCDs(buffWindow) {\n        if (this.expectedGCDs) {\n            return this.expectedGCDs.expectedPerWindow;\n        }\n        return 0;\n    }\n    /**\n     * This method MAY be overridden to provide class-specific rushing logic per BuffWindow - default is no effect\n     * Return a positive number to INCREASE expected GCDs for this window, or a negative number to DECREASE\n     * @param buffWindow\n     */\n    changeExpectedGCDsClassLogic(buffWindow) {\n        return 0;\n    }\n    /**\n     * Handles rushing logic to reduce expected GCDs in a window for end of fight rushing\n     * This method MAY be overridden if class rules for end of fight rushing vary\n     * @param buffWindow\n     */\n    reduceExpectedGCDsEndOfFight(buffWindow) {\n        if (this.buffStatus.duration) {\n            // Check to see if this window is rushing due to end of fight - reduce expected GCDs accordingly\n            const windowDurationMillis = this.buffStatus.duration * 1000;\n            const fightTimeRemaining = this.parser.fight.end_time - buffWindow.start;\n            if (windowDurationMillis >= fightTimeRemaining) {\n                const gcdEstimate = this.globalCooldown.getEstimate();\n                return Math.ceil((windowDurationMillis - fightTimeRemaining) / gcdEstimate);\n            }\n        }\n        // Default: no rushing reduction\n        return 0;\n    }\n    /**\n     * For consumers that have tracked actions that expect the same number of usages per window, this will use the\n     *   expectedPerWindow property on that action as the baseline\n     * This method MAY be overridden if the logic of expected tracked actions per window is variable\n     * @param buffWindow\n     * @param action\n     */\n    getBaselineExpectedTrackedAction(buffWindow, action) {\n        return action.expectedPerWindow || 0;\n    }\n    /**\n     * This method MAY be overridden to provide class-specific logic to change expected uses of a tracked action per BuffWindow - default no effect\n     * Return a positive number to INCREASE expected tracked action usages for this window, or a negative number to DECREASE\n     * @param buffWindow\n     * @param action\n     */\n    changeExpectedTrackedActionClassLogic(buffWindow, action) {\n        return 0;\n    }\n    getBuffWindowExpectedGCDs(buffWindow) {\n        return this.getBaselineExpectedGCDs(buffWindow) + this.changeExpectedGCDsClassLogic(buffWindow) - this.reduceExpectedGCDsEndOfFight(buffWindow);\n    }\n    /**\n     * This method MAY be overridden to provide class-specific logic to determine if the required GCD(s) were used during a given BuffWindow\n     * Classes whose required GCD list vary per window should override this function.\n     * Function MUST return a number of CORRECT GCDs used within the window\n     * @param buffWindow\n     */\n    getBuffWindowRequiredGCDsUsed(buffWindow) {\n        if (!this.requiredGCDs) {\n            return 0;\n        }\n        const allowedGCDsById = this.requiredGCDs.actions.map(a => a.id);\n        return buffWindow.getActionCountByIds(allowedGCDsById);\n    }\n    getBuffWindowExpectedTrackedActions(buffWindow, action) {\n        return this.getBaselineExpectedTrackedAction(buffWindow, action) + this.changeExpectedTrackedActionClassLogic(buffWindow, action);\n    }\n    /**\n     * This method will be called if and only if the rotationTableNotesColumnHeader property is set, to add a notes field for each buff window\n     * Implementing classes MUST define their logic to determine what note to display for each buff window within this method\n     * @param buffWindow\n     */\n    getBuffWindowNotes(buffWindow) {\n        return undefined;\n    }\n    onComplete() {\n        if (this.expectedGCDs) {\n            const missedGCDs = this.buffWindows\n                .reduce((sum, buffWindow) => {\n                const expectedGCDs = this.getBuffWindowExpectedGCDs(buffWindow);\n                return sum + Math.max(0, expectedGCDs - buffWindow.gcds);\n            }, 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.buffAction.icon,\n                content: this.expectedGCDs.suggestionContent,\n                tiers: this.expectedGCDs.severityTiers,\n                value: missedGCDs,\n                why: <Trans id=\"core.buffwindow.suggestions.missedgcd.why\">\n\t\t\t\t\t{missedGCDs} <Plural value={missedGCDs} one=\"GCD was\" other=\"GCDs were\"/> missed during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n        if (this.requiredGCDs) {\n            const invalidGCDs = this.buffWindows\n                .reduce((sum, buffWindow) => sum + Math.max(0, buffWindow.gcds - this.getBuffWindowRequiredGCDsUsed(buffWindow)), 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.requiredGCDs.icon,\n                content: this.requiredGCDs.suggestionContent,\n                tiers: this.requiredGCDs.severityTiers,\n                value: invalidGCDs,\n                why: <Trans id=\"core.buffwindow.suggestions.badgcd.why\">\n\t\t\t\t\t{invalidGCDs} incorrect <Plural value={invalidGCDs} one=\"GCD was\" other=\"GCDs were\"/> used during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n        if (this.trackedActions) {\n            const missedActions = this.trackedActions.actions\n                .reduce((sum, trackedAction) => sum + this.buffWindows\n                .reduce((sum, buffWindow) => sum + Math.max(0, trackedAction.expectedPerWindow - buffWindow.getActionCountByIds([trackedAction.action.id])), 0), 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.trackedActions.icon,\n                content: this.trackedActions.suggestionContent,\n                tiers: this.trackedActions.severityTiers,\n                value: missedActions,\n                why: <Trans id=\"core.buffwindow.suggestions.trackedaction.why\">\n\t\t\t\t\t<Plural value={missedActions} one=\"# use of a recommended cooldown was\" other=\"# uses of recommended cooldowns were\"/> missed during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n        if (this.trackedBadActions) {\n            const badActions = this.trackedBadActions.actions\n                .reduce((sum, trackedAction) => sum + this.buffWindows\n                .reduce((sum, buffWindow) => sum + Math.max(0, buffWindow.getActionCountByIds([trackedAction.action.id]) - trackedAction.expectedPerWindow), 0), 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.trackedBadActions.icon,\n                content: this.trackedBadActions.suggestionContent,\n                tiers: this.trackedBadActions.severityTiers,\n                value: badActions,\n                why: <Trans id=\"core.buffwindow.suggestions.trackedbadaction.why\">\n\t\t\t\t\t<Plural value={badActions} one=\"# use of\" other=\"# uses of\"/> cooldowns that should be avoided during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n    }\n    output() {\n        const rotationTargets = [];\n        const notesData = [];\n        if (this.expectedGCDs) {\n            rotationTargets.push({\n                header: <Trans id=\"core.buffwindow.table.header.gcds\">GCDs</Trans>,\n                accessor: 'missedgcd',\n            });\n        }\n        if (this.requiredGCDs) {\n            rotationTargets.push({\n                header: <img src={this.requiredGCDs.icon} alt=\"\" style={{ height: '20px' }}/>,\n                accessor: 'badgcd',\n            });\n        }\n        if (this.trackedActions) {\n            this.trackedActions.actions.forEach((trackedAction) => {\n                rotationTargets.push({\n                    header: <ActionLink showName={false} {...trackedAction.action}/>,\n                    accessor: trackedAction.action.name,\n                });\n            });\n        }\n        if (this.rotationTableNotesColumnHeader) {\n            notesData.push({\n                header: this.rotationTableNotesColumnHeader,\n                accessor: 'notes',\n            });\n        }\n        const rotationData = this.buffWindows\n            .map(buffWindow => {\n            const windowStart = buffWindow.start - this.parser.fight.start_time;\n            const windowEnd = (buffWindow.end != null ? buffWindow.end : buffWindow.start) - this.parser.fight.start_time;\n            const targetsData = {};\n            const notesMap = {};\n            if (this.expectedGCDs) {\n                targetsData.missedgcd = {\n                    actual: buffWindow.gcds,\n                    expected: this.getBuffWindowExpectedGCDs(buffWindow),\n                };\n            }\n            if (this.requiredGCDs) {\n                targetsData.badgcd = {\n                    actual: this.getBuffWindowRequiredGCDsUsed(buffWindow),\n                    expected: this.getBuffWindowExpectedGCDs(buffWindow),\n                };\n            }\n            if (this.trackedActions) {\n                this.trackedActions.actions.forEach((trackedAction) => {\n                    targetsData[trackedAction.action.name] = {\n                        actual: buffWindow.getActionCountByIds([trackedAction.action.id]),\n                        expected: this.getBuffWindowExpectedTrackedActions(buffWindow, trackedAction),\n                    };\n                });\n            }\n            if (this.rotationTableNotesColumnHeader) {\n                notesMap.notes = this.getBuffWindowNotes(buffWindow);\n            }\n            return {\n                start: windowStart,\n                end: windowEnd,\n                targetsData,\n                rotation: buffWindow.rotation,\n                notesMap,\n            };\n        });\n        return <RotationTable targets={rotationTargets} data={rotationData} notes={notesData} onGoto={this.timeline.show} headerTitle={this.rotationTableHeader}/>;\n    }\n}\nBuffWindowModule.handle = 'buffwindow';\nBuffWindowModule.title = t('core.buffwindow.title') `Buff Window`;\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Data)\n], BuffWindowModule.prototype, \"data\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Suggestions)\n], BuffWindowModule.prototype, \"suggestions\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Timeline)\n], BuffWindowModule.prototype, \"timeline\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", GlobalCooldown)\n], BuffWindowModule.prototype, \"globalCooldown\", void 0);\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * This method is like `_.findIndex` except that it iterates over elements\n * of `collection` from right to left.\n *\n * @static\n * @memberOf _\n * @since 2.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=array.length-1] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': true },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': false }\n * ];\n *\n * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n * // => 2\n *\n * // The `_.matches` iteratee shorthand.\n * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n * // => 0\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findLastIndex(users, ['active', false]);\n * // => 2\n *\n * // The `_.property` iteratee shorthand.\n * _.findLastIndex(users, 'active');\n * // => 0\n */\nfunction findLastIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = length - 1;\n  if (fromIndex !== undefined) {\n    index = toInteger(fromIndex);\n    index = fromIndex < 0\n      ? nativeMax(length + index, 0)\n      : nativeMin(index, length - 1);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index, true);\n}\n\nmodule.exports = findLastIndex;\n","export class AbstractGauge {\n    constructor(opts) {\n        this._parser = opts.parser;\n    }\n    /** The main parser instance. */\n    get parser() {\n        if (!this._parser) {\n            throw new Error('No parser found. Ensure this gauge is being passed to the core gauge module, or initialised with a reference to the parser.');\n        }\n        return this._parser;\n    }\n    /** Set the function used to retrieve the current timestamp. */\n    setParser(parser) {\n        this._parser = parser;\n    }\n    /** Generate a dataset suitable for use in ChartJS */\n    generateDataset() { return undefined; }\n}\n","import Color from 'color';\nimport { AbstractGauge } from './AbstractGauge';\nfunction expectExist(value) {\n    if (!value) {\n        throw new Error('Missing something required. Check the stack trace.');\n    }\n    return value;\n}\nexport class TimerGauge extends AbstractGauge {\n    constructor(opts) {\n        super(opts);\n        // Just in case I ever have to change it lmao\n        this.minimum = 0;\n        this.history = [];\n        this.onExpiration = () => {\n            if (this.expirationCallback) {\n                this.expirationCallback();\n            }\n        };\n        this.maximum = opts.maximum;\n        this.expirationCallback = opts.onExpiration;\n        this.chartOptions = opts.chart;\n    }\n    get addTimestampHook() { return expectExist(this._addTimestampHook); }\n    get removeTimestampHook() { return expectExist(this._removeTimestampHook); }\n    /** The most recent state  */\n    get lastKnownState() {\n        const { length } = this.history;\n        if (length === 0) {\n            return;\n        }\n        return this.history[length - 1];\n    }\n    /** Time currently remaining on the timer. */\n    get remaining() {\n        // If there's no known state, we have to assume there's no time left\n        if (!this.lastKnownState) {\n            return this.minimum;\n        }\n        // If we're paused, the time remaining always === specified state remaining\n        if (this.lastKnownState.paused) {\n            return this.lastKnownState.remaining;\n        }\n        const delta = this.parser.currentTimestamp - this.lastKnownState.timestamp;\n        return Math.max(this.minimum, this.lastKnownState.remaining - delta);\n    }\n    /** Whether the gauge has expired. */\n    get expired() {\n        return this.remaining <= this.minimum;\n    }\n    /** Whether the gauge is currently paused. */\n    get paused() {\n        // If there's no state, we're neither paused nor running - but safer to assume running.\n        if (!this.lastKnownState) {\n            return false;\n        }\n        return this.lastKnownState.paused;\n    }\n    /** @inheritdoc */\n    reset() {\n        this.set(this.minimum);\n    }\n    /**\n     * Start the timer from its maximum value\n     */\n    start() {\n        this.set(this.maximum);\n    }\n    /**\n     * Refresh the gauge to its maximum value.\n     * If the gauge has expired, this will have no effect.\n     */\n    refresh() {\n        if (this.expired) {\n            return;\n        }\n        this.start();\n    }\n    /**\n     * Add time to the gauge. Time over the maxium will be lost.\n     * If the gauge has edxpired, this will have no effect.\n     */\n    extend(duration) {\n        if (this.expired) {\n            return;\n        }\n        this.set(this.remaining + duration);\n    }\n    /** Pause the timer at its current state. */\n    pause() {\n        this.set(this.remaining, true);\n    }\n    /** Resume the timer from its paused state. */\n    resume() {\n        this.set(this.remaining, false);\n    }\n    /** Set the time remaining on the timer to the given duration. Value will be bounded by provided maximum. */\n    set(duration, paused = false) {\n        const timestamp = this.parser.currentTimestamp;\n        const remaining = Math.max(this.minimum, Math.min(duration, this.maximum));\n        // Push a new state onto the history\n        this.history.push({\n            timestamp,\n            remaining,\n            paused,\n        });\n        // Remove any existing hook\n        if (this.hook) {\n            this.removeTimestampHook(this.hook);\n        }\n        // If we've not yet expired, and we're not paused, set up a hook to wait for that\n        if (!paused && remaining > 0) {\n            this.hook = this.addTimestampHook(timestamp + remaining, this.onExpiration);\n        }\n    }\n    /** @inheritdoc */\n    generateDataset() {\n        // Skip charting if they've not enabled it\n        if (!this.chartOptions) {\n            return;\n        }\n        // Translate state history into a dataset that makes sense for the chart\n        const startTime = this.parser.fight.start_time;\n        const endTime = this.parser.fight.end_time;\n        const data = [];\n        this.history.forEach(entry => {\n            const relativeTimestamp = entry.timestamp - startTime;\n            // Adjust preceeding data for the start of this state's window\n            const { length } = data;\n            if (length > 0 && relativeTimestamp < data[length - 1].t) {\n                // If we're updating prior to the previous entry's expiration, update the previous entry\n                // with its state at this point in time - we'll end up with two points showing the update on\n                // this timestamp.\n                const prev = data[length - 1];\n                prev.y = (prev.y || this.minimum / 1000) + ((prev.t - relativeTimestamp) / 1000);\n                prev.t = relativeTimestamp;\n            }\n            else {\n                // This window is starting fresh, not extending - insert a blank entry so the chart doesn't\n                // render a line from the previous.\n                data.push({ t: relativeTimestamp });\n            }\n            // Insert the data point for the start of this window.\n            // Skip for pauses, as the updated previous point will represent the start point of the pause\n            const chartY = (this.minimum + entry.remaining) / 1000;\n            if (!entry.paused) {\n                data.push({\n                    t: relativeTimestamp,\n                    y: chartY,\n                });\n            }\n            // If the state isn't paused, insert a data point for the time it will expire.\n            // This data point will be updated in the event of an extension.\n            if (!entry.paused && entry.remaining > 0) {\n                const time = Math.min(relativeTimestamp + entry.remaining, endTime - startTime);\n                const timeDelta = time - relativeTimestamp;\n                data.push({\n                    t: time,\n                    y: (this.minimum + entry.remaining - timeDelta) / 1000,\n                });\n            }\n        });\n        const { label, color } = this.chartOptions;\n        const dataSet = {\n            label,\n            data,\n            lineTension: 0,\n        };\n        if (color) {\n            /* tslint:disable:no-magic-numbers */\n            const chartColor = Color(color);\n            dataSet.backgroundColor = chartColor.fade(0.8).toString();\n            dataSet.borderColor = chartColor.fade(0.5).toString();\n            /* tslint:enable:no-magic-numbers */\n        }\n        return dataSet;\n    }\n    // Junk I wish I didn't need\n    setAddTimestampHook(value) {\n        this._addTimestampHook = value;\n    }\n    setRemoveTimestampHook(value) {\n        this._removeTimestampHook = value;\n    }\n}\n","import { t } from '@lingui/macro';\nimport TimeLineChart from 'components/ui/TimeLineChart';\nimport Module from 'parser/core/Module';\nimport React from 'react';\nimport { isDefined } from 'utilities';\nimport { TimerGauge } from './TimerGauge';\nexport class Gauge extends Module {\n    constructor() {\n        super(...arguments);\n        this.gauges = [];\n    }\n    init() {\n        this.addHook('death', { to: 'player' }, this.onDeath);\n    }\n    /** Add & initialise a gauge implementation to be tracked as part of the core gauge handling. */\n    add(gauge) {\n        gauge.setParser(this.parser);\n        // TODO: Work out how to remove this. Probably also the parser, too.\n        if (gauge instanceof TimerGauge) {\n            gauge.setAddTimestampHook(this.addTimestampHook.bind(this));\n            gauge.setRemoveTimestampHook(this.removeTimestampHook.bind(this));\n        }\n        this.gauges.push(gauge);\n        return gauge;\n    }\n    onDeath(event) {\n        this.gauges.forEach(gauge => gauge.reset());\n    }\n    output() {\n        // Generate a dataset from each registered gauge\n        const datasets = this.gauges\n            .map(gauge => gauge.generateDataset())\n            .filter(isDefined);\n        if (datasets.length < 1) {\n            return false;\n        }\n        const data = { datasets };\n        return <TimeLineChart data={data}/>;\n    }\n}\nGauge.handle = 'gauge';\nGauge.title = t('core.gauge.title') `Gauge`;\n","import Color from 'color';\nimport _ from 'lodash';\nimport { AbstractGauge } from './AbstractGauge';\nexport class CounterGauge extends AbstractGauge {\n    constructor(opts = {}) {\n        super(opts);\n        this.overCap = 0;\n        this.history = [];\n        this.minimum = opts.minimum || 0;\n        this._value = opts.initialValue || this.minimum;\n        this.maximum = opts.maximum || 100;\n        this.chartOptions = opts.chart;\n    }\n    get value() {\n        return this._value;\n    }\n    getValueAt(timestamp) {\n        const counter = _.findLast(this.history, gauge => gauge.timestamp <= timestamp);\n        return counter ? counter.value : this.minimum;\n    }\n    /** @inheritdoc */\n    reset() {\n        // NOTE: This assumes counters always reset to their minimum value.\n        // Should that not be the case, probbaly needs a `resetTo` value.\n        this.set(this.minimum);\n    }\n    /** Modify the current value by the provided amount. Equivalent to `set(currentValue + amount)` */\n    modify(amount) {\n        this.set(this._value + amount);\n    }\n    /** Set the current value of the gauge. Value will automatically be bounded to valid values. Value over the maximum will be tracked as overcap. */\n    set(value) {\n        this._value = Math.min(Math.max(value, this.minimum), this.maximum);\n        // TODO: underflow means tracking was out of sync - look into backtracking to adjust history?\n        const diff = value - this._value;\n        if (diff > 0) {\n            this.overCap += diff;\n        }\n        this.pushHistory();\n    }\n    /** Set a new minimum value for the gauge. Equivalent to `setBounds(newMin, currentMax)`. */\n    setMinimum(minimum) {\n        this.setBounds(minimum, this.maximum);\n    }\n    /** Set a new maximum value for the gauge. Equivalent to `setBounds(currentMin, newMax)`. */\n    setMaximum(maximum) {\n        this.setBounds(this.minimum, maximum);\n    }\n    /** Set new bounds for the gauge. If required, the current value will be updated to remain within bounds. */\n    setBounds(minimum, maximum) {\n        this.minimum = minimum;\n        this.maximum = maximum;\n        // Ensure the value remains within bounds by re-setting it\n        this.set(this._value);\n    }\n    pushHistory() {\n        const timestamp = this.parser.currentTimestamp;\n        // Ensure we're not generating multiple entries at the samt timestamp\n        const prevTimestamp = this.history.length\n            ? this.history[this.history.length - 1].timestamp\n            : NaN;\n        if (timestamp === prevTimestamp) {\n            this.history.pop();\n        }\n        this.history.push({\n            timestamp,\n            value: this._value,\n            minimum: this.minimum,\n            maximum: this.maximum,\n        });\n    }\n    /** @inheritdoc */\n    generateDataset() {\n        // If there's no chart options, provide nothing\n        if (!this.chartOptions) {\n            return;\n        }\n        // Map the data into something the chart will understand\n        const data = this.history.map(entry => ({\n            t: entry.timestamp - this.parser.fight.start_time,\n            y: entry.value,\n        }));\n        // Build the final data set\n        const { label, color } = this.chartOptions;\n        const dataSet = {\n            label,\n            data,\n            steppedLine: true,\n        };\n        if (color) {\n            /* tslint:disable:no-magic-numbers */\n            const chartColor = Color(color);\n            dataSet.backgroundColor = chartColor.fade(0.8).toString();\n            dataSet.borderColor = chartColor.fade(0.5).toString();\n            /* tslint:enable:no-magic-numbers */\n        }\n        return dataSet;\n    }\n}\n","export { Gauge } from './Gauge';\nexport { CounterGauge } from './CounterGauge';\nexport { TimerGauge } from './TimerGauge';\n","var createFind = require('./_createFind'),\n    findLastIndex = require('./findLastIndex');\n\n/**\n * This method is like `_.find` except that it iterates over elements of\n * `collection` from right to left.\n *\n * @static\n * @memberOf _\n * @since 2.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=collection.length-1] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * _.findLast([1, 2, 3, 4], function(n) {\n *   return n % 2 == 1;\n * });\n * // => 3\n */\nvar findLast = createFind(findLastIndex);\n\nmodule.exports = findLast;\n"],"sourceRoot":""}
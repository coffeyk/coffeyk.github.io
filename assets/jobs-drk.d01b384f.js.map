{"version":3,"sources":["webpack:///./src/components/ui/RotationTable.tsx","webpack:///./src/parser/core/modules/Cooldowns.js","webpack:///./src/components/ui/TimeLineChart.js","webpack:///./src/parser/core/modules/BuffWindow.tsx","webpack:///./src/parser/core/modules/GlobalCooldown.js","webpack:///./src/parser/core/modules/Statuses.js","webpack:///./src/parser/jobs/drk/modules/DISPLAY_ORDER.ts","webpack:///./src/parser/jobs/drk/modules/ResourceSimulator.js","webpack:///./src/parser/jobs/drk/modules/Cooldowns.js","webpack:///./src/parser/jobs/drk/modules/OGCDDowntime.ts","webpack:///./src/parser/jobs/drk/modules/Darkside.js","webpack:///./src/parser/jobs/drk/modules/BloodWeapon.tsx","webpack:///./src/parser/jobs/drk/modules/Delirium.tsx","webpack:///./src/parser/jobs/drk/modules/MultiHitSkills.js","webpack:///./src/parser/jobs/drk/modules/Statuses.js","webpack:///./src/parser/jobs/drk/modules/index.js"],"names":["RotationTable","React","Component","render","targets","notes","data","onGoto","headerTitle","this","props","compact","unstackable","celled","Header","Row","HeaderCell","collapsing","id","map","target","i","key","textAlign","header","note","Body","entry","start","targetAccessorResolver","accessor","targetsData","actual","expected","notesAccessorResolver","notesMap","TargetCell","Cell","positive","undefined","negative","end","rotation","style","marginRight","formatDuration","circular","size","icon","onClick","targetEntry","events","noteEntry","Cooldowns","Module","constructor","super","_cooldownGroups","_currentAction","_cooldowns","_groups","actions","_buildGroups","cooldownOrder","addHook","by","_onBeginCast","_onCast","_onComplete","groups","order","length","action","getAction","_buildGroup","content","name","group","merge","forEach","nestedGroups","opts","ItemGroup","showNested","timeline","addGroup","event","ability","guid","cooldown","startCooldown","cooldownGroup","startCooldownGroup","finishingCast","Object","keys","actionId","_addToTimeline","parseInt","cd","current","history","push","onGcd","use","shared","addItem","Item","type","timestamp","parser","fight","start_time","src","alt","getCooldown","originActionId","filter","sharedCooldown","currentFightDuration","currentTimestamp","resetCooldown","invulnTime","reduceCooldown","reduction","setInvulnTime","previousEndTimestamp","previousCooldown","isFirst","downtime","getDowntime","getCooldownRemaining","getTimeOnCooldown","considerInvulnTime","extension","reduce","time","status","getAdjustedTimeOnCooldown","duration","maximumDuration","handle","dependencies","DEFAULT_OPTIONS","aspectRatio","scales","xAxes","displayFormats","minute","second","millisecond","tooltipFormat","TimeLineChart","PureComponent","options","width","height","BuffWindowState","e","a","getActionCountByIds","actionsById","includes","BuffWindowModule","arguments","buffWindows","lastBuffWindow","init","onCast","onApplyBuff","onRemoveBuff","onComplete","autoAttack","activeBuffWindow","considerAction","buffStatus","startNewBuffWindow","startTime","getBaselineExpectedGCDs","buffWindow","expectedGCDs","expectedPerWindow","changeExpectedGCDsClassLogic","reduceExpectedGCDsEndOfFight","windowDurationMillis","fightTimeRemaining","end_time","gcdEstimate","globalCooldown","getEstimate","Math","ceil","getBaselineExpectedTrackedAction","changeExpectedTrackedActionClassLogic","getBuffWindowExpectedGCDs","getBuffWindowRequiredGCDsUsed","requiredGCDs","allowedGCDsById","getBuffWindowExpectedTrackedActions","getBuffWindowNotes","missedGCDs","sum","max","gcds","suggestions","add","TieredSuggestion","buffAction","suggestionContent","tiers","severityTiers","value","why","invalidGCDs","trackedActions","missedActions","trackedAction","trackedBadActions","badActions","output","rotationTargets","notesData","showName","rotationTableNotesColumnHeader","rotationData","windowStart","windowEnd","missedgcd","badgcd","show","rotationTableHeader","title","__decorate","dependency","__metadata","Data","prototype","Suggestions","Timeline","GlobalCooldown","MIN_GCD","MAX_GCD","BASE_GCD","CASTER_TAX","DEBUG_LOG_SAVED_GCDS","_castingEvent","_estimatedBaseGcd","_estimateGcdCount","_lastGcd","isInstant","gcdGroupId","normalise","byPlayer","hasBeginCast","relevantEvent","saveGcd","_debugLogSavedGcds","gcd","formatTimestamp","instant","taxed","casterTaxed","console","log","normalizedLength","speedMod","Group","_getGcdLength","estimate","statistics","SimpleStatistic","ATTACK","info","gcdInfo","speedmod","get","castTime","isCasterTaxed","gcdLength","round","correctedCooldown","gcdRecast","normaliseWith","normalizedGcd","bound","lengths","math","mean","mode","min","getUptime","carry","cooldownRatio","STATUS_APPLY_ON_PARTY_THRESHOLD_MILLISECONDS","Statuses","_statuses","_statusToActionMap","_actionToMergeNameMap","byFilter","player","pets","p","_onApply","_onRefresh","_onRemove","cooldowns","ac","values","statusesApplied","statusKey","statuses","_isStatusAppliedToPet","_addStatus","_endPrevStatus","getStatus","statusEntry","prev","usages","some","it","abs","_createGroupForStatus","st","stid","statusesStackMapping","attachToGroup","report","friendlyPets","targetID","DISPLAY_ORDER","BLOODSPILLER_BLOOD_COST","FLOOD_EDGE_MP_COST","MAX_MP","MP_AFTER_RAISE","MP_REGEN_PER_TICK","TICK_RATE","MAX_BLOOD","RESOURCE_SPENDERS","ACTIONS","THE_BLACKEST_NIGHT","mp","blood","FLOOD_OF_SHADOW","EDGE_OF_SHADOW","BLOODSPILLER","QUIETUS","LIVING_SHADOW","RESOURCE_GENERATORS","CARVE_AND_SPIT","requiresCombo","SYPHON_STRIKE","SOULEATER","STALWART_SOUL","BLOOD_WEAPON_GENERATORS","HARD_SLASH","UNMEND","UNLEASH","DELIRIUM_GENERATORS","SEVERITY_THE_BLACKEST_NIGHT","1","SEVERITY","MEDIUM","2","MAJOR","SEVERITY_WASTED_BLOOD_ACTIONS","MINOR","4","SEVERITY_WASTED_MP_ACTIONS","5","Resources","_currentBlood","_wastedBlood","_currentMP","_wastedMP","_history","_lastManaSpendEvent","_gainedSinceLastSpend","_darkArtsProc","_droppedTBNs","_resourceEvents","Number","abilityId","_onEvent","_onCastBlackestNight","STATUSES","BLACKEST_NIGHT","_onRemoveBlackestNight","_onDeath","_onRaise","checkMPOvercap","beforeActionMP","actionMPChange","lastSpendActionMP","timeSinceLastSpendAction","firstSpendAction","afterActionMP","manaTicks","floor","_pushToMPGraph","checkBloodOvercap","actionBloodChange","_pushToBloodGraph","t","y","actionBloodGain","actionMPGain","hasOwnProperty","combatants","selected","hasStatus","DELIRIUM","successfulHit","BLOOD_WEAPON","sourceResources","absorb","wastedBloodActions","wastedMPActions","_bloodColor","Color","JOBS","DARK_KNIGHT","colour","_mpColor","bloodchartdata","datasets","label","steppedLine","backgroundColor","fade","borderColor","mpchartdata","yAxes","ticks","beginAtZero","displayMode","DISPLAY_MODE","FULL","displayOrder","RESOURCES","CoreCooldowns","PLUNGE","SALTED_EARTH","ABYSSAL_DRAIN","LIVING_DEAD","SHADOW_WALL","RAMPART","DARK_MIND","REPRISAL","DARK_MISSIONARY","PROVOKE","SHIRK","INTERJECT","LOW_BLOW","DEFAULT_FIRST_USE_OFFSET","OGCDDowntime","CooldownDowntime","defaultFirstUseOffset","trackedCds","firstUseOffset","DARKSIDE_MAX_DURATION","DARKSIDE_EXTENSION","INITIAL_APPLICATION_FORGIVENESS","Darkside","_currentDuration","_downtime","_lastEventTime","_updateDarkside","to","elapsedTime","fightDuration","death","deadTime","uptime","checklist","Rule","description","requirements","Requirement","percent","BloodWeapon","3","Delirium","REQUIRED_MULTI_HIT_TARGETS","SEVERITY_LOW_TARGET_ATTACKS","LOW","MultiHit","_incorrectMultihitSkills","_checkMultiHitSkill","hits","lowTargetAttacks","prop","CoreStatuses","WALKING_DEAD","ResourceSimulator","MultiHitSkills"],"mappings":"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","file":"assets/jobs-drk.d01b384f.js","sourcesContent":["import { Trans } from '@lingui/react';\nimport Rotation from 'components/ui/Rotation';\nimport React from 'react';\nimport { Button, Table } from 'semantic-ui-react';\nimport { formatDuration } from 'utilities';\nexport class RotationTable extends React.Component {\n    render() {\n        const { targets, notes, data, onGoto, headerTitle, } = this.props;\n        return <Table compact unstackable celled>\n\t\t\t<Table.Header>\n\t\t\t\t<Table.Row>\n\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t<strong><Trans id=\"core.ui.rotation-table.header.time\">Time</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(targets || []).map((target, i) => <Table.HeaderCell key={`target_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{target.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t\t<Table.HeaderCell>\n\t\t\t\t\t\t<strong>{(headerTitle) ? headerTitle : <Trans id=\"core.ui.rotation-table.header.rotation\">Rotation</Trans>}</strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(notes || []).map((note, i) => <Table.HeaderCell key={`note_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{note.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Header>\n\t\t\t<Table.Body>\n\t\t\t\t{data.map((entry) => <RotationTable.Row key={entry.start} onGoto={onGoto} targets={targets || []} notes={notes || []} {...entry}/>)}\n\t\t\t</Table.Body>\n\t\t</Table>;\n    }\n}\nRotationTable.targetAccessorResolver = (entry, target) => {\n    if (typeof target.accessor === 'string' && entry.targetsData != null) {\n        return entry.targetsData[target.accessor];\n    }\n    else if (typeof target.accessor === 'function') {\n        return target.accessor(entry);\n    }\n    else {\n        return {\n            actual: 0,\n            expected: 0,\n        };\n    }\n};\nRotationTable.notesAccessorResolver = (entry, note) => {\n    if (typeof note.accessor === 'string' && entry.notesMap != null) {\n        return entry.notesMap[note.accessor];\n    }\n    else if (typeof note.accessor === 'function') {\n        return note.accessor(entry);\n    }\n    else {\n        return null;\n    }\n};\nRotationTable.TargetCell = ({ actual, expected }) => <Table.Cell textAlign=\"center\" positive={expected === undefined ? false : actual >= expected} negative={expected === undefined ? false : actual < expected}>\n\t\t\t{actual}/{expected === undefined ? '-' : expected}\n\t\t</Table.Cell>;\nRotationTable.Row = ({ onGoto, targets, notes, notesMap, start, end, targetsData, rotation }) => <Table.Row>\n\t\t\t<Table.Cell textAlign=\"center\">\n\t\t\t\t<span style={{ marginRight: 5 }}>{formatDuration(start / 1000)}</span>\n\t\t\t\t{typeof onGoto === 'function' && <Button circular compact size=\"mini\" icon=\"time\" onClick={() => onGoto(start, end)}/>}\n\t\t\t</Table.Cell>\n\t\t\t{targets\n    .map(target => RotationTable.targetAccessorResolver({ start, end, targetsData, rotation }, target))\n    .map((targetEntry, i) => <RotationTable.TargetCell key={`target_${i}`} {...targetEntry}/>)}\n\t\t\t<Table.Cell>\n\t\t\t\t<Rotation events={rotation}/>\n\t\t\t</Table.Cell>\n\t\t\t{notes\n    .map(note => RotationTable.notesAccessorResolver({ start, end, targetsData, notesMap, rotation }, note))\n    .map((noteEntry, i) => <Table.Cell key={`notes_${i}`} textAlign=\"center\">\n\t\t\t\t\t\t\t{noteEntry}\n\t\t\t\t\t\t</Table.Cell>)}\n\t\t</Table.Row>;\n","import _ from 'lodash';\nimport Module from 'parser/core/Module';\nimport { ItemGroup, Item } from './Timeline';\nimport React from 'react';\n// Track the cooldowns on actions and shit\nexport default class Cooldowns extends Module {\n    constructor(...args) {\n        super(...args);\n        this._cooldownGroups = {};\n        this._currentAction = null;\n        this._cooldowns = {};\n        this._groups = {};\n        this._cooldownGroups = _.groupBy(this.data.actions, 'cooldownGroup');\n        // Pre-build groups for actions explicitly set by subclasses\n        this._buildGroups(this.constructor.cooldownOrder);\n        this.addHook('begincast', { by: 'player' }, this._onBeginCast);\n        this.addHook('cast', { by: 'player' }, this._onCast);\n        this.addHook('complete', this._onComplete);\n    }\n    _buildGroups(groups) {\n        // If there's no groups, noop\n        if (!groups) {\n            return;\n        }\n        const ids = groups.map((data, i) => {\n            const order = -(groups.length - i);\n            // If it's just an action id, build a group for it and stop\n            if (typeof data === 'number') {\n                const action = this.data.getAction(data);\n                this._buildGroup({\n                    id: data,\n                    content: action && action.name,\n                    order,\n                });\n                return data;\n            }\n            // Build the base group\n            const group = this._buildGroup({\n                id: data.name,\n                content: data.name,\n                order,\n            });\n            if (data.merge) {\n                // If it's a merge group, we only need to register our group for each of the IDs\n                data.actions.forEach(id => {\n                    this._groups[id] = group;\n                });\n            }\n            else {\n                // Otherwise, build nested groups for each action\n                group.nestedGroups = this._buildGroups(data.actions);\n            }\n            return data.name;\n        });\n        return ids;\n    }\n    _buildGroup(opts) {\n        const group = new ItemGroup({ showNested: false, ...opts });\n        this.timeline.addGroup(group);\n        this._groups[opts.id] = group;\n        return group;\n    }\n    // cooldown starts at the beginning of the casttime\n    // (though 99% of CD based abilities have no cast time)\n    // TODO: Should I be tracking pet CDs too? I mean, contagion/radiant are a thing.\n    _onBeginCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.cooldown == null) {\n            return;\n        }\n        this._currentAction = action;\n        this.startCooldown(action.id);\n        if (!_.isNil(action.cooldownGroup)) {\n            this.startCooldownGroup(action.id, action.cooldownGroup);\n        }\n    }\n    _onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.cooldown == null) {\n            return;\n        }\n        const finishingCast = this._currentAction && this._currentAction.id === action.id;\n        this._currentAction = null;\n        if (finishingCast) {\n            return;\n        }\n        this.startCooldown(action.id);\n        if (!_.isNil(action.cooldownGroup)) {\n            this.startCooldownGroup(action.id, action.cooldownGroup);\n        }\n    }\n    _onComplete() {\n        Object.keys(this._cooldowns).forEach(actionId => {\n            this._addToTimeline(parseInt(actionId, 10));\n        });\n    }\n    _addToTimeline(actionId) {\n        const cd = this._cooldowns[actionId];\n        if (!cd) {\n            return false;\n        }\n        // Clean out any 'current' cooldowns into the history\n        if (cd.current) {\n            cd.history.push(cd.current);\n            cd.current = null;\n        }\n        const action = this.data.getAction(actionId);\n        // If the action is on the GCD, GlobalCooldown will be managing its own group\n        if (!action || action.onGcd) {\n            return false;\n        }\n        // Ensure we've got a group for this item\n        if (!this._groups[actionId]) {\n            this._buildGroup({\n                id: actionId,\n                content: action.name,\n                order: actionId,\n            });\n        }\n        // Add CD info to the timeline\n        cd.history\n            .forEach(use => {\n            if (!use.shared) {\n                this._groups[actionId].addItem(new Item({\n                    type: 'background',\n                    start: use.timestamp - this.parser.fight.start_time,\n                    length: use.length,\n                    content: <img src={action.icon} alt={action.name}/>,\n                }));\n            }\n        });\n        return true;\n    }\n    getCooldown(actionId) {\n        return this._cooldowns[actionId] || {\n            current: null,\n            history: [],\n        };\n    }\n    startCooldownGroup(originActionId, cooldownGroup) {\n        const sharedCooldownActions = _.get(this._cooldownGroups, cooldownGroup, []);\n        sharedCooldownActions\n            .map(action => action.id)\n            .filter(id => id !== originActionId)\n            .forEach(id => this.startCooldown(id, true));\n    }\n    startCooldown(actionId, sharedCooldown = false) {\n        // TODO: handle shared CDs\n        const action = this.data.getAction(actionId);\n        if (!action) {\n            return;\n        }\n        // Get the current cooldown status, falling back to a new cooldown\n        const cd = this.getCooldown(actionId);\n        // If there's a current object, move it into the history\n        // TODO: handle errors on CD overlap\n        if (cd.current) {\n            const currentFightDuration = this.parser.currentTimestamp - this.parser.fight.start_time;\n            if (cd.current.timestamp < this.parser.fight.start_time && cd.current.length > currentFightDuration) {\n                // Pre-pull usage, reset the cooldown to prevent overlap on timeline since we don't know exactly when cooldown was used pre-pull\n                this.resetCooldown(actionId);\n            }\n            else {\n                cd.history.push(cd.current);\n            }\n        }\n        cd.current = {\n            timestamp: this.parser.currentTimestamp,\n            length: action.cooldown * 1000,\n            shared: sharedCooldown,\n            invulnTime: 0,\n        };\n        // Save the info back out (to ensure propagation if we've got a new info)\n        this._cooldowns[actionId] = cd;\n    }\n    reduceCooldown(actionId, reduction) {\n        const cd = this.getCooldown(actionId);\n        const currentTimestamp = this.parser.currentTimestamp;\n        // Check if current isn't current\n        if (cd.current && cd.current.timestamp + cd.current.length < currentTimestamp) {\n            cd.history.push(cd.current);\n            cd.current = null;\n        }\n        // TODO: Do I need to warn if they're reducing cooldown on something _with_ no cooldown?\n        if (cd.current === null) {\n            return;\n        }\n        // Reduce the CD\n        cd.current.length -= reduction * 1000;\n        // If the reduction would have made it come off CD earlier than now, reset it - the extra time reduction should be lost.\n        if (cd.current.timestamp + cd.current.length < currentTimestamp) {\n            this.resetCooldown(actionId);\n        }\n    }\n    setInvulnTime(actionId) {\n        const cd = this.getCooldown(actionId);\n        let previousEndTimestamp = this.parser.fight.start_time;\n        let previousCooldown = {};\n        let isFirst = true;\n        for (const cooldown of cd.history) {\n            if (isFirst) {\n                previousEndTimestamp = (cooldown.timestamp + cooldown.length);\n                isFirst = false;\n                previousCooldown = cooldown;\n            }\n            //We invuln time is the time the boss was invuln from when the CD came off CD and when it was next executed\n            previousCooldown.invulnTime = this.downtime.getDowntime(previousEndTimestamp, cooldown.timestamp);\n            previousEndTimestamp = (cooldown.timestamp + cooldown.length);\n            previousCooldown = cooldown;\n        }\n    }\n    resetCooldown(actionId) {\n        const cd = this.getCooldown(actionId);\n        // If there's nothing running, we can just stop\n        // TODO: need to warn?\n        if (cd.current === null) {\n            return;\n        }\n        // Fix up the length\n        cd.current.length = this.parser.currentTimestamp - cd.current.timestamp;\n        // Move the CD into the history\n        cd.history.push(cd.current);\n        cd.current = null;\n    }\n    getCooldownRemaining(actionId) {\n        const current = this.getCooldown(actionId).current;\n        if (!current) {\n            return 0;\n        }\n        return current.length - (this.parser.currentTimestamp - current.timestamp);\n    }\n    // TODO: Should this be here?\n    getTimeOnCooldown(actionId, considerInvulnTime = false, extension = 0) {\n        const cd = this.getCooldown(actionId);\n        const currentTimestamp = this.parser.currentTimestamp;\n        if (considerInvulnTime) {\n            this.setInvulnTime(actionId);\n        }\n        else {\n            cd.history.map(cooldown => {\n                cooldown.invulnTime = 0;\n            });\n        }\n        return cd.history.reduce((time, status) => time + this.getAdjustedTimeOnCooldown(status, currentTimestamp, extension), cd.current ? this.getAdjustedTimeOnCooldown(cd.current, currentTimestamp, extension) : 0);\n    }\n    getAdjustedTimeOnCooldown(cooldown, currentTimestamp, extension) {\n        // Doesn't count time on CD outside the bounds of the current fight, it'll throw calcs off\n        // Add to the length of the cooldown any invuln time for the boss\n        // Additionally account for any extension the caller allowed to the CD Length\n        const duration = currentTimestamp - cooldown.timestamp;\n        const maximumDuration = cooldown.length + cooldown.invulnTime + extension;\n        return _.clamp(duration, 0, maximumDuration);\n    }\n    get used() {\n        return Object.keys(this._cooldowns);\n    }\n}\nCooldowns.handle = 'cooldowns';\nCooldowns.dependencies = [\n    'data',\n    'downtime',\n    'timeline',\n];\n// Array used to sort cooldowns in the timeline. Elements should be either IDs for\n// top-level groups, or objects of the format {name: string, actions: array} for\n// nested groups. Actions not specified here will be sorted by their ID below.\n// Check the NIN and SMN modules for examples.\nCooldowns.cooldownOrder = [];\n","import _ from 'lodash';\nimport PropTypes from 'prop-types';\nimport React, { PureComponent } from 'react';\nimport { Line } from 'react-chartjs-2';\nconst DEFAULT_OPTIONS = {\n    aspectRatio: 3,\n    scales: {\n        xAxes: [{\n                type: 'time',\n                time: {\n                    displayFormats: {\n                        minute: 'm:ss',\n                        second: 'm:ss',\n                        millisecond: 'm:ss.SS',\n                    },\n                    // This tooltip format displays similar to a \"relative\" timestamp,\n                    // since react assumes UNIX epoch timestamps for the data.\n                    tooltipFormat: 'mm:ss.SSS',\n                },\n            }],\n    },\n};\nexport default class TimeLineChart extends PureComponent {\n    render() {\n        const options = _.merge({}, DEFAULT_OPTIONS, this.props.options || {});\n        return <Line data={this.props.data} options={options} \n        // Using this trash 'cus aspectRatio doesn't work with the react wrapper\n        width={options.aspectRatio} height={1}/>;\n    }\n}\nTimeLineChart.propTypes = {\n    data: PropTypes.object.isRequired,\n    options: PropTypes.object,\n};\n","import { __decorate, __metadata } from \"tslib\";\nimport { t } from '@lingui/macro';\nimport { Plural, Trans } from '@lingui/react';\nimport { ActionLink } from 'components/ui/DbLink';\nimport { RotationTable } from 'components/ui/RotationTable';\nimport _ from 'lodash';\nimport Module, { dependency } from 'parser/core/Module';\nimport GlobalCooldown from 'parser/core/modules/GlobalCooldown';\nimport Suggestions, { TieredSuggestion } from 'parser/core/modules/Suggestions';\nimport Timeline from 'parser/core/modules/Timeline';\nimport React from 'react';\nimport { Data } from './Data';\nexport class BuffWindowState {\n    constructor(data, start) {\n        this.rotation = [];\n        this.data = data;\n        this.start = start;\n    }\n    get gcds() {\n        // TODO: Investigate removing the reliance on data here.\n        return this.rotation\n            .map(e => this.data.getAction(e.ability.guid))\n            .filter(a => a && a.onGcd)\n            .length;\n    }\n    getActionCountByIds(actionsById) {\n        return this.rotation\n            .filter(e => actionsById.includes(e.ability.guid))\n            .length;\n    }\n}\nexport class BuffWindowModule extends Module {\n    constructor() {\n        super(...arguments);\n        this.buffWindows = [];\n    }\n    get activeBuffWindow() {\n        const lastBuffWindow = _.last(this.buffWindows);\n        if (lastBuffWindow && lastBuffWindow.end == null) {\n            return lastBuffWindow;\n        }\n        return undefined;\n    }\n    init() {\n        this.addHook('cast', { by: 'player' }, this.onCast);\n        this.addHook('applybuff', { by: 'player' }, this.onApplyBuff);\n        this.addHook('removebuff', { by: 'player' }, this.onRemoveBuff);\n        this.addHook('complete', this.onComplete);\n    }\n    onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.autoAttack) {\n            // Disregard auto attacks for tracking rotations / events during buff windows\n            return;\n        }\n        if (this.activeBuffWindow && this.considerAction(action)) {\n            this.activeBuffWindow.rotation.push(event);\n        }\n    }\n    /**\n     * This method MAY be overridden to return true or false, indicating whether or not this action should be considered within the buff window\n     * If false is returned, the action will not be tracked AT ALL within the buff window, and will NOT appear within the Rotation column\n     * @param action\n     */\n    considerAction(action) {\n        return true;\n    }\n    onApplyBuff(event) {\n        if (!this.buffStatus || event.ability.guid !== this.buffStatus.id) {\n            return;\n        }\n        this.startNewBuffWindow(event.timestamp);\n    }\n    startNewBuffWindow(startTime) {\n        this.buffWindows.push(new BuffWindowState(this.data, startTime));\n    }\n    onRemoveBuff(event) {\n        if (!this.buffStatus || event.ability.guid !== this.buffStatus.id) {\n            return;\n        }\n        if (this.activeBuffWindow) {\n            this.activeBuffWindow.end = event.timestamp;\n        }\n    }\n    /**\n     * For consumers that have the same number of expected GCDs per window, this will use the expectedPerWindow property\n     *   on expectedGCDs as the baseline\n     * This method MAY be overridden if the logic of expected GCDs per window is variable\n     * @param buffWindow\n     */\n    getBaselineExpectedGCDs(buffWindow) {\n        if (this.expectedGCDs) {\n            return this.expectedGCDs.expectedPerWindow;\n        }\n        return 0;\n    }\n    /**\n     * This method MAY be overridden to provide class-specific rushing logic per BuffWindow - default is no effect\n     * Return a positive number to INCREASE expected GCDs for this window, or a negative number to DECREASE\n     * @param buffWindow\n     */\n    changeExpectedGCDsClassLogic(buffWindow) {\n        return 0;\n    }\n    /**\n     * Handles rushing logic to reduce expected GCDs in a window for end of fight rushing\n     * This method MAY be overridden if class rules for end of fight rushing vary\n     * @param buffWindow\n     */\n    reduceExpectedGCDsEndOfFight(buffWindow) {\n        if (this.buffStatus.duration) {\n            // Check to see if this window is rushing due to end of fight - reduce expected GCDs accordingly\n            const windowDurationMillis = this.buffStatus.duration * 1000;\n            const fightTimeRemaining = this.parser.fight.end_time - buffWindow.start;\n            if (windowDurationMillis >= fightTimeRemaining) {\n                const gcdEstimate = this.globalCooldown.getEstimate();\n                return Math.ceil((windowDurationMillis - fightTimeRemaining) / gcdEstimate);\n            }\n        }\n        // Default: no rushing reduction\n        return 0;\n    }\n    /**\n     * For consumers that have tracked actions that expect the same number of usages per window, this will use the\n     *   expectedPerWindow property on that action as the baseline\n     * This method MAY be overridden if the logic of expected tracked actions per window is variable\n     * @param buffWindow\n     * @param action\n     */\n    getBaselineExpectedTrackedAction(buffWindow, action) {\n        return action.expectedPerWindow || 0;\n    }\n    /**\n     * This method MAY be overridden to provide class-specific logic to change expected uses of a tracked action per BuffWindow - default no effect\n     * Return a positive number to INCREASE expected tracked action usages for this window, or a negative number to DECREASE\n     * @param buffWindow\n     * @param action\n     */\n    changeExpectedTrackedActionClassLogic(buffWindow, action) {\n        return 0;\n    }\n    getBuffWindowExpectedGCDs(buffWindow) {\n        return this.getBaselineExpectedGCDs(buffWindow) + this.changeExpectedGCDsClassLogic(buffWindow) - this.reduceExpectedGCDsEndOfFight(buffWindow);\n    }\n    /**\n     * This method MAY be overridden to provide class-specific logic to determine if the required GCD(s) were used during a given BuffWindow\n     * Classes whose required GCD list vary per window should override this function.\n     * Function MUST return a number of CORRECT GCDs used within the window\n     * @param buffWindow\n     */\n    getBuffWindowRequiredGCDsUsed(buffWindow) {\n        if (!this.requiredGCDs) {\n            return 0;\n        }\n        const allowedGCDsById = this.requiredGCDs.actions.map(a => a.id);\n        return buffWindow.getActionCountByIds(allowedGCDsById);\n    }\n    getBuffWindowExpectedTrackedActions(buffWindow, action) {\n        return this.getBaselineExpectedTrackedAction(buffWindow, action) + this.changeExpectedTrackedActionClassLogic(buffWindow, action);\n    }\n    /**\n     * This method will be called if and only if the rotationTableNotesColumnHeader property is set, to add a notes field for each buff window\n     * Implementing classes MUST define their logic to determine what note to display for each buff window within this method\n     * @param buffWindow\n     */\n    getBuffWindowNotes(buffWindow) {\n        return undefined;\n    }\n    onComplete() {\n        if (this.expectedGCDs) {\n            const missedGCDs = this.buffWindows\n                .reduce((sum, buffWindow) => {\n                const expectedGCDs = this.getBuffWindowExpectedGCDs(buffWindow);\n                return sum + Math.max(0, expectedGCDs - buffWindow.gcds);\n            }, 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.buffAction.icon,\n                content: this.expectedGCDs.suggestionContent,\n                tiers: this.expectedGCDs.severityTiers,\n                value: missedGCDs,\n                why: <Trans id=\"core.buffwindow.suggestions.missedgcd.why\">\n\t\t\t\t\t{missedGCDs} <Plural value={missedGCDs} one=\"GCD was\" other=\"GCDs were\"/> missed during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n        if (this.requiredGCDs) {\n            const invalidGCDs = this.buffWindows\n                .reduce((sum, buffWindow) => sum + Math.max(0, buffWindow.gcds - this.getBuffWindowRequiredGCDsUsed(buffWindow)), 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.requiredGCDs.icon,\n                content: this.requiredGCDs.suggestionContent,\n                tiers: this.requiredGCDs.severityTiers,\n                value: invalidGCDs,\n                why: <Trans id=\"core.buffwindow.suggestions.badgcd.why\">\n\t\t\t\t\t{invalidGCDs} incorrect <Plural value={invalidGCDs} one=\"GCD was\" other=\"GCDs were\"/> used during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n        if (this.trackedActions) {\n            const missedActions = this.trackedActions.actions\n                .reduce((sum, trackedAction) => sum + this.buffWindows\n                .reduce((sum, buffWindow) => sum + Math.max(0, trackedAction.expectedPerWindow - buffWindow.getActionCountByIds([trackedAction.action.id])), 0), 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.trackedActions.icon,\n                content: this.trackedActions.suggestionContent,\n                tiers: this.trackedActions.severityTiers,\n                value: missedActions,\n                why: <Trans id=\"core.buffwindow.suggestions.trackedaction.why\">\n\t\t\t\t\t<Plural value={missedActions} one=\"# use of a recommended cooldown was\" other=\"# uses of recommended cooldowns were\"/> missed during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n        if (this.trackedBadActions) {\n            const badActions = this.trackedBadActions.actions\n                .reduce((sum, trackedAction) => sum + this.buffWindows\n                .reduce((sum, buffWindow) => sum + Math.max(0, buffWindow.getActionCountByIds([trackedAction.action.id]) - trackedAction.expectedPerWindow), 0), 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.trackedBadActions.icon,\n                content: this.trackedBadActions.suggestionContent,\n                tiers: this.trackedBadActions.severityTiers,\n                value: badActions,\n                why: <Trans id=\"core.buffwindow.suggestions.trackedbadaction.why\">\n\t\t\t\t\t<Plural value={badActions} one=\"# use of\" other=\"# uses of\"/> cooldowns that should be avoided during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n    }\n    output() {\n        const rotationTargets = [];\n        const notesData = [];\n        if (this.expectedGCDs) {\n            rotationTargets.push({\n                header: <Trans id=\"core.buffwindow.table.header.gcds\">GCDs</Trans>,\n                accessor: 'missedgcd',\n            });\n        }\n        if (this.requiredGCDs) {\n            rotationTargets.push({\n                header: <img src={this.requiredGCDs.icon} alt=\"\" style={{ height: '20px' }}/>,\n                accessor: 'badgcd',\n            });\n        }\n        if (this.trackedActions) {\n            this.trackedActions.actions.forEach((trackedAction) => {\n                rotationTargets.push({\n                    header: <ActionLink showName={false} {...trackedAction.action}/>,\n                    accessor: trackedAction.action.name,\n                });\n            });\n        }\n        if (this.rotationTableNotesColumnHeader) {\n            notesData.push({\n                header: this.rotationTableNotesColumnHeader,\n                accessor: 'notes',\n            });\n        }\n        const rotationData = this.buffWindows\n            .map(buffWindow => {\n            const windowStart = buffWindow.start - this.parser.fight.start_time;\n            const windowEnd = (buffWindow.end != null ? buffWindow.end : buffWindow.start) - this.parser.fight.start_time;\n            const targetsData = {};\n            const notesMap = {};\n            if (this.expectedGCDs) {\n                targetsData.missedgcd = {\n                    actual: buffWindow.gcds,\n                    expected: this.getBuffWindowExpectedGCDs(buffWindow),\n                };\n            }\n            if (this.requiredGCDs) {\n                targetsData.badgcd = {\n                    actual: this.getBuffWindowRequiredGCDsUsed(buffWindow),\n                    expected: this.getBuffWindowExpectedGCDs(buffWindow),\n                };\n            }\n            if (this.trackedActions) {\n                this.trackedActions.actions.forEach((trackedAction) => {\n                    targetsData[trackedAction.action.name] = {\n                        actual: buffWindow.getActionCountByIds([trackedAction.action.id]),\n                        expected: this.getBuffWindowExpectedTrackedActions(buffWindow, trackedAction),\n                    };\n                });\n            }\n            if (this.rotationTableNotesColumnHeader) {\n                notesMap.notes = this.getBuffWindowNotes(buffWindow);\n            }\n            return {\n                start: windowStart,\n                end: windowEnd,\n                targetsData,\n                rotation: buffWindow.rotation,\n                notesMap,\n            };\n        });\n        return <RotationTable targets={rotationTargets} data={rotationData} notes={notesData} onGoto={this.timeline.show} headerTitle={this.rotationTableHeader}/>;\n    }\n}\nBuffWindowModule.handle = 'buffwindow';\nBuffWindowModule.title = t('core.buffwindow.title') `Buff Window`;\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Data)\n], BuffWindowModule.prototype, \"data\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Suggestions)\n], BuffWindowModule.prototype, \"suggestions\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Timeline)\n], BuffWindowModule.prototype, \"timeline\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", GlobalCooldown)\n], BuffWindowModule.prototype, \"globalCooldown\", void 0);\n","import { t } from '@lingui/macro';\nimport { Trans } from '@lingui/react';\nimport math from 'mathjsCustom';\nimport React from 'react';\nimport Module from 'parser/core/Module';\nimport { Group, Item } from './Timeline';\nimport { SimpleStatistic } from './Statistics';\nconst MIN_GCD = 1500;\nconst MAX_GCD = 2500;\nconst BASE_GCD = 2500;\nconst CASTER_TAX = 100;\nconst DEBUG_LOG_SAVED_GCDS = false && process.env.NODE_ENV !== 'production';\n// NOTE: Caster tax refers to spells taking 0.1s longer than their tooltip claims if their cast time is at least as long as their recast time.\n// See https://www.reddit.com/r/ffxiv/comments/8s05rn/the_recast_time_on_your_tooltip_can_be_up_to_85/, specifically:\n//    There is also another issue that influences how long recast times actually take that isnt as heavily influenced by fps but is still affected,\n//    which is animation delay that happen between casts, this means that if you have a spell with a cast time that is equal to or\n//    greater than the recast time you will end up taking longer between casts than the (re)cast time. The delay is around 100 ms at 100+ fps\nexport default class GlobalCooldown extends Module {\n    constructor(...args) {\n        super(...args);\n        this._castingEvent = null;\n        this._estimatedBaseGcd = null;\n        this._estimateGcdCount = -1;\n        this._lastGcd = {\n            isInstant: false,\n            event: null,\n        };\n        this.gcds = [];\n        this.gcdGroupId = 'gcd';\n        this.addHook('complete', this._onComplete);\n    }\n    // Using normalise so the estimate can be used throughout the parse\n    normalise(events) {\n        for (let i = 0; i < events.length; i++) {\n            const event = events[i];\n            // Only care about player GCDs\n            if (!this.parser.byPlayer(event) || !event.ability) {\n                continue;\n            }\n            const action = this.data.getAction(event.ability.guid);\n            if (!action || !action.onGcd) {\n                continue;\n            }\n            // eslint-disable-next-line default-case\n            switch (event.type) {\n                // wowa uses beginchannel for this...? need info for flamethrower/that ast skill/passage of arms\n                case 'begincast':\n                    // Can I check for cancels?\n                    this._castingEvent = event;\n                    break;\n                case 'cast':\n                    const hasBeginCast = this._castingEvent !== null && this._castingEvent.ability.guid === action.id;\n                    const relevantEvent = hasBeginCast ? this._castingEvent : event;\n                    this.saveGcd({ ...this._lastGcd }, relevantEvent.timestamp); // Save last gcd with current timestamp\n                    this._lastGcd.isInstant = !hasBeginCast;\n                    this._lastGcd.event = relevantEvent;\n                    this._castingEvent = null;\n                    break;\n            }\n        }\n        if (events.length) {\n            this.saveGcd({ ...this._lastGcd }, events[events.length - 1].timestamp);\n        }\n        this._debugLogSavedGcds();\n        return events;\n    }\n    _debugLogSavedGcds() {\n        if (!DEBUG_LOG_SAVED_GCDS) {\n            return;\n        }\n        // NOTE: Please sanity-check results when changing normalise or saveGcd. Good test cases include:\n        // - Attributing 1.5s and 2.2s to correct RDM melee gcds\n        // - Sub-0.5s speedmod for BLM fast-casts and correct Instant/CasterTaxed flagging\n        // - Correct timestamp for last event before long gaps (ie: Kefka normal)\n        this.gcds.forEach((gcd) => {\n            const timestamp = this.parser.formatTimestamp(gcd.timestamp);\n            const action = this.data.getAction(gcd.actionId);\n            const instant = gcd.isInstant ? ' Instant' : '';\n            const taxed = gcd.casterTaxed ? ' CasterTaxed' : '';\n            console.log(`${timestamp} ${action.name}[${gcd.length}|${gcd.normalizedLength}] Speedmod[${gcd.speedMod}]${instant}${taxed}`);\n        });\n    }\n    _onComplete() {\n        const startTime = this.parser.fight.start_time;\n        // Timeline output\n        // TODO: Look into adding items to groups? Maybe?\n        this.timeline.addGroup(new Group({\n            id: this.gcdGroupId,\n            content: 'GCD',\n            order: -99,\n        }));\n        this.gcds.forEach(gcd => {\n            const action = this.data.getAction(gcd.actionId);\n            if (!action) {\n                return;\n            }\n            this.timeline.addItem(new Item({\n                type: 'background',\n                start: gcd.timestamp - startTime,\n                length: this._getGcdLength(gcd),\n                title: action.name,\n                group: this.gcdGroupId,\n                content: <img src={action.icon} alt={action.name} title={action.name}/>,\n            }));\n        });\n        // Statistic box\n        const estimate = this.getEstimate(false);\n        this.statistics.add(new SimpleStatistic({\n            title: <Trans id=\"core.gcd.estimated-gcd\">Estimated GCD</Trans>,\n            icon: this.data.actions.ATTACK.icon,\n            value: this.parser.formatDuration(estimate),\n            info: (<Trans id=\"core.gcd.no-statistics\">\n\t\t\t\t\tUnfortunately, player statistics are not available from FF Logs. As such, the calculated GCD length is an <em>estimate</em>, and may well be incorrect. If it is reporting a GCD length <em>longer</em> than reality, you likely need to focus on keeping your GCD rolling.\n\t\t\t\t</Trans>),\n        }));\n    }\n    //saveGcd(event, isInstant) {\n    saveGcd(gcdInfo, timestamp) {\n        if (!gcdInfo.event) {\n            return;\n        }\n        const action = this.data.getAction(gcdInfo.event.ability.guid);\n        if (!action || !action.id) {\n            return;\n        }\n        let speedMod = this.speedmod.get(gcdInfo.event.timestamp);\n        let castTime = action.castTime;\n        // HACK NOTE TODO: Need to properly account for abilities that alter only the cast or recast of attacks.\n        // Thinking of moving this into a module like speedmod, that can be called with a timestamp to grab modified base castTime/cooldown values\n        const HACK_ASTRAL_UMBRAL_SPEED_SCALAR = 0.5;\n        if (speedMod <= HACK_ASTRAL_UMBRAL_SPEED_SCALAR) {\n            speedMod /= HACK_ASTRAL_UMBRAL_SPEED_SCALAR;\n            castTime *= HACK_ASTRAL_UMBRAL_SPEED_SCALAR;\n        }\n        let isCasterTaxed = false;\n        // GCD is only to two decimal places, so round it there. Storing in Ms.\n        // eslint-disable-next-line no-magic-numbers\n        let gcdLength = Math.round((timestamp - gcdInfo.event.timestamp) / 10) * 10;\n        if (!gcdInfo.isInstant && castTime >= action.cooldown) {\n            gcdLength -= CASTER_TAX;\n            isCasterTaxed = true;\n        }\n        const correctedCooldown = action.gcdRecast != null\n            ? action.gcdRecast\n            : action.cooldown;\n        const normaliseWith = gcdInfo.isInstant || castTime < correctedCooldown\n            ? correctedCooldown\n            : castTime;\n        const normalizedGcd = Math.round(gcdLength\n            * ((BASE_GCD / 1000) / normaliseWith)\n            * (1 / speedMod));\n        this.gcds.push({\n            timestamp: gcdInfo.event.timestamp,\n            length: gcdLength,\n            normalizedLength: normalizedGcd,\n            speedMod,\n            castTime,\n            cooldown: correctedCooldown,\n            casterTaxed: isCasterTaxed,\n            actionId: action.id,\n            isInstant: gcdInfo.isInstant,\n        });\n    }\n    getEstimate(bound = true) {\n        const gcdLength = this.gcds.length;\n        // If we don't have cache, need to recaculate it\n        if (this._estimatedBaseGcd === null || gcdLength !== this._estimateGcdCount) {\n            // Calculate the lengths of the GCD\n            const lengths = this.gcds.map(gcd => gcd.normalizedLength);\n            // Mode seems to get best results. Using mean in case there's multiple modes.\n            this._estimatedBaseGcd = lengths.length ? math.mean(math.mode(lengths)) : MAX_GCD;\n            this._estimateGcdCount = gcdLength;\n        }\n        // Bound the result if requested\n        if (bound) {\n            this._estimatedBaseGcd = Math.max(MIN_GCD, Math.min(MAX_GCD, this._estimatedBaseGcd));\n        }\n        return this._estimatedBaseGcd;\n    }\n    getUptime() {\n        return this.gcds.reduce((carry, gcd) => {\n            const duration = this._getGcdLength(gcd);\n            const downtime = this.downtime.getDowntime(gcd.timestamp, gcd.timestamp + duration);\n            return carry + duration - downtime;\n        }, 0);\n    }\n    _getGcdLength(gcd) {\n        let cooldown = (gcd.isInstant || gcd.castTime <= gcd.cooldown)\n            ? gcd.cooldown\n            : Math.max(gcd.castTime, gcd.cooldown);\n        cooldown *= 1000;\n        // Some actions are lower than or equal to min gcd, only adjust with ratios when they are not\n        if (cooldown > MIN_GCD) {\n            const cooldownRatio = this.getEstimate() / MAX_GCD;\n            cooldown = Math.max(MIN_GCD, cooldown * cooldownRatio * gcd.speedMod);\n        }\n        const duration = Math.round(cooldown + (gcd.casterTaxed ? CASTER_TAX : 0));\n        return duration;\n    }\n}\nGlobalCooldown.handle = 'gcd';\nGlobalCooldown.dependencies = [\n    // We need this to normalise before us\n    'precastAction',\n    'castTime',\n    'data',\n    'downtime',\n    'speedmod',\n    'statistics',\n    'timeline',\n];\nGlobalCooldown.title = t('core.gcd.title') `Global Cooldown`;\n","import Module from 'parser/core/Module';\nimport { ItemGroup, Item } from './Timeline';\nimport React from 'react';\nconst STATUS_APPLY_ON_PARTY_THRESHOLD_MILLISECONDS = 2 * 1000;\n// Track statuses applied by actions\nexport default class Statuses extends Module {\n    constructor(...args) {\n        super(...args);\n        this._statuses = {};\n        this._groups = {};\n        this._statusToActionMap = {};\n        this._actionToMergeNameMap = {};\n        const ids = [this.parser.player.id, ...this.parser.player.pets.map(p => p.id)];\n        const byFilter = { by: ids };\n        this.addHook('complete', this._onComplete);\n        this.addHook(['applybuff', 'applydebuff'], byFilter, this._onApply);\n        this.addHook(['refreshdebuff', 'refreshbuff'], byFilter, this._onRefresh);\n        this.addHook(['removebuff', 'removedebuff'], byFilter, this._onRemove);\n        this.cooldowns.constructor.cooldownOrder.forEach(cd => {\n            if (cd && typeof cd === 'object' && cd.merge) {\n                cd.actions.forEach(ac => {\n                    this._actionToMergeNameMap[ac] = cd.name;\n                });\n            }\n        });\n        // Map statuses to actions\n        Object.values(this.data.actions).forEach(action => {\n            if (!action.statusesApplied) {\n                return;\n            }\n            action.statusesApplied.forEach(statusKey => {\n                const status = this.data.statuses[statusKey];\n                this._statusToActionMap[status.id] = action;\n            });\n        });\n    }\n    _onApply(event) {\n        if (this._isStatusAppliedToPet(event)) {\n            return;\n        }\n        this._addStatus(event);\n    }\n    _onRefresh(event) {\n        if (this._isStatusAppliedToPet(event)) {\n            return;\n        }\n        this._endPrevStatus(event);\n        this._addStatus(event);\n    }\n    _onRemove(event) {\n        if (this._isStatusAppliedToPet(event)) {\n            return;\n        }\n        this._endPrevStatus(event);\n    }\n    _endPrevStatus(event) {\n        const status = this.data.getStatus(event.ability.guid);\n        if (!status) {\n            return;\n        }\n        const statusEntry = this._statuses[status.id];\n        if (statusEntry) {\n            const prev = statusEntry.usages[statusEntry.usages.length - 1];\n            if (!prev.end) {\n                prev.end = event.timestamp - this.parser.fight.start_time;\n            }\n        }\n    }\n    _addStatus(event) {\n        const status = this.data.getStatus(event.ability.guid);\n        if (!status) {\n            return;\n        }\n        let statusEntry = this._statuses[status.id];\n        if (!statusEntry) {\n            statusEntry = this._statuses[status.id] = {\n                status: status,\n                usages: [],\n            };\n        }\n        if (statusEntry.usages.some(it => {\n            const diff = Math.abs(event.timestamp - this.parser.fight.start_time - it.start);\n            return diff <= STATUS_APPLY_ON_PARTY_THRESHOLD_MILLISECONDS;\n        })) {\n            return;\n        }\n        statusEntry.usages.push({\n            start: event.timestamp - this.parser.fight.start_time,\n        });\n    }\n    _onComplete() {\n        Object.values(this._statuses).forEach(entry => {\n            const group = this._createGroupForStatus(entry.status);\n            if (!group) {\n                return;\n            }\n            entry.usages.forEach(st => {\n                group.addItem(new Item({\n                    type: 'background',\n                    start: st.start,\n                    end: st.end || st.start + entry.status.duration * 1000,\n                    content: <img src={entry.status.icon} alt={entry.status.name}/>,\n                }));\n            });\n        });\n    }\n    _createGroupForStatus(status) {\n        const stid = 'status-' + (this.constructor.statusesStackMapping[status.id] || status.id);\n        if (this._groups[stid]) {\n            return this._groups[stid];\n        }\n        // find action for status\n        const action = this._statusToActionMap[status.id];\n        if (!action) {\n            return undefined;\n        }\n        const group = new ItemGroup({\n            id: stid,\n            content: status.name,\n            showNested: false,\n        });\n        this._groups[stid] = group;\n        this.timeline.attachToGroup(action.onGcd ? this.gcd.gcdGroupId : (this._actionToMergeNameMap[action.id] || action.id), group);\n        return group;\n    }\n    _isStatusAppliedToPet(event) {\n        return (this.parser.report.friendlyPets.some(p => p.id === event.targetID));\n    }\n}\nStatuses.handle = 'statuses';\nStatuses.dependencies = [\n    'data',\n    'timeline',\n    'cooldowns',\n    'gcd',\n];\nStatuses.statusesStackMapping = {};\n","export var DISPLAY_ORDER;\n(function (DISPLAY_ORDER) {\n    DISPLAY_ORDER[DISPLAY_ORDER[\"DELIRIUM\"] = 1] = \"DELIRIUM\";\n    DISPLAY_ORDER[DISPLAY_ORDER[\"BLOOD_WEAPON\"] = 2] = \"BLOOD_WEAPON\";\n    DISPLAY_ORDER[DISPLAY_ORDER[\"RESOURCES\"] = 3] = \"RESOURCES\";\n})(DISPLAY_ORDER || (DISPLAY_ORDER = {}));\n","import React, { Fragment } from 'react';\nimport { Trans, Plural } from '@lingui/react';\nimport { t } from '@lingui/macro';\nimport { ActionLink } from 'components/ui/DbLink';\nimport ACTIONS from 'data/ACTIONS';\nimport STATUSES from 'data/STATUSES';\nimport Module, { DISPLAY_MODE } from 'parser/core/Module';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport Color from 'color';\nimport JOBS from 'data/JOBS';\nimport TimeLineChart from 'components/ui/TimeLineChart';\nimport { DISPLAY_ORDER } from './DISPLAY_ORDER';\n// -----\n// UI stuff\n// -----\nconst BLOODSPILLER_BLOOD_COST = 50;\nconst FLOOD_EDGE_MP_COST = 3000;\n// -----\n// Meters\n// ------\nconst MAX_MP = 10000;\nconst MP_AFTER_RAISE = 2000;\nconst MP_REGEN_PER_TICK = 200;\nconst TICK_RATE = 3000;\nconst MAX_BLOOD = 100;\nconst RESOURCE_SPENDERS = {\n    [ACTIONS.THE_BLACKEST_NIGHT.id]: { mp: -3000, blood: 0 },\n    [ACTIONS.FLOOD_OF_SHADOW.id]: { mp: -3000, blood: 0 },\n    [ACTIONS.EDGE_OF_SHADOW.id]: { mp: -3000, blood: 0 },\n    [ACTIONS.BLOODSPILLER.id]: { mp: 0, blood: -50 },\n    [ACTIONS.QUIETUS.id]: { mp: 0, blood: -50 },\n    [ACTIONS.LIVING_SHADOW.id]: { mp: 0, blood: -50 },\n};\nconst RESOURCE_GENERATORS = {\n    [ACTIONS.CARVE_AND_SPIT.id]: { mp: 600, blood: 0, requiresCombo: false },\n    [ACTIONS.SYPHON_STRIKE.id]: { mp: 600, blood: 0, requiresCombo: true },\n    [ACTIONS.SOULEATER.id]: { mp: 0, blood: 20, requiresCombo: true },\n    [ACTIONS.STALWART_SOUL.id]: { mp: 600, blood: 20, requiresCombo: true },\n};\n// Actions that generate blood and mana under blood weapon\nconst BLOOD_WEAPON_GENERATORS = {\n    [ACTIONS.HARD_SLASH.id]: { mp: 600, blood: 10 },\n    [ACTIONS.SYPHON_STRIKE.id]: { mp: 600, blood: 10 },\n    [ACTIONS.SOULEATER.id]: { mp: 600, blood: 10 },\n    [ACTIONS.BLOODSPILLER.id]: { mp: 600, blood: 10 },\n    [ACTIONS.QUIETUS.id]: { mp: 600, blood: 10 },\n    [ACTIONS.UNMEND.id]: { mp: 600, blood: 10 },\n    [ACTIONS.UNLEASH.id]: { mp: 600, blood: 10 },\n    [ACTIONS.STALWART_SOUL.id]: { mp: 600, blood: 10 },\n};\nconst DELIRIUM_GENERATORS = {\n    [ACTIONS.BLOODSPILLER.id]: { mp: 200, blood: 0 },\n    [ACTIONS.QUIETUS.id]: { mp: 500, blood: 0 },\n};\n// Tiered suggestion severities\nconst SEVERITY_THE_BLACKEST_NIGHT = {\n    1: SEVERITY.MEDIUM,\n    2: SEVERITY.MAJOR,\n};\nconst SEVERITY_WASTED_BLOOD_ACTIONS = {\n    1: SEVERITY.MINOR,\n    2: SEVERITY.MEDIUM,\n    4: SEVERITY.MAJOR,\n};\nconst SEVERITY_WASTED_MP_ACTIONS = {\n    1: SEVERITY.MINOR,\n    2: SEVERITY.MEDIUM,\n    5: SEVERITY.MAJOR,\n};\nexport default class Resources extends Module {\n    constructor(...args) {\n        super(...args);\n        // -----\n        // Resource utilities\n        // -----\n        this._currentBlood = 0;\n        this._wastedBlood = 0;\n        this._currentMP = 0;\n        this._wastedMP = 0;\n        // tracker stacks\n        this._history = {\n            mp: [],\n            blood: [],\n        };\n        // -----\n        // Internal tracking of generator events for MP overcap calculations\n        // -----\n        this._lastManaSpendEvent = null;\n        this._gainedSinceLastSpend = 0;\n        this._darkArtsProc = false;\n        // -----\n        // Evaluation units\n        // -----\n        this._droppedTBNs = 0;\n        this._resourceEvents = [\n            ...Object.keys(RESOURCE_SPENDERS),\n            ...Object.keys(RESOURCE_GENERATORS),\n            ...Object.keys(BLOOD_WEAPON_GENERATORS),\n            ...Object.keys(DELIRIUM_GENERATORS),\n        ].map(Number);\n        this.addHook(['aoedamage', 'combo'], { by: 'player', abilityId: this._resourceEvents }, this._onEvent);\n        // Hook cast for Living Shadow, as it doesn't directly deal damage so doesn't have an aoedamage event\n        this.addHook('cast', { by: 'player', abilityId: ACTIONS.LIVING_SHADOW.id }, this._onEvent);\n        // Hook cast for TBN application\n        this.addHook('cast', { by: 'player', abilityId: ACTIONS.THE_BLACKEST_NIGHT.id }, this._onCastBlackestNight);\n        this.addHook('removebuff', { by: 'player', abilityId: STATUSES.BLACKEST_NIGHT.id }, this._onRemoveBlackestNight);\n        this.addHook('death', { by: 'player' }, this._onDeath);\n        this.addHook('raise', { by: 'player' }, this._onRaise);\n        this.addHook('complete', this._onComplete);\n    }\n    // -----\n    // Resource Utility Methods\n    // -----\n    checkMPOvercap(event, beforeActionMP, actionMPChange) {\n        let lastSpendActionMP = 0;\n        let timeSinceLastSpendAction = 0;\n        let firstSpendAction = false;\n        if (this._lastManaSpendEvent !== null) {\n            lastSpendActionMP = this._lastManaSpendEvent.afterActionMP;\n            timeSinceLastSpendAction = event.timestamp - this._lastManaSpendEvent.timestamp;\n        }\n        else {\n            // First spender in the fight, assume we start with max MP\n            lastSpendActionMP = MAX_MP;\n            firstSpendAction = true;\n            timeSinceLastSpendAction = event.timestamp - this.parser.fight.start_time;\n        }\n        let manaTicks = Math.floor(timeSinceLastSpendAction / TICK_RATE);\n        if (actionMPChange <= 0) {\n            if (beforeActionMP === MAX_MP) {\n                // MP was at cap before using spender, check for waste\n                if (firstSpendAction) {\n                    // First spender in the fight, allow one tick before penalizing overflow from passive regeneration before first spender\n                    manaTicks = Math.floor(manaTicks - 1, 0);\n                }\n                // Add MP wasted due to ticks at cap (simulated).  MP waste due to generators will be calculated with the generator events\n                this._wastedMP += Math.max(lastSpendActionMP + this._gainedSinceLastSpend + manaTicks * MP_REGEN_PER_TICK - MAX_MP, 0);\n            }\n            this._gainedSinceLastSpend = 0;\n            event.afterActionMP = beforeActionMP + actionMPChange;\n            this._lastManaSpendEvent = event;\n        }\n        else {\n            if (beforeActionMP + actionMPChange > MAX_MP) {\n                // Generator, MP capped out with this action, check for waste\n                this._wastedMP += beforeActionMP + actionMPChange - MAX_MP;\n                actionMPChange = MAX_MP - beforeActionMP;\n            }\n            this._gainedSinceLastSpend += actionMPChange;\n        }\n        this._currentMP = beforeActionMP + actionMPChange;\n        this._pushToMPGraph();\n    }\n    checkBloodOvercap(actionBloodChange) {\n        this._currentBlood += actionBloodChange;\n        if (this._currentBlood > MAX_BLOOD) {\n            // Check to determine if blood was overcapped by gain, mark as wasted if so\n            this._wastedBlood += this._currentBlood - MAX_BLOOD;\n            this._currentBlood = MAX_BLOOD;\n        }\n        if (this._currentBlood < 0) {\n            // Sanity check - if blood drops below 0 from a spender, floor blood count at 0\n            this._currentBlood = 0;\n        }\n        this._pushToBloodGraph();\n    }\n    _pushToBloodGraph() {\n        const timestamp = this.parser.currentTimestamp - this.parser.fight.start_time;\n        this._history.blood.push({ t: timestamp, y: this._currentBlood });\n    }\n    _pushToMPGraph() {\n        const timestamp = this.parser.currentTimestamp - this.parser.fight.start_time;\n        this._history.mp.push({ t: timestamp, y: this._currentMP });\n    }\n    // -----\n    // simulator util\n    // ------\n    _onDeath() {\n        this._wastedMP += this._currentMP;\n        this._wastedBlood += this._currentBlood;\n        this._currentMP = 0;\n        this._currentBlood = 0;\n        this._pushToBloodGraph();\n        this._pushToMPGraph();\n    }\n    _onRaise() {\n        this._currentMP = MP_AFTER_RAISE;\n        this._pushToMPGraph();\n    }\n    _onEvent(event) {\n        const abilityId = event.ability.guid;\n        let actionBloodGain = 0;\n        let actionMPGain = 0;\n        if (RESOURCE_SPENDERS.hasOwnProperty(abilityId)) {\n            if (RESOURCE_SPENDERS[abilityId].blood < 0 && this.combatants.selected.hasStatus(STATUSES.DELIRIUM.id)) {\n                // Blood spender under delirium - no change\n                actionBloodGain += 0;\n            }\n            else {\n                actionBloodGain += RESOURCE_SPENDERS[abilityId].blood;\n            }\n            if (RESOURCE_SPENDERS[abilityId].mp < 0 && this._darkArtsProc) {\n                // MP Spending attack (Edge/Flood of Shadow) - free with Dark Arts proc\n                actionMPGain += 0;\n                this._darkArtsProc = false;\n            }\n            else {\n                actionMPGain += RESOURCE_SPENDERS[abilityId].mp;\n            }\n        }\n        if (event.successfulHit && (event.type !== 'combo' && this.combatants.selected.hasStatus(STATUSES.BLOOD_WEAPON.id) && BLOOD_WEAPON_GENERATORS.hasOwnProperty(abilityId))) {\n            // Actions that did not hit do not generate resources\n            // Don't double count blood weapon gains on comboed events\n            actionBloodGain += BLOOD_WEAPON_GENERATORS[abilityId].blood;\n            actionMPGain += BLOOD_WEAPON_GENERATORS[abilityId].mp;\n        }\n        if (event.successfulHit && RESOURCE_GENERATORS.hasOwnProperty(abilityId)) {\n            // Actions that did not hit do not generate resources\n            const actionInfo = RESOURCE_GENERATORS[abilityId];\n            if ((!actionInfo.requiresCombo && event.type !== 'combo') || event.type === 'combo') {\n                // Only gain resources if the action does not require a combo or is in a valid combo\n                actionBloodGain += RESOURCE_GENERATORS[abilityId].blood;\n                actionMPGain += RESOURCE_GENERATORS[abilityId].mp;\n            }\n        }\n        this.checkBloodOvercap(actionBloodGain);\n        const afterActionMP = (event.hasOwnProperty('sourceResources')) ? event.sourceResources.mp : 0;\n        this.checkMPOvercap(event, afterActionMP, actionMPGain);\n    }\n    _onCastBlackestNight(event) {\n        const abilityId = event.ability.guid;\n        const actionMPGain = RESOURCE_SPENDERS[abilityId].mp;\n        const afterActionMP = (event.hasOwnProperty('sourceResources')) ? event.sourceResources.mp : 0;\n        this.checkMPOvercap(event, afterActionMP, actionMPGain);\n        this._pushToMPGraph();\n    }\n    _onRemoveBlackestNight(event) {\n        const poppedTBN = event.absorb === 0;\n        if (poppedTBN) {\n            //popped\n            this._darkArtsProc = true;\n        }\n        else {\n            //expired\n            this._droppedTBNs += 1;\n        }\n    }\n    // -----\n    // ui\n    // -----\n    _onComplete() {\n        // UI\n        if (this._droppedTBNs > 0) {\n            this.suggestions.add(new TieredSuggestion({\n                icon: ACTIONS.THE_BLACKEST_NIGHT.icon,\n                content: <Trans id=\"drk.resourceanalyzer.blackestnight.content\">\n\t\t\t\t\tOne or more <ActionLink {...ACTIONS.THE_BLACKEST_NIGHT}/> applications did not fully use the shield, and thus did not generate a Dark Arts proc to allow free use of <ActionLink {...ACTIONS.EDGE_OF_SHADOW}/> or <ActionLink {...ACTIONS.FLOOD_OF_SHADOW}/>.\n\t\t\t\t</Trans>,\n                tiers: SEVERITY_THE_BLACKEST_NIGHT,\n                value: this._droppedTBNs,\n                why: <Trans id=\"drk.resourceanalyzer.blackestnight.why\">\n\t\t\t\t\tYou missed out on <Plural value={this._droppedTBNs} one=\"# Dark Arts use\" other=\"# Dark Arts uses\"/> due to Blackest Night applications that did not consume the shield.\n\t\t\t\t</Trans>,\n            }));\n        }\n        const wastedBloodActions = Math.floor(this._wastedBlood / BLOODSPILLER_BLOOD_COST);\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.BLOODSPILLER.icon,\n            content: <Trans id=\"drk.resourceanalyzer.wastedblood.content\">\n\t\t\t\tYour blood gauge allows you to use <ActionLink {...ACTIONS.BLOODSPILLER}/> or other spenders, which are among your strongest attacks.  Be sure to spend your blood before exceeding the cap of 100.\n\t\t\t</Trans>,\n            tiers: SEVERITY_WASTED_BLOOD_ACTIONS,\n            value: wastedBloodActions,\n            why: <Trans id=\"drk.resourceanalyzer.wastedblood.why\">\n\t\t\t\tYou lost a total of <Plural value={wastedBloodActions} one=\"# blood spending skill\" other=\"# blood spending skills\"/> from gaining blood over the cap or from death.\n\t\t\t</Trans>,\n        }));\n        const wastedMPActions = Math.floor(this._wastedMP / FLOOD_EDGE_MP_COST);\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.EDGE_OF_SHADOW.icon,\n            content: <Trans id=\"drk.resourceanalyzer.wastedmp.content\">\n\t\t\t\tYour MP allows you to use <ActionLink {...ACTIONS.EDGE_OF_SHADOW}/>, a strong attack that gives you a persistent damage up buff, as well as the strong mitigation of <ActionLink {...ACTIONS.THE_BLACKEST_NIGHT}/>.\n\t\t\t\tBe sure to consistently use your MP so you can benefit from natural regeneration and MP gain from your main combo skills.\n\t\t\t</Trans>,\n            tiers: SEVERITY_WASTED_MP_ACTIONS,\n            value: wastedMPActions,\n            why: <Trans id=\"drk.resourceanalyzer.wastedmp.why\">\n\t\t\t\tYou lost a total of <Plural value={wastedMPActions} one=\"# MP spending skill\" other=\"# MP spending skills\"/> from gaining MP over the cap or death.\n\t\t\t</Trans>,\n        }));\n    }\n    output() {\n        // Mana usage and blood usage modules\n        // make this into a pretty table\n        // also include spenders and generators\n        const _bloodColor = Color(JOBS.DARK_KNIGHT.colour);\n        const _mpColor = Color('#f266a2');\n        /* eslint-disable no-magic-numbers */\n        const bloodchartdata = {\n            datasets: [\n                {\n                    label: 'Blood',\n                    steppedLine: true,\n                    data: this._history.blood,\n                    backgroundColor: _bloodColor.fade(0.8),\n                    borderColor: _bloodColor.fade(0.5),\n                },\n            ],\n        };\n        const mpchartdata = {\n            datasets: [\n                {\n                    label: 'MP',\n                    steppedLine: true,\n                    data: this._history.mp,\n                    backgroundColor: _mpColor.fade(0.8),\n                    borderColor: _mpColor.fade(0.5),\n                },\n            ],\n        };\n        /* eslint-enable no-magic-numbers */\n        const mpChartOptions = {\n            scales: {\n                yAxes: [{\n                        ticks: {\n                            beginAtZero: true,\n                            min: 0,\n                            max: 10000,\n                        },\n                    }],\n            },\n        };\n        const bloodChartOptions = {\n            scales: {\n                yAxes: [{\n                        ticks: {\n                            beginAtZero: true,\n                            min: 0,\n                            max: 100,\n                        },\n                    }],\n            },\n        };\n        return <Fragment>\n\t\t\t<TimeLineChart data={bloodchartdata} options={bloodChartOptions}/>\n\t\t\t<TimeLineChart data={mpchartdata} options={mpChartOptions}/>\n\t\t</Fragment>;\n    }\n}\nResources.handle = 'resourceanalyzer';\nResources.title = t('drk.resourceanalyzer.title') `Resource Analyzer`;\nResources.displayMode = DISPLAY_MODE.FULL;\nResources.displayOrder = DISPLAY_ORDER.RESOURCES;\nResources.dependencies = [\n    'combatants',\n    'suggestions',\n];\n","import CoreCooldowns from 'parser/core/modules/Cooldowns';\nimport ACTIONS from 'data/ACTIONS';\nexport default class Cooldowns extends CoreCooldowns {\n}\nCooldowns.cooldownOrder = [\n    // Buffs\n    ACTIONS.BLOOD_WEAPON.id,\n    ACTIONS.DELIRIUM.id,\n    // oGCD Damage\n    ACTIONS.EDGE_OF_SHADOW.id,\n    ACTIONS.FLOOD_OF_SHADOW.id,\n    ACTIONS.LIVING_SHADOW.id,\n    ACTIONS.CARVE_AND_SPIT.id,\n    ACTIONS.PLUNGE.id,\n    ACTIONS.SALTED_EARTH.id,\n    ACTIONS.ABYSSAL_DRAIN.id,\n    // Personal Mitigation\n    ACTIONS.LIVING_DEAD.id,\n    ACTIONS.SHADOW_WALL.id,\n    ACTIONS.RAMPART.id,\n    ACTIONS.DARK_MIND.id,\n    // Party Mitigation\n    ACTIONS.THE_BLACKEST_NIGHT.id,\n    ACTIONS.REPRISAL.id,\n    ACTIONS.DARK_MISSIONARY.id,\n    // Tank Utility\n    ACTIONS.PROVOKE.id,\n    ACTIONS.SHIRK.id,\n    // Disrupt Utility\n    ACTIONS.INTERJECT.id,\n    ACTIONS.LOW_BLOW.id,\n];\n","import ACTIONS from 'data/ACTIONS';\nimport { CooldownDowntime } from 'parser/core/modules/CooldownDowntime';\nconst DEFAULT_FIRST_USE_OFFSET = 17500;\nexport default class OGCDDowntime extends CooldownDowntime {\n    constructor() {\n        super(...arguments);\n        this.defaultFirstUseOffset = DEFAULT_FIRST_USE_OFFSET;\n        this.trackedCds = [\n            {\n                cooldowns: [ACTIONS.BLOOD_WEAPON],\n                firstUseOffset: 2500,\n            },\n            {\n                cooldowns: [ACTIONS.DELIRIUM],\n                firstUseOffset: 15000,\n            },\n            { cooldowns: [ACTIONS.PLUNGE] },\n            { cooldowns: [ACTIONS.SALTED_EARTH] },\n            { cooldowns: [ACTIONS.CARVE_AND_SPIT] },\n            { cooldowns: [ACTIONS.ABYSSAL_DRAIN] },\n            {\n                cooldowns: [ACTIONS.LIVING_SHADOW],\n                firstUseOffset: 10000,\n            },\n        ];\n    }\n}\n","import { Trans } from '@lingui/react';\nimport { t } from '@lingui/macro';\nimport ACTIONS from 'data/ACTIONS';\nimport Module from 'parser/core/Module';\nimport { Rule, Requirement } from 'parser/core/modules/Checklist';\nimport React from 'react';\nimport { ActionLink } from 'components/ui/DbLink';\nconst DARKSIDE_MAX_DURATION = 60000;\nconst DARKSIDE_EXTENSION = {\n    [ACTIONS.FLOOD_OF_SHADOW.id]: 30000,\n    [ACTIONS.EDGE_OF_SHADOW.id]: 30000,\n};\nconst INITIAL_APPLICATION_FORGIVENESS = 2500;\nexport default class Darkside extends Module {\n    constructor(...args) {\n        super(...args);\n        this._currentDuration = 0;\n        this._downtime = 0;\n        this._lastEventTime = null;\n        this.addHook('aoedamage', { by: 'player', abilityId: Object.keys(DARKSIDE_EXTENSION).map(Number) }, this._updateDarkside);\n        this.addHook('death', { to: 'player' }, this._onDeath);\n        this.addHook('raise', { to: 'player' }, this._onRaise);\n        this.addHook('complete', this._onComplete);\n    }\n    _updateDarkside(event) {\n        if (this._lastEventTime === null) {\n            // First application - allow up to 1 GCD to apply before counting downtime\n            const elapsedTime = event.timestamp - this.parser.fight.start_time;\n            this._downtime = Math.max(elapsedTime - INITIAL_APPLICATION_FORGIVENESS, 0);\n        }\n        else {\n            const elapsedTime = event.timestamp - this._lastEventTime;\n            this._currentDuration -= elapsedTime;\n            if (this._currentDuration < 0) {\n                this._downtime += Math.abs(this._currentDuration);\n                this._currentDuration = 0;\n            }\n        }\n        if (event.hasOwnProperty('ability')) {\n            const abilityId = event.ability.guid;\n            this._currentDuration = Math.min(this._currentDuration + DARKSIDE_EXTENSION[abilityId], DARKSIDE_MAX_DURATION);\n            this._lastEventTime = event.timestamp;\n        }\n    }\n    _onDeath(event) {\n        this._updateDarkside(event);\n        this._currentDuration = 0;\n    }\n    _onRaise(event) {\n        // So floor time doesn't count against Darkside uptime\n        this._lastEventTime = event.timestamp;\n    }\n    _onComplete(event) {\n        this._updateDarkside(event);\n        const duration = this.parser.fightDuration - this.death.deadTime;\n        const uptime = ((duration - this._downtime) / duration) * 100;\n        this.checklist.add(new Rule({\n            name: 'Keep Darkside up',\n            description: <Trans id=\"drk.darkside.uptime.why\">\n\t\t\t\tDarkside is gained by using <ActionLink {...ACTIONS.EDGE_OF_SHADOW}/> or <ActionLink {...ACTIONS.FLOOD_OF_SHADOW}/> and provides you with a 10% damage increase.  As such, it is a significant part of a DRK's personal DPS.  Do your best not to let it drop, and recover it as quickly as possible if it does.\n\t\t\t</Trans>,\n            requirements: [\n                new Requirement({\n                    name: <Trans id=\"drk.darkside.uptime\">Darkside Uptime</Trans>,\n                    percent: () => uptime,\n                }),\n            ],\n            target: 99,\n        }));\n    }\n}\nDarkside.handle = 'Darkside';\nDarkside.dependencies = [\n    'checklist',\n    'death',\n];\nDarkside.title = t('drk.darkside.title') `Darkside`;\n","import { t } from '@lingui/macro';\nimport { Trans } from '@lingui/react';\nimport { ActionLink } from 'components/ui/DbLink';\nimport ACTIONS from 'data/ACTIONS';\nimport STATUSES from 'data/STATUSES';\nimport { BuffWindowModule } from 'parser/core/modules/BuffWindow';\nimport { SEVERITY } from 'parser/core/modules/Suggestions';\nimport React from 'react';\nimport { DISPLAY_ORDER } from './DISPLAY_ORDER';\nexport default class BloodWeapon extends BuffWindowModule {\n    constructor() {\n        super(...arguments);\n        this.buffAction = ACTIONS.BLOOD_WEAPON;\n        this.buffStatus = STATUSES.BLOOD_WEAPON;\n        this.expectedGCDs = {\n            expectedPerWindow: 5,\n            suggestionContent: <Trans id=\"drk.bloodweapon.suggestions.missedgcd.content\">\n\t\t\tTry to land 5 GCDs during every <ActionLink {...ACTIONS.BLOOD_WEAPON}/> window.  If you cannot do this with full uptime and no clipping, consider adjusting your gearset for more Skill Speed.\n\t\t</Trans>,\n            severityTiers: {\n                1: SEVERITY.MINOR,\n                3: SEVERITY.MEDIUM,\n                5: SEVERITY.MAJOR,\n            },\n        };\n    }\n}\nBloodWeapon.handle = 'bloodweapon';\nBloodWeapon.title = t('drk.bloodweapon.title') `Blood Weapon Usage`;\nBloodWeapon.displayOrder = DISPLAY_ORDER.BLOOD_WEAPON;\n","import { t } from '@lingui/macro';\nimport { Trans } from '@lingui/react';\nimport { ActionLink } from 'components/ui/DbLink';\nimport ACTIONS from 'data/ACTIONS';\nimport STATUSES from 'data/STATUSES';\nimport { BuffWindowModule } from 'parser/core/modules/BuffWindow';\nimport { SEVERITY } from 'parser/core/modules/Suggestions';\nimport React from 'react';\nimport { DISPLAY_ORDER } from './DISPLAY_ORDER';\nexport default class Delirium extends BuffWindowModule {\n    constructor() {\n        super(...arguments);\n        this.buffAction = ACTIONS.DELIRIUM;\n        this.buffStatus = STATUSES.DELIRIUM;\n        this.expectedGCDs = {\n            expectedPerWindow: 5,\n            suggestionContent: <Trans id=\"drk.delirium.suggestions.missedgcd.content\">\n\t\t\tTry to land 5 GCDs during every <ActionLink {...ACTIONS.DELIRIUM}/> window.  If you cannot do this with full uptime and no clipping, consider adjusting your gearset for more Skill Speed.\n\t\t</Trans>,\n            severityTiers: {\n                1: SEVERITY.MEDIUM,\n                3: SEVERITY.MAJOR,\n            },\n        };\n        this.requiredGCDs = {\n            icon: ACTIONS.BLOODSPILLER.icon,\n            actions: [\n                ACTIONS.BLOODSPILLER,\n                ACTIONS.QUIETUS,\n            ],\n            suggestionContent: <Trans id=\"drk.delirium.suggestions.badgcd.content\">\n\t\t\tGCDs used during <ActionLink {...ACTIONS.DELIRIUM}/> should be limited to <ActionLink {...ACTIONS.BLOODSPILLER}/> for optimal damage (or <ActionLink {...ACTIONS.QUIETUS}/> if three or more targets are present).\n\t\t</Trans>,\n            severityTiers: {\n                1: SEVERITY.MEDIUM,\n                2: SEVERITY.MAJOR,\n            },\n        };\n    }\n}\nDelirium.handle = 'delirium';\nDelirium.title = t('drk.delirium.title') `Delirium Usage`;\nDelirium.displayOrder = DISPLAY_ORDER.DELIRIUM;\n","import ACTIONS from 'data/ACTIONS';\nimport Module from 'parser/core/Module';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport { Plural, Trans } from '@lingui/react';\nimport { ActionLink } from 'components/ui/DbLink';\nimport React from 'react';\nconst REQUIRED_MULTI_HIT_TARGETS = {\n    [ACTIONS.FLOOD_OF_SHADOW.id]: 2,\n    [ACTIONS.UNLEASH.id]: 2,\n    [ACTIONS.STALWART_SOUL.id]: 2,\n    [ACTIONS.QUIETUS.id]: 3,\n};\nconst SEVERITY_LOW_TARGET_ATTACKS = {\n    1: SEVERITY.LOW,\n    2: SEVERITY.MEDIUM,\n    4: SEVERITY.MAJOR,\n};\nexport default class MultiHit extends Module {\n    constructor(...args) {\n        super(...args);\n        this._incorrectMultihitSkills = {\n            [ACTIONS.FLOOD_OF_SHADOW.id]: 0,\n            [ACTIONS.QUIETUS.id]: 0,\n            [ACTIONS.UNLEASH.id]: 0,\n            [ACTIONS.STALWART_SOUL.id]: 0,\n        };\n        this.addHook('aoedamage', { by: 'player', abilityId: Object.keys(this._incorrectMultihitSkills).map(Number) }, this._checkMultiHitSkill);\n        this.addHook('complete', this._onComplete);\n    }\n    _checkMultiHitSkill(event) {\n        if (REQUIRED_MULTI_HIT_TARGETS.hasOwnProperty(event.ability.guid) && event.hits.length < REQUIRED_MULTI_HIT_TARGETS[event.ability.guid]) {\n            this._incorrectMultihitSkills[event.ability.guid]++;\n        }\n    }\n    _onComplete() {\n        let lowTargetAttacks = 0;\n        for (const prop in this._incorrectMultihitSkills) {\n            lowTargetAttacks += this._incorrectMultihitSkills[prop];\n        }\n        if (lowTargetAttacks > 0) {\n            this.suggestions.add(new TieredSuggestion({\n                icon: ACTIONS.QUIETUS.icon,\n                content: <Trans id=\"drk.multihit.suggestions.content\">\n\t\t\t\t\tDo not use multi-hit GCDs or <ActionLink {...ACTIONS.FLOOD_OF_SHADOW}/> unless they can hit at least 2 targets, or <ActionLink {...ACTIONS.QUIETUS}/> unless it can hit at least 3 targets.\n\t\t\t\t\tMulti-hit GCDs are lower total damage than single target GCDs against only 1 target, and <ActionLink {...ACTIONS.FLOOD_OF_SHADOW}/> or <ActionLink {...ACTIONS.QUIETUS}/> consume resources that can be used on more powerful single target attacks.\n\t\t\t\t</Trans>,\n                tiers: SEVERITY_LOW_TARGET_ATTACKS,\n                value: lowTargetAttacks,\n                why: <Trans id=\"drk.multihit.suggestions.why\">\n\t\t\t\t\t{lowTargetAttacks} <Plural value={lowTargetAttacks} one=\"multi-target attack was\" other=\"multi-target attacks were\"/> used against too few targets.\n\t\t\t\t</Trans>,\n            }));\n        }\n    }\n}\nMultiHit.handle = 'multihit';\nMultiHit.dependencies = [\n    'suggestions',\n];\n","import CoreStatuses from 'parser/core/modules/Statuses';\nimport STATUSES from 'data/STATUSES';\nexport default class Statuses extends CoreStatuses {\n}\nStatuses.statusesStackMapping = {\n    [STATUSES.WALKING_DEAD.id]: STATUSES.LIVING_DEAD.id,\n};\n","import ResourceSimulator from './ResourceSimulator';\nimport Cooldowns from './Cooldowns';\nimport OGCDDowntime from './OGCDDowntime';\nimport Darkside from './Darkside';\nimport BloodWeapon from './BloodWeapon';\nimport Delirium from './Delirium';\nimport MultiHitSkills from './MultiHitSkills';\nimport Statuses from './Statuses';\nexport default [\n    Darkside,\n    BloodWeapon,\n    Delirium,\n    ResourceSimulator,\n    Cooldowns,\n    OGCDDowntime,\n    MultiHitSkills,\n    Statuses,\n];\n"],"sourceRoot":""}
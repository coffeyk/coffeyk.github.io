{"version":3,"sources":["webpack:///./src/parser/core/modules/Weaving.js","webpack:///./src/parser/jobs/brd/modules/Barrage.module.css?3e86","webpack:///./src/parser/jobs/brd/modules/PitchPerfect.module.css?29bc","webpack:///./src/parser/jobs/brd/modules/AdditionalStats.js","webpack:///./src/parser/jobs/brd/modules/Barrage.js","webpack:///./src/parser/jobs/brd/modules/DoTs.js","webpack:///./src/parser/jobs/brd/modules/OGCDDowntime.ts","webpack:///./src/parser/jobs/brd/modules/PitchPerfect.js","webpack:///./src/parser/jobs/brd/modules/Sidewinder.js","webpack:///./src/parser/jobs/brd/modules/Snapshots.js","webpack:///./src/parser/jobs/brd/modules/SongUptime.js","webpack:///./src/parser/jobs/brd/modules/Util.js","webpack:///./src/parser/jobs/brd/modules/Weaving.js","webpack:///./src/parser/jobs/brd/modules/index.js"],"names":["DEFAULT_MAX_WEAVES","MAX_WEAVE_TIERS","0","1","2.5","WEAVING_SEVERITY","SEVERITY","MEDIUM","5","MAJOR","Weaving","Module","constructor","super","this","_weaves","_ongoingCastEvent","_leadingGcdEvent","_trailingGcdEvent","_badWeaves","addHook","by","_onBeginCast","_onCast","_onComplete","event","action","data","getAction","ability","guid","autoAttack","isOgcd","push","id","timestamp","_saveIfBad","badWeaves","suggestions","add","TieredSuggestion","icon","content","href","onClick","parser","scrollTo","handle","message","title","why","length","tiers","value","leadingGcdEvent","fight","start_time","gcdTimeDiff","invuln","getUntargetableUptime","weave","trailingGcdEvent","weaves","isBadWeave","onGcd","maxWeaves","weaveCount","filter","isUntargetable","castTime","forEvent","closest","matchClosestLower","undefined","speedmod","get","gcdLength","gcd","getEstimate","output","panels","map","item","key","formatTimestamp","formatDuration","events","exclusive","styled","fluid","dependencies","module","exports","CRIT_MODIFIERS","STATUSES","BATTLE_LITANY","strength","CHAIN_STRATAGEM","DEVILMENT","SNAPSHOTTERS","ACTIONS","IRON_JAWS","CAUSTIC_BITE","STORMBITE","VENOMOUS_BITE","WINDBITE","DOTS","DHIT_MOD","TRAIT_STRENGTH","DEVIATION_PRECISION","BASE_SUBSTAT_80","LEVEL_MOD_80","BASE_CRIT_PROBABILITY","AdditionalStats","arguments","_enemies","_player","statuses","_snapshotters","_damageInstances","_critFromDots","normalise","type","match","actor","targetID","combatants","selected","targetIsFriendly","_getEnemy","includes","startsWith","snapshotter","Object","keys","_getSnapshotter","reduce","a","b","dot","_getDot","_snapshotStatuses","isActive","critModifier","find","cm","sourceID","tick","enemy","accumulatedCritBuffs","_parseDotCritBuffs","expectedCritRate","_getStatus","THE_SPEAR","critRate","fixedMultiplier","debugMultiplier","THE_WANDERERS_MINUET","MAGES_BALLAD","ARMYS_PAEON","Math","trunc","critTier","_parseCritBuffs","rawDamage","amount","toString","newSnapshotter","player","snapshot","criticalHitProbability","_getCriticalHitProbability","criticalHitRate","_getCriticalHitRate","critMod","_getCritMod","potencyDamageRatio","_getPotencyDamageRatio","targetId","dots","statusId","skillId","entity","status","target","sources","forEach","source","modifier","enemyStatus","playerStatus","dotStatus","_getEmpiricalRuleSubsetMean","rates","sampleSize","critAmount","x","criticalHit","rate","max","Number","parseFloat","acc","chr","floor","values","instance","SHOT","skill","getDataBy","directHit","potency","isNaN","round","dataset","n","mean","math","standardDeviation","std","v","SUCCESS","TARGET","WARNING","WARN","ERROR","FAIL","text","TRIPLE_HIT_BUFFER","BAD_BARRAGE_WEIGHT","UNALIGNED_BARRAGE_WEIGHT","PROC_WASTED_WEIGHT","DROPPED_BARRAGE_WEIGHT","BAD_ST_WEAPONSKILLS","HEAVY_SHOT","BURST_SHOT","WEAPONSKILLS","STRAIGHT_SHOT","REFULGENT_ARROW","concat","Barrage","_lastWeaponskill","_barrageEvents","abilityId","BARRAGE","_onBarrageCast","_onStWeaponskillDamage","STRAIGHTER_SHOT","_onSSApply","_onSSRemove","_addBarrage","_getLastWeaponskill","util","timeSince","addDamageEvent","hits","_checkOutBarrage","_setLastWeaponskill","_hasSS","badBarrages","isBad","unalignedBarrages","aligned","wastedProcs","wastedProc","droppedBarrages","isDropped","_getBarrage","checklist","WeightedTieredRule","name","description","NormalisedMessage","90","100","requirements","WeightedRequirement","percent","weight","RAGING_STRIKES","Rule","Requirement","barrageEvents","barrage","panelProperties","tuples","contents","issue","severity","reason","totalDamage","damageEvents","y","totalDPS","formatDecimal","fightDuration","potentialDamage","potentialRefulgentDamage","skillBarraged","cooldown","potentialDPS","potentialRefulgentDPS","dpsLoss","Table","collapsing","unstackable","celled","Header","Row","HeaderCell","width","negative","Body","Cell","formatDamageNumber","buildPanel","Accordion","timeUntilFinish","hasBuff","castEvent","index","slice","sort","_severitySelector","t","defaultTitle","issueElements","Message","indexOf","error","warning","success","Icon","reasonElements","className","styles","List","bulleted","relaxed","Item","contentElements","c","damageElements","info","Content","formatDamageLog","severities","min","s","TieredRule","options","totalWeight","req","r","DoTs","_onDotApply","_dotComponent","apply","_onDotRemove","remove","getDebuffUptime","OGCDDowntime","CooldownDowntime","trackedCds","cooldowns","SIDEWINDER","checklistTarget","DOT_TICK_FREQUENCY","SONG_DURATION","ANIMATION_LOCK","CONVERSION_FACTOR","PP","2","3","PP_POTENCY","PITCH_PERFECT","PP_MAX_POTENCY","NONE","PP_CAST_WIHTOUT_MAX_STACKS","PP_NOT_CAST_AT_END","PitchPerfect","_lastWMCast","_lostPotencyFromStacks","_lostPotencyFromMissedCast","_ppEvents","_onPPDamage","_onPPEvent","_onDotTick","_onWMCast","additionalStats","approximatedPotency","matchClosest","stacks","fabricateEvent","wm","brokenLog","trigger","ppEvent","damageEvent","timeLeftOnSong","critOnDot","lastTickOnEnemy","lastTick","lostPotency","_cleanUpPPs","badPPs","pp","missedPPs","900","400","150","MINOR","8","_formatPotency","_buildPanel","attached","Label","color","size","pointing","titleIconName","titleIconClass","titleElement","timeLeftElement","potencyLostElement","_createTimelineButton","_isAMissedPP","lastPPInWM","missedPPGracePeriod","downtime","getDowntime","lastPP","badCastInCurrentWM","stacksUsedInCurrentWM","stacksUsedInWM","castsInWM","castsInCurrentWM","splice","isDowntime","wmIndex","casts","totalPotencyInWM","cast","totalStacks","potencyFromMax","potencyFromLast","maxPotencyInWM","toLocaleString","Button","circular","compact","timeline","show","MAX_SHADOWBITE_POTENCY","SHADOWBITE","MAX_SIDEWINDER_POTENCY","Sidewinder","_amountOfBadSidewinders","_amountOfBadShadowbites","_amountOfSingleTargetShadowbites","_notBothDotsPotencyLoss","_singleTargetShadowbitesPotencyLoss","_badCasts","_shadowbiteDamageTimestamps","Map","_onSidewinderCast","fflogsEvents","damageEventName","_onShadowbiteDamage","_getDotsOnEnemy","dotsApplied","dotId","hasStatus","_getRawDamage","shadowbiteTimestampArray","shadowbiteDamageEvent","isSingleTargetShadowbite","hasBothDots","missedDamage","missedPotency","targetsHit","set","enemies","getEntity","thisPotency","_addInSingleTargetShadowbites","badSidewinders","badShadowbites","showIcon","1110","480","160","200","40","floated","totalPotencyLost","items","verticalAlign","_createIssueTag","horizontal","_formatDamageNumber","divided","damage","truncDamage","singleTargetAmount","needsSort","eventArray","lostDamage","cast1","cast2","Snapshots","_snapshotEvents","snapshotEvents","rows","snapshotEvent","snapshotCell","showName","iconSize","createTimelineButton","SETUP_TIME","TIER","SongUptime","_songCastEvents","_deathEvents","_onSongCast","to","_onDeath","songlessTime","_getSonglessTime","songlessTolerance","_getTolerance","totalSonglessTime","i","songless","start","end","end_time","deathEvent","d","theoreticalSonglessTime","tolerance","Util","getStatusUptime","getInvulnerableUptime","getBuffUptime","getDowntimeLength","window","getDowntimeWindows","number","precision","isInteger","pow","multistrike","hitType","milliToSeconds","time","currentTimestamp","damageNumber","maximumFractionDigits","SPECIAL_WEAVE","ALLOWED_WEAVES","BLOODLETTER","EMPYREAL_ARROW","CoreWeaving","weaveSequence","w","some"],"mappings":"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","file":"assets/jobs-brd.fdbc216a.js","sourcesContent":["import { t } from '@lingui/macro';\nimport { Trans, Plural } from '@lingui/react';\nimport React from 'react';\nimport { Accordion } from 'semantic-ui-react';\nimport Rotation from 'components/ui/Rotation';\nimport NormalisedMessage from 'components/ui/NormalisedMessage';\nimport Module from 'parser/core/Module';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport { matchClosestLower } from 'utilities';\n// BRD weaves, ninjustsu, etc. should be handled by subclasses w/ isBadWeave overrides\nconst DEFAULT_MAX_WEAVES = 2; // Default castTime is 0\nconst MAX_WEAVE_TIERS = {\n    0: 2,\n    1: 1,\n    2.5: 0,\n};\nconst WEAVING_SEVERITY = {\n    1: SEVERITY.MEDIUM,\n    5: SEVERITY.MAJOR,\n};\nexport default class Weaving extends Module {\n    constructor(...args) {\n        super(...args);\n        this._weaves = [];\n        this._ongoingCastEvent = null;\n        this._leadingGcdEvent = null;\n        this._trailingGcdEvent = null;\n        this._badWeaves = [];\n        this.addHook('begincast', { by: 'player' }, this._onBeginCast);\n        this.addHook('cast', { by: 'player' }, this._onCast);\n        this.addHook('complete', this._onComplete);\n    }\n    _onBeginCast(event) {\n        this._ongoingCastEvent = event;\n    }\n    _onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        // If the action is an auto, just ignore it\n        if (!action || action.autoAttack) {\n            return;\n        }\n        // If it's not a GCD, just bump the weave count\n        if (this.isOgcd(action)) {\n            this._weaves.push(event);\n            return;\n        }\n        if (this._ongoingCastEvent && this._ongoingCastEvent.ability.guid === action.id) {\n            // This event is the end of a GCD cast\n            this._trailingGcdEvent = {\n                ...event,\n                // Override the timestamp of the GCD with when its cast began\n                timestamp: this._ongoingCastEvent.timestamp,\n            };\n        }\n        else {\n            // This event was an instant GCD (or log missed the cast starting)\n            this._trailingGcdEvent = event;\n        }\n        // Always reset the ongoing cast\n        this._ongoingCastEvent = null;\n        // Throw the current state onto the history\n        this._saveIfBad();\n        // Reset\n        this._leadingGcdEvent = this._trailingGcdEvent;\n        this._weaves = [];\n    }\n    _onComplete() {\n        // If there's been at least one gcd, run a cleanup on any remnant data\n        if (this._leadingGcdEvent) {\n            this._saveIfBad();\n        }\n        // Few triples is medium, any more is major\n        const badWeaves = this._badWeaves;\n        this.suggestions.add(new TieredSuggestion({\n            // WVR Focused synth lmao\n            icon: 'https://xivapi.com/i/001000/001785.png',\n            content: <Trans id=\"core.weaving.content\">\n\t\t\t\tAvoid weaving more actions than you have time for in a single GCD window. Doing so will delay your next GCD, reducing possible uptime. Check the <a href=\"javascript:void(0);\" onClick={() => this.parser.scrollTo(this.constructor.handle)}><NormalisedMessage message={this.constructor.title}/></a> module below for more detailed analysis.\n\t\t\t</Trans>,\n            why: <Plural id=\"core.weaving.why\" value={badWeaves.length} _1=\"# instance of incorrect weaving\" other=\"# instances of incorrect weaving\"/>,\n            tiers: WEAVING_SEVERITY,\n            value: badWeaves.length,\n        }));\n    }\n    _saveIfBad() {\n        const leadingGcdEvent = this._leadingGcdEvent || { timestamp: this.parser.fight.start_time };\n        const gcdTimeDiff = this._trailingGcdEvent.timestamp -\n            leadingGcdEvent.timestamp -\n            this.invuln.getUntargetableUptime('all', leadingGcdEvent.timestamp, this._trailingGcdEvent.timestamp);\n        const weave = {\n            leadingGcdEvent,\n            trailingGcdEvent: this._trailingGcdEvent,\n            gcdTimeDiff,\n            weaves: this._weaves,\n        };\n        if (weave.weaves.length === 0) {\n            return;\n        }\n        if (this.isBadWeave(weave)) {\n            this._badWeaves.push(weave);\n        }\n    }\n    isOgcd(action) {\n        return !action.onGcd\n            && !action.autoAttack;\n    }\n    // Basic weave check. For job-specific weave concerns, subclass Weaving and override this method. Make sure it's included under the same module key to override the base implementation.\n    isBadWeave(weave, maxWeaves) {\n        // Calc. the no. of weaves - we're ignoring any made while the boss is untargetable\n        const weaveCount = weave.weaves.filter(event => !this.invuln.isUntargetable('all', event.timestamp)).length;\n        // Just using maxWeaves to allow potential subclasses to utilise standard functionality with custom max\n        if (!maxWeaves) {\n            // If there's no leading ability, it's the first GCD. Allow the 'default' cast time's amount\n            if (!weave.leadingGcdEvent.ability) {\n                maxWeaves = DEFAULT_MAX_WEAVES;\n            }\n            else {\n                const castTime = this.castTime.forEvent(weave.leadingGcdEvent);\n                const closest = matchClosestLower(MAX_WEAVE_TIERS, castTime);\n                maxWeaves = closest !== undefined ? closest : DEFAULT_MAX_WEAVES;\n            }\n        }\n        // It's possible that they did a bunch of weaves during downtime or similar - that's fine.\n        const speedmod = this.speedmod.get(this.parser.timestamp);\n        const gcdLength = this.gcd.getEstimate() * speedmod;\n        return weave.gcdTimeDiff > gcdLength && weaveCount > maxWeaves;\n    }\n    output() {\n        const badWeaves = this._badWeaves;\n        if (badWeaves.length === 0) {\n            return false;\n        }\n        const panels = badWeaves.map(item => ({\n            key: item.leadingGcdEvent.timestamp,\n            title: {\n                content: <>\n\t\t\t\t\t<strong>{this.parser.formatTimestamp(item.leadingGcdEvent.timestamp)}</strong>\n\t\t\t\t\t&nbsp;-&nbsp;\n\t\t\t\t\t<Plural id=\"core.weaving.panel-count\" value={item.weaves.length} _1=\"# weave\" other=\"# weaves\"/>\n\t\t\t\t\t&nbsp;(\n\t\t\t\t\t{this.parser.formatDuration(item.gcdTimeDiff)}\n\t\t\t\t\t&nbsp;\n\t\t\t\t\t<Trans id=\"core.weaving.between-gcds\">between GCDs</Trans>\n\t\t\t\t\t)\n\t\t\t\t</>,\n            },\n            content: {\n                content: <Rotation events={[\n                    ...(item.leadingGcdEvent.ability ? [item.leadingGcdEvent] : []),\n                    ...item.weaves,\n                ]}/>,\n            },\n        }));\n        return <Accordion exclusive={false} panels={panels} styled fluid/>;\n    }\n}\nWeaving.handle = 'weaving';\nWeaving.dependencies = [\n    'castTime',\n    'data',\n    'gcd',\n    'invuln',\n    'speedmod',\n    'suggestions',\n];\nWeaving.title = t('core.weaving.title') `Weaving Issues`;\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"title\":\"Barrage-module_title__2q8k6\",\"description\":\"Barrage-module_description__23PK8\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"title\":\"PitchPerfect-module_title__3Qxb2\",\"description\":\"PitchPerfect-module_description__2DTk6\"};","/**\n * @author Yumiya\n */\nimport Module from 'parser/core/Module';\nimport { getDataBy } from 'data';\nimport ACTIONS from 'data/ACTIONS';\nimport STATUSES from 'data/STATUSES';\nimport math from 'mathjsCustom';\n// Relevant crit buffs\nconst CRIT_MODIFIERS = [\n    {\n        id: STATUSES.BATTLE_LITANY.id,\n        strength: 0.1,\n    },\n    {\n        id: STATUSES.CHAIN_STRATAGEM.id,\n        strength: 0.1,\n    },\n    {\n        id: STATUSES.DEVILMENT.id,\n        strength: 0.2,\n    },\n];\n// Skills that snapshot dots and their respective dot statuses (let's do it BRD only for now)\n// TODO: Populate with other jobs DoTs and Snapshotters\nconst SNAPSHOTTERS = {\n    [ACTIONS.IRON_JAWS.id]: [\n        STATUSES.CAUSTIC_BITE.id,\n        STATUSES.STORMBITE.id,\n    ],\n    [ACTIONS.CAUSTIC_BITE.id]: [\n        STATUSES.CAUSTIC_BITE.id,\n    ],\n    [ACTIONS.STORMBITE.id]: [\n        STATUSES.STORMBITE.id,\n    ],\n    [ACTIONS.VENOMOUS_BITE.id]: [\n        STATUSES.VENOMOUS_BITE.id,\n    ],\n    [ACTIONS.WINDBITE.id]: [\n        STATUSES.WINDBITE.id,\n    ],\n};\n// Relevant dot statuses (let's do it BRD only for now)\nconst DOTS = [\n    STATUSES.CAUSTIC_BITE.id,\n    STATUSES.STORMBITE.id,\n    STATUSES.VENOMOUS_BITE.id,\n    STATUSES.WINDBITE.id,\n];\nconst DHIT_MOD = 1.25;\nconst TRAIT_STRENGTH = 0.20;\nconst DEVIATION_PRECISION = 3;\nconst BASE_SUBSTAT_80 = 380;\nconst LEVEL_MOD_80 = 3300;\nconst BASE_CRIT_PROBABILITY = 50; //5%\nexport default class AdditionalStats extends Module {\n    constructor() {\n        super(...arguments);\n        // Represents a map of IDs and statuses for each enemy in this parse\n        this._enemies = {};\n        // Represents the player statuses\n        this._player = {\n            statuses: {},\n        };\n        // Represents a map of IDs and statuses for each snapshotter skill in this parse\n        this._snapshotters = {};\n        // Let's store these in the class like normal people\n        this._damageInstances = {};\n        this._critFromDots = [];\n    }\n    normalise(events) {\n        for (const event of events) {\n            // Registers buffs/debuffs statuses on the respective entity (either player or enemies)\n            if (event.type.match(/^(apply|remove|refresh)(de)?buff(stack)?$/)) {\n                let actor;\n                // Determines if it's a status on the selected player or on an enemy\n                if (event.targetID === this.combatants.selected.id && event.ability) {\n                    actor = this._player;\n                }\n                else if (!event.targetIsFriendly) {\n                    actor = this._getEnemy(event.targetID);\n                    // Separately checks for dot application on enemies, too\n                    if (DOTS.includes(event.ability.guid)\n                        && (event.type.startsWith('apply') || event.type.startsWith('refresh'))) {\n                        // We fetch only the most recent snapshotter that affects the current dot\n                        const snapshotter = Object.keys(SNAPSHOTTERS)\n                            .filter(action => SNAPSHOTTERS[action].includes(event.ability.guid))\n                            .map(action => this._getSnapshotter(action))\n                            .reduce((a, b) => { return a.timestamp > b.timestamp ? a : b; });\n                        // We get the dot component from the enemy\n                        const dot = this._getDot(actor, event.ability.guid);\n                        this._snapshotStatuses(dot, snapshotter);\n                    }\n                }\n                // If it's a status on either the selected player or on an enemy\n                if (actor) {\n                    actor.statuses[event.ability.guid] = {\n                        isActive: event.type.startsWith('apply') || event.type.startsWith('refresh'),\n                    };\n                    // If the current status is a crit modifier, we add the strength onto it to use later\n                    const critModifier = CRIT_MODIFIERS.find(cm => cm.id === event.ability.guid);\n                    if (critModifier) {\n                        actor.statuses[event.ability.guid].strength = critModifier.strength;\n                    }\n                }\n                // For every damage event that:\n                // - comes from the player\n                // - has an ability attached to it\n            }\n            else if (event.type === 'damage'\n                && event.sourceID === this.combatants.selected.id\n                && event.ability) {\n                // If it's not a dot tick\n                if (!event.tick) {\n                    // Fixing the multiplier\n                    // TODO: Skills should probably have a property with their type/element and category, otherwise this will only work on BRD\n                    let fixedMultiplier = event.debugMultiplier;\n                    if ( // Spells (songs)\n                    event.ability.guid !== ACTIONS.THE_WANDERERS_MINUET.id\n                        && event.ability.guid !== ACTIONS.MAGES_BALLAD.id\n                        && event.ability.guid !== ACTIONS.ARMYS_PAEON.id) {\n                        // AND ALSO FOR RANGED TRAIT, BECAUSE APPARENTLY IT'S PHYSICAL DAMAGE ONLY REEEEEEEEEE\n                        fixedMultiplier = Math.trunc((fixedMultiplier + TRAIT_STRENGTH) * 100) / 100;\n                    }\n                    // Collects the damage instances, to be used for calculating crit and 'potencyDamageRatio'\n                    // TODO: Have a filtered array with skills\n                    // ...let's not count Spears for now\n                    if (!this._getStatus(this._player, STATUSES.THE_SPEAR.id)) {\n                        const critTier = this._parseCritBuffs(event);\n                        // We store the damage event, grouping them by Δcrit tiers\n                        if (!this._damageInstances[critTier]) {\n                            this._damageInstances[critTier] = [];\n                        }\n                        this._damageInstances[critTier].push({ event: event, rawDamage: event.amount / fixedMultiplier });\n                    }\n                    // If it's a dot tick (yay, they have/used a dot!), we will collect the data to get a better critMod approximation\n                }\n                else {\n                    const enemy = this._getEnemy(event.targetID);\n                    const dot = this._getDot(enemy, event.ability.guid);\n                    const accumulatedCritBuffs = this._parseDotCritBuffs(event);\n                    // First of all, let's fix cases of broken crit\n                    event.expectedCritRate -= accumulatedCritBuffs * 1000;\n                    while (event.expectedCritRate < BASE_CRIT_PROBABILITY) {\n                        event.expectedCritRate += 256;\n                    }\n                    event.expectedCritRate += accumulatedCritBuffs * 1000;\n                    // Not comfortable with counting Spears just yet\n                    if (!this._getStatus(dot, STATUSES.THE_SPEAR.id)) {\n                        const accumulatedCritBuffs = this._parseDotCritBuffs(event);\n                        const critRate = event.expectedCritRate / 1000 - accumulatedCritBuffs;\n                        this._critFromDots.push(critRate);\n                    }\n                }\n                // We also register the last snapshotter cast, to... snapshot the statuses on the dots\n            }\n            else if (event.type === 'cast'\n                && event.sourceID === this.combatants.selected.id\n                && event.ability\n                && Object.keys(SNAPSHOTTERS).includes(event.ability.guid.toString()) // Why do I have to use toString() here? This is dumb\n            ) {\n                //We make a new one here to avoid issues caused by it being a reference that can be updated after the fact.\n                const newSnapshotter = {\n                    statuses: {},\n                    timestamp: 0,\n                };\n                const player = this._player;\n                const enemy = this._getEnemy(event.targetID);\n                this._snapshotStatuses(newSnapshotter, player, enemy);\n                newSnapshotter.timestamp = event.timestamp;\n                this._snapshotters[event.ability.guid] = newSnapshotter;\n                event.snapshot = newSnapshotter;\n            }\n        }\n        // We calculate this info\n        this.criticalHitProbability = this._getCriticalHitProbability();\n        this.criticalHitRate = this._getCriticalHitRate();\n        this.critMod = this._getCritMod();\n        this.potencyDamageRatio = this._getPotencyDamageRatio();\n        // Return all this shit\n        return events;\n    }\n    // Returns the enemy statuses state and dots state given the ID\n    _getEnemy(targetId) {\n        if (!this._enemies[targetId]) {\n            this._enemies[targetId] = {\n                statuses: {},\n                dots: {},\n            };\n        }\n        return this._enemies[targetId];\n    }\n    // Returns the dot state from an enemy given the status ID\n    _getDot(enemy, statusId) {\n        if (!enemy.dots[statusId]) {\n            enemy.dots[statusId] = {\n                statuses: {},\n            };\n        }\n        return enemy.dots[statusId];\n    }\n    // Returns the latest snapshotter state\n    _getSnapshotter(skillId) {\n        if (!this._snapshotters[skillId]) {\n            this._snapshotters[skillId] = {\n                statuses: {},\n                timestamp: 0,\n            };\n        }\n        return this._snapshotters[skillId];\n    }\n    _getStatus(entity, status) {\n        return entity.statuses[status] || false;\n    }\n    // Copies all the statuses from multiple sources to a target entity\n    _snapshotStatuses(target, ...sources) {\n        sources.forEach(source => {\n            Object.keys(source.statuses).forEach(status => {\n                //To avoid having it be a reference.\n                target.statuses[status] = {\n                    isActive: source.statuses[status].isActive,\n                    strength: source.statuses[status].strength,\n                };\n            });\n        });\n    }\n    // Returns the accumulated crit modifier from all the currently active crit buffs/debuffs\n    _parseCritBuffs(event) {\n        // We need to get the specific enemy in case it's Chain Stratagem\n        const enemy = this._getEnemy(event.targetID);\n        const player = this._player;\n        let accumulatedCritBuffs = 0;\n        for (const modifier of CRIT_MODIFIERS) {\n            const enemyStatus = this._getStatus(enemy, modifier.id);\n            const playerStatus = this._getStatus(player, modifier.id);\n            if (modifier.id === STATUSES.CHAIN_STRATAGEM.id && enemyStatus && enemyStatus.isActive) {\n                accumulatedCritBuffs += enemyStatus.strength;\n            }\n            else if (playerStatus && playerStatus.isActive) {\n                accumulatedCritBuffs += playerStatus.strength;\n            }\n        }\n        return accumulatedCritBuffs;\n    }\n    // Same as above, but dots statuses are snapshotted, so they're stored separately\n    _parseDotCritBuffs(event) {\n        // We need the enemy to which the dot was applied\n        const enemy = this._getEnemy(event.targetID);\n        const dot = this._getDot(enemy, event.ability.guid);\n        let accumulatedCritBuffs = 0;\n        for (const modifier of CRIT_MODIFIERS) {\n            const dotStatus = this._getStatus(dot, modifier.id);\n            if (dotStatus && dotStatus.isActive) {\n                accumulatedCritBuffs += dotStatus.strength;\n            }\n        }\n        return accumulatedCritBuffs;\n    }\n    // Sorry, but these constants are all fucking magic\n    /* eslint-disable no-magic-numbers */\n    // Reference to the formulas: https://docs.google.com/document/d/1h85J3xPhVZ2ubqR77gzoD16L4T-Pltv3dnsKthE4k60/edit\n    // Credits to The TheoryJerks\n    _getCriticalHitProbability() {\n        // If we have crit rate information from dots, we use that instead\n        if (this._critFromDots.length) {\n            return this._getEmpiricalRuleSubsetMean(this._critFromDots, DEVIATION_PRECISION);\n        }\n        // Otherwise, some mathmagic takes place to approximate the crit rate\n        const rates = [];\n        for (const critTier of Object.keys(this._damageInstances)) {\n            const sampleSize = this._damageInstances[critTier].length;\n            const critAmount = this._damageInstances[critTier].filter(x => x.event.criticalHit).length;\n            const rate = Math.max((critAmount / sampleSize) - Number.parseFloat(critTier), 0);\n            rates.push({ rate: rate, amount: sampleSize });\n        }\n        const weightedRates = rates.reduce((acc, value) => acc + value.rate * value.amount, 0);\n        const totalAmount = rates.reduce((acc, value) => acc + value.amount, 0);\n        return weightedRates / totalAmount;\n    }\n    _getCriticalHitRate() {\n        const critRate = this.criticalHitProbability || this._getCriticalHitProbability();\n        // Time to guesstimate the critical hit rate attribute\n        return (((critRate * 1000) - 50) * LEVEL_MOD_80 / 200) + BASE_SUBSTAT_80;\n    }\n    _getCritMod() {\n        const chr = this.criticalHitRate || this._getCriticalHitRate();\n        // Time to guesstimate the critMod:\n        return Math.floor((200 * (chr - BASE_SUBSTAT_80) / LEVEL_MOD_80) + 1400) / 1000;\n    }\n    /* eslint-enable no-magic-numbers */\n    // We use the damage events to determine 'potencyDamageRatio'\n    // tl;dr: 'potencyDamageRatio' is an approximation to damage to potency ratio, ignoring the natural 5% spread because we don't need this kind of precision\n    _getPotencyDamageRatio() {\n        const values = [];\n        const critMod = this.critMod || this._getCritMod();\n        // We iterate over all damage events, across all crit buff tiers\n        for (const critTier of Object.keys(this._damageInstances)) {\n            for (const instance of this._damageInstances[critTier]) {\n                // Let's not count auto attacks, because they have a different formula and aren't affected by the 20% trait\n                if (instance.event.ability.guid === ACTIONS.SHOT.id) {\n                    continue;\n                }\n                const skill = getDataBy(ACTIONS, 'id', instance.event.ability.guid);\n                if (!skill) {\n                    continue;\n                }\n                // We have already calculated the unbuffed damage, now we need to strip crit/dhit modifiers\n                let rawDamage = instance.rawDamage;\n                if (instance.event.criticalHit) {\n                    rawDamage = Math.trunc(rawDamage / critMod);\n                }\n                if (instance.event.directHit) {\n                    rawDamage = Math.trunc(rawDamage / DHIT_MOD);\n                }\n                // If we have the potency information for the current skill and it's not a conditional potency skill, we add it's potency ratio to the array of potential 'K' values\n                if (skill.potency && !isNaN(skill.potency)) {\n                    values.push(Math.round(rawDamage * 100 / skill.potency));\n                }\n            }\n        }\n        // If there are no damage instances, we can't really calculate the ratio. Let's return 1. Will be broken as fuck, but there are no damage events anyway, so lol\n        if (!values || !values.length) {\n            return 1;\n        }\n        return this._getEmpiricalRuleSubsetMean(values, DEVIATION_PRECISION);\n    }\n    // This method returns the mean of the data subset within {n} standard deviations of the mean of the data set\n    _getEmpiricalRuleSubsetMean(dataset, n) {\n        const mean = math.mean(dataset);\n        const standardDeviation = math.std(dataset);\n        return math.mean(dataset.filter(v => v >= mean - n * standardDeviation && v <= mean + n * standardDeviation));\n    }\n}\nAdditionalStats.handle = 'additionalStats';\nAdditionalStats.dependencies = [\n    'additionalEvents',\n    'combatants',\n    'hitType',\n];\n","/**\n * @author Yumiya\n */\nimport { t } from '@lingui/macro';\nimport { Trans } from '@lingui/react';\nimport React, { Fragment } from 'react';\nimport { Accordion, Icon, Message, List, Table } from 'semantic-ui-react';\nimport Module from 'parser/core/Module';\nimport { getDataBy } from 'data';\nimport STATUSES from 'data/STATUSES';\nimport ACTIONS from 'data/ACTIONS';\nimport { Rule, TieredRule, Requirement, TARGET } from 'parser/core/modules/Checklist';\nimport { ActionLink, StatusLink } from 'components/ui/DbLink';\nimport NormalisedMessage from 'components/ui/NormalisedMessage';\nimport styles from './Barrage.module.css';\nconst SUCCESS = TARGET.SUCCESS;\nconst WARNING = TARGET.WARN;\nconst ERROR = TARGET.FAIL;\nconst SEVERITY = {\n    [SUCCESS]: {\n        icon: 'checkmark',\n        text: 'text-success',\n    },\n    [WARNING]: {\n        icon: 'warning sign',\n        text: 'text-warning',\n    },\n    [ERROR]: {\n        icon: 'remove',\n        text: 'text-error',\n    },\n};\n// Buffer in ms when checking for multiple hits close enough to be from the same cast (completely arbitraty, fite me)\nconst TRIPLE_HIT_BUFFER = 500;\n// Weights for each possible bad barrage, for calculating the percent\nconst BAD_BARRAGE_WEIGHT = 4;\nconst UNALIGNED_BARRAGE_WEIGHT = 1;\nconst PROC_WASTED_WEIGHT = 2;\nconst DROPPED_BARRAGE_WEIGHT = 5;\n// List of ARC/BRD single-target weaponskills that can be Barrage'd, but shouldn't\nconst BAD_ST_WEAPONSKILLS = [\n    ACTIONS.HEAVY_SHOT.id,\n    ACTIONS.BURST_SHOT.id,\n    ACTIONS.VENOMOUS_BITE.id,\n    ACTIONS.WINDBITE.id,\n    ACTIONS.IRON_JAWS.id,\n    ACTIONS.CAUSTIC_BITE.id,\n    ACTIONS.STORMBITE.id,\n];\n// List of all ARC/BRD single-target weaponskills\nconst WEAPONSKILLS = [\n    ACTIONS.STRAIGHT_SHOT.id,\n    ACTIONS.REFULGENT_ARROW.id,\n].concat(BAD_ST_WEAPONSKILLS);\nexport default class Barrage extends Module {\n    constructor(...args) {\n        super(...args);\n        this._lastWeaponskill = undefined;\n        this._barrageEvents = [];\n        // Event hooks\n        this.addHook('cast', {\n            by: 'player',\n            abilityId: ACTIONS.BARRAGE.id,\n        }, this._onBarrageCast);\n        this.addHook('damage', {\n            by: 'player',\n            abilityId: WEAPONSKILLS,\n        }, this._onStWeaponskillDamage);\n        this.addHook('applybuff', {\n            by: 'player',\n            abilityId: STATUSES.STRAIGHTER_SHOT.id,\n        }, this._onSSApply);\n        this.addHook('removebuff', {\n            by: 'player',\n            abilityId: STATUSES.STRAIGHTER_SHOT.id,\n        }, this._onSSRemove);\n        this.addHook('complete', this._onComplete);\n    }\n    _onBarrageCast(event) {\n        // Creates a new Barrage Event with only the cast information and Raging Strikes alignment for now\n        this._addBarrage(event);\n    }\n    _onStWeaponskillDamage(event) {\n        // Checks for damage events that are the same as the last weaponskill damage registered,\n        // within TRIPLE_HIT_BUFFER milliseconds of each other\n        const skill = this._getLastWeaponskill();\n        if (skill\n            && this.util.timeSince(skill.timestamp) <= TRIPLE_HIT_BUFFER\n            && skill.id === event.ability.guid) {\n            // Adds this weaponskill damage event to the list\n            skill.addDamageEvent(event);\n            // When there are three damage events from the same weaponskill within the buffer time,\n            // checks out a Barrage by adding these damage events to the latest Barrage Event object\n            // (that only contains the cast event and alignment status at this point)\n            if (skill.hits === STATUSES.BARRAGE.amount) {\n                this._checkOutBarrage(skill);\n            }\n            // Otherwise, sets a new last weaponskill event\n        }\n        else {\n            this._setLastWeaponskill(event);\n        }\n    }\n    _onSSApply() {\n        // This so that we can check to see if barrage was used while a Straighter Shot proc was already avaliable\n        this._hasSS = true;\n    }\n    _onSSRemove() {\n        // This so that we can check to see if barrage was used while a Straighter Shot proc was already avaliable\n        this._hasSS = false;\n    }\n    _onComplete() {\n        // - badBarrage: Barrage that was used in a skill from BAD_ST_WEAPONSKILLS list\n        // - unalignedBarrage: Barrage that was not aligned with Raging Strikes\n        const badBarrages = this._barrageEvents.filter(x => x.isBad);\n        const unalignedBarrages = this._barrageEvents.filter(x => !x.aligned);\n        const wastedProcs = this._barrageEvents.filter(x => x.wastedProc);\n        const droppedBarrages = this._barrageEvents.filter(x => x.isDropped);\n        // Barrage usage Rule added to the checklist\n        if (this._getBarrage()) {\n            this.checklist.add(new WeightedTieredRule({\n                name: <Trans id=\"brd.barrage.checklist.default-name\">Barrage usage</Trans>,\n                description: <Trans id=\"brd.barrage.checklist.description\">\n\t\t\t\t\tAn analysis of your {ACTIONS.BARRAGE.name} casts. More details in the <a href=\"javascript:void(0);\" onClick={() => this.parser.scrollTo(this.constructor.handle)}><NormalisedMessage message={this.constructor.title}/></a> module below.\n\t\t\t\t</Trans>,\n                tiers: { 0: ERROR, 90: WARNING, 100: SUCCESS },\n                requirements: [\n                    new WeightedRequirement({\n                        name: <Trans id=\"brd.barrage.checklist.used-on-refulgent\"><ActionLink {...ACTIONS.BARRAGE}/>s used on <ActionLink {...ACTIONS.REFULGENT_ARROW}/></Trans>,\n                        percent: () => { return 100 - ((badBarrages.length) * 100 / this._barrageEvents.length); },\n                        weight: BAD_BARRAGE_WEIGHT,\n                    }),\n                    new WeightedRequirement({\n                        name: <Trans id=\"brd.barrage.checklist.aligned-barrage\"><ActionLink {...ACTIONS.BARRAGE}/>s aligned with <ActionLink {...ACTIONS.RAGING_STRIKES}/></Trans>,\n                        percent: () => { return 100 - ((unalignedBarrages.length) * 100 / this._barrageEvents.length); },\n                        weight: UNALIGNED_BARRAGE_WEIGHT,\n                    }),\n                    new WeightedRequirement({\n                        name: <Trans id=\"brd.barrage.checklist.granted-refulgent\"><ActionLink {...ACTIONS.BARRAGE}/>s that granted <StatusLink {...STATUSES.STRAIGHTER_SHOT}/></Trans>,\n                        percent: () => { return 100 - ((wastedProcs.length) * 100 / this._barrageEvents.length); },\n                        weight: PROC_WASTED_WEIGHT,\n                    }),\n                    new WeightedRequirement({\n                        name: <Trans id=\"brd.barrage.checklist.dealt-damage\"><ActionLink {...ACTIONS.BARRAGE}/>s that dealt damage</Trans>,\n                        percent: () => { return 100 - ((droppedBarrages.length) * 100 / this._barrageEvents.length); },\n                        weight: DROPPED_BARRAGE_WEIGHT,\n                    }),\n                ],\n            }));\n        }\n        else {\n            this.checklist.add(new Rule({\n                name: <Trans id=\"brd.barrage.no-barrage-checklist.name\">No Barrage usage</Trans>,\n                description: <Trans id=\"brd.barrage.no-barrage-checklist.description\"> <ActionLink {...ACTIONS.BARRAGE}/> into <ActionLink {...ACTIONS.REFULGENT_ARROW}/> is Bard's highest single-target attack, make sure to use it during a fight.</Trans>,\n                target: 95,\n                requirements: [\n                    new Requirement({\n                        name: <Trans id=\"brd.barrage.no-barrage-checklist.no-barrage-cast\"><ActionLink {...ACTIONS.BARRAGE}/> cast</Trans>,\n                        percent: () => 0,\n                    }),\n                ],\n            }));\n        }\n    }\n    output() {\n        const barrageEvents = this._barrageEvents;\n        if (barrageEvents.length === 0) {\n            return;\n        }\n        // Builds a panel for each barrage event\n        const panels = barrageEvents.map(barrage => {\n            const panelProperties = {\n                barrage: barrage,\n                title: undefined,\n                tuples: [],\n                contents: [],\n            };\n            // If it's any kind of bad barrages:\n            //Any bad barrage could have also wasted a straighter shot proc, so do this first\n            if (barrage.wastedProc) {\n                // Adds the {issue, severity, reason} tuple corresponding a wastedProc to the panel\n                panelProperties.tuples.push({\n                    issue: <Trans id=\"brd.barrage.issue.wasted-proc\">\n\t\t\t\t\t\tThere was a <StatusLink {...STATUSES.STRAIGHTER_SHOT}/> proc that went <strong>unused</strong>.\n\t\t\t\t\t</Trans>,\n                    severity: WARNING,\n                    reason: <Trans id=\"brd.barrage.issue.wasted-proc.reason\">\n\t\t\t\t\t\t{ACTIONS.BARRAGE.name} gives you a guaranteed <StatusLink {...STATUSES.STRAIGHTER_SHOT}/> proc.  If you already have a proc avaliable, use it before using {ACTIONS.BARRAGE.name}.\n\t\t\t\t\t</Trans>,\n                });\n            }\n            if (barrage.isDropped) {\n                panelProperties.tuples.push({\n                    issue: <Trans id=\"brd.barrage.issue.dropped\">\n\t\t\t\t\t\tThis barrage did <strong>not</strong> deal any damage.\n\t\t\t\t\t</Trans>,\n                    severity: ERROR,\n                    reason: <Trans id=\"brd.barrage.issue.dropped.reason\">\n\t\t\t\t\t\tUsing <StatusLink {...STATUSES.BARRAGE}/> on <strong>anything</strong> is better than letting it drop. Be mindful of transitions and invulnerability periods.\n\t\t\t\t\t</Trans>,\n                });\n            }\n            else if (barrage.isBad || !barrage.aligned) {\n                // Calculates the total damage, total DPS, and potential damage for each \"good\" barrage skill\n                const totalDamage = barrage.damageEvents.reduce((x, y) => x + y.amount, 0);\n                const totalDPS = this.util.formatDecimal(totalDamage * 1000 / this.parser.fightDuration);\n                let potentialDamage = totalDamage;\n                let potentialRefulgentDamage = Math.trunc(ACTIONS.REFULGENT_ARROW.potency * totalDamage / barrage.skillBarraged.potency);\n                // If this barrage is not aligned, multiplies the potential damage with Raging Strikes damage modifier (10%)\n                if (!barrage.aligned) {\n                    // Applies RS modifier\n                    potentialRefulgentDamage = Math.trunc(potentialRefulgentDamage * (1 + STATUSES.RAGING_STRIKES.amount));\n                    potentialDamage = Math.trunc(potentialDamage * (1 + STATUSES.RAGING_STRIKES.amount));\n                    // Adds the {issue, severity, reason} tuple corresponding an unalignedBarrage to the panel\n                    panelProperties.tuples.push({\n                        issue: <Trans id=\"brd.barrage.issue.unaligned-barrage\">\n\t\t\t\t\t\t\tThis barrage did <strong>not</strong> receive the effects of <StatusLink {...STATUSES.RAGING_STRIKES}/>.\n\t\t\t\t\t\t</Trans>,\n                        severity: WARNING,\n                        reason: <Trans id=\"brd.barrage.issue.unaligned-barrage.reason\">\n\t\t\t\t\t\t\tBoth {ACTIONS.BARRAGE.name} and <ActionLink {...ACTIONS.RAGING_STRIKES}/> have a cooldown of {ACTIONS.BARRAGE.cooldown} seconds. Keeping them aligned is often better than holding onto {ACTIONS.BARRAGE.name}.\n\t\t\t\t\t\t</Trans>,\n                    });\n                }\n                // Now that it's gone through the Raging Strikes check, can actually calculate the potential DPS\n                // Calculating it beforehand could potentially give rounding errors\n                // (It's still not the best way of doing it, but gives me some peace of mind)\n                const potentialDPS = this.util.formatDecimal(potentialDamage * 1000 / this.parser.fightDuration);\n                const potentialRefulgentDPS = this.util.formatDecimal(potentialRefulgentDamage * 1000 / this.parser.fightDuration);\n                // DPS loss is the difference between potential DPS and total DPS (duh)\n                let dpsLoss = this.util.formatDecimal(potentialDPS - totalDPS);\n                // If this was a badBarrage\n                if (barrage.isBad) {\n                    dpsLoss = `${this.util.formatDecimal(potentialRefulgentDPS - totalDPS)}`;\n                    // Adds the {issue, severity, reason} tuple corresponding a badBarrage to the panel\n                    panelProperties.tuples.push({\n                        issue: <Trans id=\"brd.barrage.issue.bad-barrage\">\n\t\t\t\t\t\t\tThis barrage was <strong>not</strong> used on <ActionLink {...ACTIONS.REFULGENT_ARROW}/>.\n\t\t\t\t\t\t</Trans>,\n                        severity: ERROR,\n                        reason: <Trans id=\"brd.barrage.issue.bad-barrage.reason\">\n\t\t\t\t\t\t\tYour strongest weaponskill is <ActionLink {...ACTIONS.REFULGENT_ARROW}/>. Make sure you only use your {ACTIONS.BARRAGE.name} on that skill.\n\t\t\t\t\t\t</Trans>,\n                    });\n                }\n                // Only adds the DPS loss table as a custom content in case it was any case of bad barrage (badBarrage, unalignedBarrage, worstBarrageNA)\n                // That's what the first 'if' is for\n                panelProperties.contents.push(<>\n\t\t\t\t\t<Table collapsing unstackable celled>\n\t\t\t\t\t\t<Table.Header>\n\t\t\t\t\t\t\t<Table.Row>\n\t\t\t\t\t\t\t\t<Table.HeaderCell width={2}>\n\t\t\t\t\t\t\t\t\t<Trans id=\"brd.barrage.panel.table-header.total-damage\"><strong>Total damage</strong></Trans>\n\t\t\t\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t\t\t\t<Table.HeaderCell width={2}>\n\t\t\t\t\t\t\t\t\t<Trans id=\"brd.barrage.panel.table-header.potential-damage\"><strong>Potential damage</strong></Trans>\n\t\t\t\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t\t\t\t<Table.HeaderCell width={2} negative>\n\t\t\t\t\t\t\t\t\t<Trans id=\"brd.barrage.panel.table-header.dps-loss\"><strong>DPS loss</strong></Trans>\n\t\t\t\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t\t\t</Table.Row>\n\t\t\t\t\t\t</Table.Header>\n\t\t\t\t\t\t<Table.Body>\n\t\t\t\t\t\t\t<Table.Row>\n\t\t\t\t\t\t\t\t<Table.Cell>{this.util.formatDamageNumber(totalDamage)}</Table.Cell>\n\t\t\t\t\t\t\t\t<Table.Cell>{this.util.formatDamageNumber(potentialDamage)}</Table.Cell>\n\t\t\t\t\t\t\t\t<Table.Cell negative>{this.util.formatDamageNumber(dpsLoss)}</Table.Cell>\n\t\t\t\t\t\t\t</Table.Row>\n\t\t\t\t\t\t</Table.Body>\n\t\t\t\t\t</Table>\n\t\t\t\t</>);\n            }\n            // Then builds the panel and returns it in the mapping function\n            return this.buildPanel(panelProperties);\n        });\n        // Output is an Accordion made with panels, one for each barrage event\n        return <Accordion exclusive={false} panels={panels} styled fluid/>;\n    }\n    // Adds a new barrage event to the array, with only cast and alignment information for now\n    _addBarrage(event) {\n        let aligned = true;\n        // Checks for Raging Strikes alignment\n        if (!event\n            || this.util.timeUntilFinish(event.timestamp) >= ACTIONS.BARRAGE.cooldown * 1000\n                && !this.util.hasBuff(STATUSES.RAGING_STRIKES)) {\n            aligned = false;\n        }\n        // Adds the barrage event to the array\n        this._barrageEvents.push({\n            castEvent: event,\n            aligned: aligned,\n            wastedProc: this._hasSS,\n            get timestamp() { return this.castEvent ? this.castEvent.timestamp : 0; },\n            get isBad() { return this.skillBarraged && this.skillBarraged.id && BAD_ST_WEAPONSKILLS.includes(this.skillBarraged.id) || undefined; },\n            get isDropped() { return !this.damageEvents || !this.damageEvents.length; },\n        });\n    }\n    // Returns the most recent barrage event, or undefined if there's none\n    _getBarrage() {\n        const index = this._barrageEvents.length - 1;\n        return index >= 0 ? this._barrageEvents[index] : undefined;\n    }\n    // Checks out a barrage by adding the damage events information to the barrage event and resetting the last skill tracker\n    _checkOutBarrage(skill) {\n        let barrage = this._getBarrage();\n        if (!barrage) {\n            // If no previous barrage cast was found, we assume it was pre-pull. We add a barrage with an undefined event\n            this._addBarrage();\n            barrage = this._getBarrage();\n        }\n        barrage.skillBarraged = skill.action;\n        barrage.damageEvents = skill.damageEvents.slice();\n        this._lastWeaponskill = undefined;\n    }\n    // Returns the last weaponskill used information (action and damage events)\n    _getLastWeaponskill() {\n        return this._lastWeaponskill;\n    }\n    // Sets the last weaponskill tracker given the damage event\n    _setLastWeaponskill(event) {\n        this._lastWeaponskill = {\n            action: getDataBy(ACTIONS, 'id', event.ability.guid),\n            damageEvents: [event],\n            get id() { return this.action && this.action.id; },\n            get timestamp() { return this.damageEvents && this.damageEvents[0] && this.damageEvents[0].timestamp; },\n            get hits() { return this.damageEvents && this.damageEvents.length; },\n            addDamageEvent(event) { this.damageEvents.push(event); },\n        };\n    }\n    // Builds a panel for each cast of Barrage and its respectives issues, to be provided to the final Accordion\n    // Each panel has the following components:\n    // - A title, containing:\n    //    - timestamp\n    //    - name of the barrage'd skill\n    //    - icon indicating severity\n    //    - a custom content, provided via constructor, to be added to the title\n    // - A list of issues, containing:\n    //    - severity icon and color (tuples[].severity)\n    //    - issue description (tuples[].issue)\n    // - A list of reasons, containing:\n    //    - the reason explaining why each issue is... an issue (tuples[].reason)\n    // - A list of contents, containing:\n    //    - a custom content, provided via constructor, to be added after the issues and reasons (i.e.: the DPS loss table)\n    // - A message block, containing:\n    //    - a formatted text log for each barrage hit\n    buildPanel({ barrage, title, tuples, contents }) {\n        // Sorting the tuples by severity\n        tuples.sort((a, b) => (a.severity || 0) - (b.severity || 0));\n        // Severity of a panel is determined by the highest severity of the issues in it described\n        const severity = tuples.length ? this._severitySelector(tuples.map(t => t.severity)) : SUCCESS;\n        // Panel title\n        let defaultTitle = <></>;\n        if (barrage.isDropped) {\n            defaultTitle = <Trans id=\"brd.barrage.panel.title.barrage-dropped\">\n\t\t\t\t{this.parser.formatTimestamp(barrage.timestamp)} {ACTIONS.BARRAGE.name} used\n\t\t\t</Trans>;\n        }\n        else {\n            defaultTitle = <Trans id=\"brd.barrage.panel.title.barrage-not-dropped\">\n\t\t\t\t{this.parser.formatTimestamp(barrage.timestamp)} {ACTIONS.BARRAGE.name} used on <ActionLink {...barrage.skillBarraged}/>\n\t\t\t</Trans>;\n        }\n        // List of issues\n        const issueElements = tuples && tuples.length && tuples.map(t => {\n            return t.issue && <Message key={tuples.indexOf(t)} error={t.severity === ERROR} warning={t.severity === WARNING} success={t.severity === SUCCESS}>\n\t\t\t\t<Icon name={SEVERITY[t.severity].icon}/>\n\t\t\t\t<span>{t.issue}</span>\n\t\t\t</Message>;\n        }) || undefined;\n        // List of reasons\n        const reasonElements = tuples && tuples.length && <div className={styles.description}>\n\t\t\t<List bulleted relaxed>\n\t\t\t\t{tuples.map(t => {\n            return <List.Item key={tuples.indexOf(t)}>{t.reason}</List.Item>;\n        })}\n\t\t\t</List>\n\t\t</div> || undefined;\n        // List of contents\n        const contentElements = contents && contents.length && contents.map(c => {\n            return <Fragment key={contents.indexOf(c)}>\n\t\t\t\t{c}\n\t\t\t</Fragment>;\n        }) || undefined;\n        // Damage log\n        const damageElements = barrage.damageEvents && barrage.damageEvents.length && <Message info>\n\t\t\t<List>\n\t\t\t\t<List.Header>\n\t\t\t\t\t<Trans id=\"brd.barrage.panel.damage-elements.header\">Damage:</Trans>\n\t\t\t\t</List.Header>\n\t\t\t\t<List.Content>\n\t\t\t\t\t<List.Item>\n\t\t\t\t\t\t<Icon name={'arrow right'}/>\n\t\t\t\t\t\t{this.util.formatDamageLog(barrage.damageEvents[0])}\n\t\t\t\t\t</List.Item>\n\t\t\t\t\t<List.Item>\n\t\t\t\t\t\t<Icon name={'arrow right'}/>\n\t\t\t\t\t\t{this.util.formatDamageLog(barrage.damageEvents[1])}\n\t\t\t\t\t</List.Item>\n\t\t\t\t\t<List.Item>\n\t\t\t\t\t\t<Icon name={'arrow right'}/>\n\t\t\t\t\t\t{this.util.formatDamageLog(barrage.damageEvents[2])}\n\t\t\t\t\t</List.Item>\n\t\t\t\t</List.Content>\n\t\t\t</List>\n\t\t</Message> || undefined;\n        // Builds the full panel\n        return {\n            key: barrage.timestamp,\n            title: {\n                content: <>\n\t\t\t\t\t<Icon name={SEVERITY[severity].icon} className={SEVERITY[severity].text}/>\n\t\t\t\t\t{defaultTitle}\n\t\t\t\t\t{title}\n\t\t\t\t</>,\n            },\n            content: {\n                content: <>\n\t\t\t\t\t{issueElements}\n\t\t\t\t\t{reasonElements}\n\t\t\t\t\t{contentElements}\n\t\t\t\t\t{damageElements}\n\t\t\t\t</>,\n            },\n        };\n    }\n    // Needs to be fancy for this, since one type of severity is 'undefined'\n    _severitySelector(severities) {\n        const severity = Math.min(...severities.map(s => s || 0));\n        return severity !== 0 ? severity : undefined;\n    }\n}\nBarrage.handle = 'barrage';\nBarrage.title = t('brd.barrage.title') `Barrage`;\nBarrage.dependencies = [\n    'checklist',\n    'util',\n];\n// WeightedTieredRule is an extention of TieredRule, with the following additions:\n// - Defined a custom percentage method to consider weights for each requirement\nclass WeightedTieredRule extends TieredRule {\n    constructor(options) {\n        super({\n            ...options,\n        });\n        // Normalize the weights\n        const totalWeight = this.requirements.reduce((acc, req) => acc + (req.weight || 1), 0);\n        this.requirements.forEach(r => r.weight = (r.weight || 1) / totalWeight);\n    }\n    get percent() {\n        return this.requirements.reduce((acc, req) => acc + (req.percent * req.weight), 0);\n    }\n}\n// WeightedRequirement is an extension of Requirement, with the following addition:\n// - A requirement now can have a weight attached to it, used when calculating the overall Rule percentage\nclass WeightedRequirement extends Requirement {\n    constructor(options) {\n        super({\n            weight: 1,\n            ...options,\n        });\n    }\n}\n","/**\n * @author Yumiya\n */\nimport React, { Fragment } from 'react';\nimport Module from 'parser/core/Module';\nimport STATUSES from 'data/STATUSES';\nimport ACTIONS from 'data/ACTIONS';\nimport { ActionLink, StatusLink } from 'components/ui/DbLink';\nimport { Rule, Requirement } from 'parser/core/modules/Checklist';\n//const DROP_TOLERANCE = 1000\nexport default class DoTs extends Module {\n    //_dotComponent = new DotComponent(STATUSES.CAUSTIC_BITE.id, STATUSES.STORMBITE.id)\n    constructor(...args) {\n        super(...args);\n        /*const dotFilter = {\n            by: 'player',\n            abilityId: [STATUSES.CAUSTIC_BITE.id, STATUSES.STORMBITE.id],\n        }*/\n        //this.addHook('applydebuff', dotFilter, this._onDotApply)\n        //this.addHook('removedebuff', dotFilter, this._onDotRemove)\n        this.addHook('complete', this._onComplete);\n    }\n    _onDotApply(event) {\n        this._dotComponent[event.ability.guid].apply(event.timestamp);\n    }\n    _onDotRemove(event) {\n        this._dotComponent[event.ability.guid].remove(event.timestamp);\n    }\n    _onComplete() {\n        this.checklist.add(new Rule({\n            name: 'Keep your DoTs up',\n            description: <> Most of Bard's DPS comes either directly or indirectly from <ActionLink {...ACTIONS.STORMBITE}/> and <ActionLink {...ACTIONS.CAUSTIC_BITE}/>.\n\t\t\t\tMake sure you have these skills applied on the target at all times. Use <ActionLink {...ACTIONS.IRON_JAWS}/> to refresh the timer on the Damage over Time (DoT) debuff.\n\t\t\t</>,\n            target: 95,\n            requirements: [\n                new Requirement({\n                    name: <Fragment><StatusLink {...STATUSES.STORMBITE}/> uptime</Fragment>,\n                    percent: () => this.util.getDebuffUptime(STATUSES.STORMBITE),\n                }),\n                new Requirement({\n                    name: <Fragment><StatusLink {...STATUSES.CAUSTIC_BITE}/> uptime</Fragment>,\n                    percent: () => this.util.getDebuffUptime(STATUSES.CAUSTIC_BITE),\n                }),\n            ],\n        }));\n    }\n}\nDoTs.handle = 'dots';\nDoTs.dependencies = [\n    'checklist',\n    'util',\n];\n/*class DotComponent {\n\n    constructor(...actions) {\n        for (const action of actions) {\n            this[action] = new DotObject()\n        }\n    }\n}*/\n/*class DotObject {\n    _windows = []\n\n    apply(t) {\n        if (!this.isRunning()) {\n            // Two possible scenarios:\n\n            // 1) The dot didn't actually drop, was just a hiccup\n            if (this._windows.length && t - this._windows[this._windows.length - 1].end <= DROP_TOLERANCE) {\n                this._windows[this._windows.length - 1].end = undefined\n\n            // 2) The dot wasn't up to begin with or actually dropped\n            } else {\n                this._windows.push({start: t})\n            }\n        }\n    }\n\n    remove(t) {\n        if (this.isRunning() && this._windows.length) {\n            this._windows[this._windows.length - 1].end = t\n        }\n    }\n\n    isRunning() {\n        return this._windows.length && !this._windows[this._windows.length - 1].end\n    }\n}*/\n","/**\n * @author Yumiya\n */\nimport ACTIONS from 'data/ACTIONS';\nimport { CooldownDowntime } from 'parser/core/modules/CooldownDowntime';\nexport default class OGCDDowntime extends CooldownDowntime {\n    constructor() {\n        super(...arguments);\n        this.trackedCds = [\n            { cooldowns: [ACTIONS.BARRAGE] },\n            { cooldowns: [ACTIONS.RAGING_STRIKES] },\n            { cooldowns: [ACTIONS.SIDEWINDER] },\n        ];\n        this.checklistTarget = 100;\n    }\n}\n","/**\n * @author Yumiya\n */\nimport { Trans, Plural } from '@lingui/react';\nimport { t } from '@lingui/macro';\nimport React from 'react';\nimport Module from 'parser/core/Module';\nimport { Accordion, Icon, Message, List, Button, Label } from 'semantic-ui-react';\nimport STATUSES from 'data/STATUSES';\nimport ACTIONS from 'data/ACTIONS';\nimport { ActionLink } from 'components/ui/DbLink';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport { matchClosest } from 'utilities';\nimport styles from './PitchPerfect.module.css';\nconst DOT_TICK_FREQUENCY = 3000; // 3s\nconst SONG_DURATION = 30000; // 30s\nconst ANIMATION_LOCK = 700; // 700ms (arbitrary, fite me)\nconst CONVERSION_FACTOR = 0.1;\nconst DHIT_MOD = 1.25;\nconst TRAIT_STRENGTH = 0.20;\n// Where's the lazy scale again?\nconst PP = {\n    1: 1,\n    2: 2,\n    3: 3,\n};\nconst PP_POTENCY = ACTIONS.PITCH_PERFECT.potency;\nconst PP_MAX_POTENCY = PP_POTENCY[2];\n// Issues\nconst NONE = 0;\nconst PP_CAST_WIHTOUT_MAX_STACKS = 1;\nconst PP_NOT_CAST_AT_END = 2;\nexport default class PitchPerfect extends Module {\n    constructor(...args) {\n        super(...args);\n        this._enemies = {};\n        this._lastWMCast = undefined;\n        this._lostPotencyFromStacks = 0;\n        this._lostPotencyFromMissedCast = [0, 0];\n        this._ppEvents = [];\n        this.addHook('damage', {\n            by: 'player',\n            abilityId: ACTIONS.PITCH_PERFECT.id,\n        }, this._onPPDamage);\n        this.addHook('pitchPerfect', this._onPPEvent);\n        this.addHook('damage', {\n            by: 'player',\n            abilityId: [STATUSES.CAUSTIC_BITE.id, STATUSES.STORMBITE.id],\n            tick: true,\n        }, this._onDotTick);\n        this.addHook('cast', {\n            by: 'player',\n            abilityId: ACTIONS.THE_WANDERERS_MINUET.id,\n        }, this._onWMCast);\n        this.addHook('complete', this._onComplete);\n    }\n    _onDotTick(event) {\n        // Keeping track of the dot tick on each enemy\n        const enemy = this._getEnemy(event.targetID);\n        enemy.tick[event.ability.guid] = event;\n    }\n    _onWMCast(event) {\n        this._lastWMCast = event;\n    }\n    _onPPDamage(event) {\n        const potencyDamageRatio = this.additionalStats.potencyDamageRatio;\n        let fixedMultiplier = event.debugMultiplier;\n        // AND ALSO FOR RANGED TRAIT, BECAUSE APPARENTLY IT'S PHYSICAL DAMAGE ONLY REEEEEEEEEE\n        fixedMultiplier = Math.trunc((fixedMultiplier + TRAIT_STRENGTH) * 100) / 100;\n        // We get the unbuffed damage\n        let rawDamage = event.amount / fixedMultiplier;\n        // And then strip off critical hit and direct hit mods\n        if (event.criticalHit) {\n            rawDamage = Math.trunc(rawDamage / this.additionalStats.critMod);\n        }\n        if (event.directHit) {\n            rawDamage = Math.trunc(rawDamage / DHIT_MOD);\n        }\n        // We get the approximated potency and then match to the closest real potency\n        const approximatedPotency = rawDamage * 100 / potencyDamageRatio;\n        const potency = matchClosest(PP_POTENCY, approximatedPotency);\n        // We then infer the amount of stacks\n        const stacks = PP_POTENCY.indexOf(potency) + 1;\n        // And finally we fabricate the event\n        this.parser.fabricateEvent({\n            ...event,\n            type: 'pitchPerfect',\n            stacks: stacks,\n            rawDamage: rawDamage,\n        });\n    }\n    _onPPEvent(event) {\n        const enemy = this._getEnemy(event.targetID);\n        const wm = this._lastWMCast;\n        if (event.stacks === undefined) {\n            //Fuck, abort!\n            return;\n        }\n        if (wm === undefined) {\n            //The only time I have encounted this is from broken logs\n            this.brokenLog.trigger(this, 'no previous wm cast', (<Trans id=\"brd.pitch-perfect.trigger.no-wm-cast\">\n\t\t\t\t\t<ActionLink {...ACTIONS.PITCH_PERFECT}/> was used when there was no cast of <ActionLink {...ACTIONS.THE_WANDERERS_MINUET}/> before hand.\n\t\t\t\t</Trans>));\n            return;\n        }\n        const ppEvent = {\n            damageEvent: event,\n            issue: NONE,\n            timeLeftOnSong: Math.max(wm.timestamp + SONG_DURATION - event.timestamp, 0),\n            critOnDot: {\n                [STATUSES.CAUSTIC_BITE.id]: 0,\n                [STATUSES.STORMBITE.id]: 0,\n            },\n            lastTickOnEnemy: enemy.lastTick,\n            get stacks() { return this.damageEvent && this.damageEvent.stacks || undefined; },\n            get timestamp() { return this.damageEvent && this.damageEvent.timestamp; },\n        };\n        this._ppEvents.push(ppEvent);\n        // Only an issue if there are dot ticks left on the song and sufficient time to use PP (animation lock)\n        if (ppEvent.lastTickOnEnemy + DOT_TICK_FREQUENCY >= wm.timestamp + SONG_DURATION - 2 * ANIMATION_LOCK) {\n            return;\n        }\n        // We write down the crit on each dot, to provide the information later\n        ppEvent.critOnDot[STATUSES.CAUSTIC_BITE.id] = enemy.tick[STATUSES.CAUSTIC_BITE.id] && enemy.tick[STATUSES.CAUSTIC_BITE.id].expectedCritRate * CONVERSION_FACTOR;\n        ppEvent.critOnDot[STATUSES.STORMBITE.id] = enemy.tick[STATUSES.STORMBITE.id] && enemy.tick[STATUSES.STORMBITE.id].expectedCritRate * CONVERSION_FACTOR;\n        if (event.stacks !== PP[3]) {\n            ppEvent.lostPotency = PP_MAX_POTENCY - PP_POTENCY[event.stacks - 1];\n            ppEvent.issue = PP_CAST_WIHTOUT_MAX_STACKS;\n        }\n    }\n    _onComplete() {\n        // We remove bad PPs that were used because of downtime\n        this._cleanUpPPs();\n        const badPPs = this._ppEvents.filter(pp => pp.issue === PP_CAST_WIHTOUT_MAX_STACKS).length;\n        const missedPPs = this._ppEvents.filter(pp => pp.issue === PP_NOT_CAST_AT_END).length;\n        if (badPPs === 0 && missedPPs === 0) {\n            // Good job!\n            return;\n        }\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.PITCH_PERFECT.icon,\n            content: <Trans id=\"brd.pitch-perfect.cast-without-stacks.suggestion\">\n\t\t\t\tUse {ACTIONS.PITCH_PERFECT.name} at <strong>3 stacks</strong>. Only use it at <strong>2 or less stacks</strong> when there are no more DoT ticks before <ActionLink {...ACTIONS.THE_WANDERERS_MINUET}/> ends.\n\t\t\t</Trans>,\n            tiers: {\n                900: SEVERITY.MAJOR,\n                400: SEVERITY.MEDIUM,\n                150: SEVERITY.MINOR,\n            },\n            value: this._lostPotencyFromStacks,\n            why: <Trans id=\"brd.pitch-perfect.cast-without-stacks.suggestion.reason\">\n\t\t\t\t<Plural value={badPPs} one=\"# cast\" other=\"# casts\"/> of {ACTIONS.PITCH_PERFECT.name} with the wrong amount of stacks.\n\t\t\t</Trans>,\n        }));\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.PITCH_PERFECT.icon,\n            content: <Trans id=\"brd.pitch-perfect.no-cast-at-end.suggestion\">\n\t\t\t\tUse any stacks you have of {ACTIONS.PITCH_PERFECT.name} after there are no more DoT ticks before <ActionLink {...ACTIONS.THE_WANDERERS_MINUET}/> ends.\n\t\t\t</Trans>,\n            tiers: {\n                8: SEVERITY.MAJOR,\n                5: SEVERITY.MEDIUM,\n                2: SEVERITY.MINOR,\n            },\n            value: missedPPs,\n            why: <Trans id=\"brd.pitch-perfect.no-cast-at-end.suggestion.reason\">\n\t\t\t\tYou might have missed up to <Plural value={missedPPs} one=\"# cast\" other=\"# casts\"/> of {ACTIONS.PITCH_PERFECT.name}.\n\t\t\t</Trans>,\n        }));\n    }\n    output() {\n        const badPPs = this._ppEvents.filter(pp => pp.issue !== NONE);\n        if (badPPs.length === 0) {\n            return;\n        }\n        // Builds a panel for each pp event\n        const panels = badPPs.map(pp => {\n            const panelProperties = {\n                pp: pp,\n                tuples: [],\n            };\n            if (pp.issue === PP_CAST_WIHTOUT_MAX_STACKS) {\n                panelProperties.tuples.push({\n                    issue: <Trans id=\"brd.pitch-perfect.cast-without-max-stacks\">\n\t\t\t\t\t\t<ActionLink {...ACTIONS.PITCH_PERFECT}/> should only be used below 3 stacks when you know there are no more DoT ticks left until the end of <ActionLink {...ACTIONS.THE_WANDERERS_MINUET}/>.\n\t\t\t\t\t</Trans>,\n                    reason: <Trans id=\"brd.pitch-perfect.cast-without-max-stacks.reason\">\n\t\t\t\t\t\t<ActionLink {...ACTIONS.PITCH_PERFECT}/> potency is {this._formatPotency(PP_POTENCY[0])} at the first stack, {this._formatPotency(PP_POTENCY[1])} at the second, and {this._formatPotency(PP_POTENCY[2])} at the third and final stack, so you don't want to use it before the last one.\n\t\t\t\t\t</Trans>,\n                });\n            }\n            else if (pp.issue === PP_NOT_CAST_AT_END) {\n                panelProperties.tuples.push({\n                    issue: <Trans id=\"brd.pitch-perfect.cast-without-stacks\">\n\t\t\t\t\t\tBefore <ActionLink {...ACTIONS.THE_WANDERERS_MINUET}/> ends, you should make sure to use <ActionLink {...ACTIONS.PITCH_PERFECT}/> regardless of the amount of stacks you have.\n\t\t\t\t\t</Trans>,\n                    reason: <Trans id=\"brd.pitch-perfect.cast-without-stacks.reason\">\n\t\t\t\t\t\tAny left over stack is lost when your song ends, so using whatever stacks you have before it ends is always a gain.\n\t\t\t\t\t</Trans>,\n                });\n            }\n            // Then builds the panel and returns it in the mapping function\n            return this._buildPanel(panelProperties);\n        });\n        // Output is an Accordion made with panels, one for each wrong PP event\n        return <>\n\t\t\t{this._lostPotencyFromMissedCast[0] ?\n            <Message attached=\"top\">\n\t\t\t\t\t<Trans id=\"brd.pitch-perfect.estimate-note\">\n\t\t\t\t\t\t<Label color=\"orange\" size=\"tiny\" pointing=\"right\">NOTE:</Label> We do not have access to how many unused stacks you had at the end of {ACTIONS.THE_WANDERERS_MINUET.name}, these are times you might have had some.\n\t\t\t\t\t</Trans>\n\t\t\t\t</Message> : null}\n\t\t\t<Accordion exclusive={false} panels={panels} styled fluid/>\n\t\t\t<Message attached=\"bottom\" info>\n\t\t\t\t<List bulleted>\n\t\t\t\t\t<List.Content>\n\t\t\t\t\t\t{this._lostPotencyFromStacks ?\n            <List.Item>\n\t\t\t\t\t\t\t\t<Trans id=\"brd.pitch-perfect.without-max-stacks.total-potency-lost\">\n\t\t\t\t\t\t\t\t\t<Icon name={'remove'} className={'text-error'}/> Casting without max stacks lost you a total of <strong>{this._formatPotency(this._lostPotencyFromStacks)}</strong> potency\n\t\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t\t</List.Item> : null}\n\t\t\t\t\t\t{this._lostPotencyFromMissedCast[0] ?\n            <List.Item>\n\t\t\t\t\t\t\t\t<Trans id=\"brd.pitch-perfect.no-cast-at-end.total-potency-lost\">\n\t\t\t\t\t\t\t\t\t<Icon name={'question'} className={'text-warning'}/> You might have lost between <strong>{this._formatPotency(this._lostPotencyFromMissedCast[0])} to {this._formatPotency(this._lostPotencyFromMissedCast[1])}</strong> potency from missing casts at the end of <ActionLink {...ACTIONS.THE_WANDERERS_MINUET}/>\n\t\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t\t</List.Item> : null}\n\t\t\t\t\t</List.Content>\n\t\t\t\t</List>\n\t\t\t</Message>\n\t\t</>;\n    }\n    // Builds a panel for each cast of Pitch Perfect and its respectives issues, to be provided to the final Accordion\n    // Each panel has the following components:\n    // - A title, containing:\n    //    - timestamp\n    //    - amount of stacks\n    // - A list of issues, containing:\n    //    - issue description (tuples[].issue)\n    // - A list of reasons, containing:\n    //    - the reason explaining why each issue is... an issue (tuples[].reason)\n    // - A message block, containing:\n    //    - information about critical hit rate and time left on song\n    _buildPanel({ pp, tuples }) {\n        let titleIconName = '';\n        let titleIconClass = '';\n        let titleElement = <></>;\n        let timeLeftElement = <></>;\n        let potencyLostElement = <></>;\n        let timestamp = 0;\n        if (pp.issue === PP_CAST_WIHTOUT_MAX_STACKS) {\n            // Without Max Stacks Title\n            titleElement = <Trans id=\"brd.pitch-perfect.cast-without-max-stacks.title\">\n\t\t\t\t{ACTIONS.PITCH_PERFECT.name} used at <Plural value={pp.stacks} one=\"# stack\" other=\"# stacks\"/>.\n\t\t\t</Trans>;\n            titleIconName = 'remove';\n            titleIconClass = 'text-error';\n            // Witout Max Stacks timestamp for button\n            timestamp = pp.timestamp;\n            // Without Max Stacks Information Elements\n            timeLeftElement = <Trans id=\"brd.pitch-perfect.cast-without-max-stacks.time-left\"><strong>{this.parser.formatDuration(pp.timeLeftOnSong)}</strong> left on <ActionLink {...ACTIONS.THE_WANDERERS_MINUET}/></Trans>;\n            potencyLostElement = <Trans id=\"brd.pitch-perfect.cast-without-max-stacks.potency-lost\"><strong>{this._formatPotency(PP_MAX_POTENCY - PP_POTENCY[pp.stacks - 1])}</strong> potency lost versus casting at max stacks</Trans>;\n        }\n        else if (pp.issue === PP_NOT_CAST_AT_END) {\n            // Not Cast At End Title\n            titleElement = <Trans id=\"brd.pitch-perfect.not-cast-at-end.title\">\n\t\t\t\t{ACTIONS.PITCH_PERFECT.name} might have been usable before the end of {ACTIONS.THE_WANDERERS_MINUET.name}.\n\t\t\t</Trans>;\n            titleIconName = 'question';\n            titleIconClass = 'text-warning';\n            // Witout Max Stacks timestamp for button\n            timestamp = pp.timestamp + pp.timeLeftOnSong;\n            // Not Cast At End Information Elements\n            timeLeftElement = <Trans id=\"brd.pitch-perfect.not-cast-at-end.time-left\"><strong>{this.parser.formatDuration(pp.timeLeftOnSong)}</strong> left on <ActionLink {...ACTIONS.THE_WANDERERS_MINUET}/> after the last cast of <ActionLink {...ACTIONS.PITCH_PERFECT}/></Trans>;\n            potencyLostElement = <Trans id=\"brd.pitch-perfect.not-cast-at-end.potency-lost\"><strong>{this._formatPotency(PP_POTENCY[0])} to {this._formatPotency(PP_MAX_POTENCY)}</strong> potency potentially lost</Trans>;\n        }\n        const issueElements = tuples && tuples.length && tuples.map(t => {\n            return t.issue && <Message key={tuples.indexOf(t)} error={pp.issue === PP_CAST_WIHTOUT_MAX_STACKS} warning={pp.issue === PP_NOT_CAST_AT_END}>\n\t\t\t\t<Icon name={'remove'}/>\n\t\t\t\t<span>{t.issue}</span>\n\t\t\t</Message>;\n        }) || null;\n        // List of reasons\n        const reasonElements = tuples && tuples.length && <div className={styles.description}>\n\t\t\t<List bulleted relaxed>\n\t\t\t\t{tuples.map(t => {\n            return <List.Item key={tuples.indexOf(t)}>{t.reason}</List.Item>;\n        })}\n\t\t\t</List>\n\t\t</div> || null;\n        // Builds the full panel\n        return {\n            key: pp.timestamp,\n            title: {\n                content: <>\n\t\t\t\t\t<Icon name={titleIconName} className={titleIconClass}/> {this._createTimelineButton(timestamp)}\n\t\t\t\t\t{titleElement}\n\t\t\t\t</>,\n            },\n            content: {\n                content: <>\n\t\t\t\t\t{issueElements}\n\t\t\t\t\t{reasonElements}\n\t\t\t\t\t<Message info>\n\t\t\t\t\t\t<List>\n\t\t\t\t\t\t\t<List.Content>\n\t\t\t\t\t\t\t\t<List.Item>\n\t\t\t\t\t\t\t\t\t<Icon name={'hourglass'}/>\n\t\t\t\t\t\t\t\t\t{timeLeftElement}\n\t\t\t\t\t\t\t\t</List.Item>\n\t\t\t\t\t\t\t\t<List.Item>\n\t\t\t\t\t\t\t\t\t<Icon name={'arrow down'}/>\n\t\t\t\t\t\t\t\t\t{potencyLostElement}\n\t\t\t\t\t\t\t\t</List.Item>\n\t\t\t\t\t\t\t</List.Content>\n\t\t\t\t\t\t</List>\n\t\t\t\t\t</Message>\n\t\t\t\t</>,\n            },\n        };\n    }\n    _getEnemy(targetId) {\n        if (!this._enemies[targetId]) {\n            this._enemies[targetId] = {\n                tick: {\n                    [STATUSES.CAUSTIC_BITE.id]: undefined,\n                    [STATUSES.STORMBITE.id]: undefined,\n                },\n                get lastTick() {\n                    return this.tick[STATUSES.CAUSTIC_BITE.id]\n                        && this.tick[STATUSES.CAUSTIC_BITE.id].timestamp\n                        || this.tick[STATUSES.STORMBITE.id]\n                            && this.tick[STATUSES.STORMBITE.id].timestamp;\n                },\n            };\n        }\n        return this._enemies[targetId];\n    }\n    _isAMissedPP(lastPPInWM, missedPPGracePeriod) {\n        return lastPPInWM.timeLeftOnSong > missedPPGracePeriod && !this.downtime.getDowntime(lastPPInWM.timestamp, lastPPInWM.timestamp + missedPPGracePeriod);\n    }\n    _cleanUpPPs() {\n        let lastPP = this._ppEvents[0];\n        let badCastInCurrentWM = false;\n        let stacksUsedInCurrentWM = 0;\n        const stacksUsedInWM = [];\n        const castsInWM = [];\n        let castsInCurrentWM = [];\n        // It's the length of two dot ticks to have a better chance of being right.\n        const missedPPGracePeriod = DOT_TICK_FREQUENCY * 2;\n        // They didn't use their PP\n        if (!this._ppEvents.length) {\n            return;\n        }\n        // TODO: Add in checking for EA use after last PP cast for better accuracy\n        for (const pp of this._ppEvents) {\n            //This means a new Wanderers Minuet was cast since the last one\n            if (pp.timeLeftOnSong > lastPP.timeLeftOnSong) {\n                if (this._isAMissedPP(lastPP, missedPPGracePeriod)) {\n                    this._ppEvents.splice(this._ppEvents.indexOf(pp), 0, {\n                        ...lastPP,\n                        issue: PP_NOT_CAST_AT_END,\n                    });\n                    this._lostPotencyFromMissedCast[0] += PP_POTENCY[0];\n                    this._lostPotencyFromMissedCast[1] += PP_MAX_POTENCY;\n                }\n                // If they don't have a bad cast in this WM window, then we don't care about it\n                // Also, Prevents including a pp cast because of downtime improperly.\n                if (badCastInCurrentWM) {\n                    stacksUsedInWM.push(stacksUsedInCurrentWM);\n                    castsInWM.push(castsInCurrentWM);\n                    badCastInCurrentWM = false;\n                }\n                stacksUsedInCurrentWM = 0;\n                castsInCurrentWM = [];\n            }\n            if (this.downtime.isDowntime(pp.lastTickOnEnemy + DOT_TICK_FREQUENCY + ANIMATION_LOCK)) {\n                this._ppEvents.splice(this._ppEvents.indexOf(pp), 1);\n            }\n            if (pp.issue === PP_CAST_WIHTOUT_MAX_STACKS) {\n                badCastInCurrentWM = true;\n            }\n            stacksUsedInCurrentWM += pp.stacks;\n            castsInCurrentWM.push(pp);\n            lastPP = pp;\n        }\n        if (badCastInCurrentWM) {\n            stacksUsedInWM.push(stacksUsedInCurrentWM);\n            castsInWM.push(castsInCurrentWM);\n        }\n        //To catch if the missed PP was after the last use of PP in the log\n        if (this._isAMissedPP(lastPP, missedPPGracePeriod)) {\n            this._ppEvents.push({\n                ...lastPP,\n                issue: PP_NOT_CAST_AT_END,\n            });\n            this._lostPotencyFromMissedCast[0] += PP_POTENCY[0];\n            this._lostPotencyFromMissedCast[1] += PP_MAX_POTENCY;\n        }\n        //To properly find how much potency was lost due to missed stacks\n        for (const wmIndex in stacksUsedInWM) {\n            const casts = castsInWM[wmIndex];\n            let totalPotencyInWM = 0;\n            for (const cast of casts) {\n                totalPotencyInWM += PP_POTENCY[cast.stacks - 1];\n            }\n            const totalStacks = stacksUsedInWM[wmIndex];\n            const potencyFromMax = Math.floor(totalStacks / PP[3]) * PP_MAX_POTENCY;\n            let potencyFromLast = 0;\n            //Sometimes, you don't get enough stacks for a full pitch perfect, so we include that possiblity in here as well\n            if (totalStacks % PP[3]) {\n                potencyFromLast = PP_POTENCY[totalStacks % PP[3] - 1];\n            }\n            const maxPotencyInWM = potencyFromMax + potencyFromLast;\n            this._lostPotencyFromStacks += maxPotencyInWM - totalPotencyInWM;\n        }\n    }\n    // Allows for proper localization of potency numbers, aka proper thousands separators and things like that.\n    _formatPotency(potency) {\n        return potency.toLocaleString();\n    }\n    _createTimelineButton(timestamp) {\n        return <Button circular compact icon=\"time\" size=\"small\" onClick={() => this.timeline.show(timestamp - this.parser.fight.start_time, timestamp - this.parser.fight.start_time)} content={this.parser.formatTimestamp(timestamp)}/>;\n    }\n}\nPitchPerfect.handle = 'pitchPerfect';\nPitchPerfect.title = t('brd.pitch-perfect.title') `Pitch Perfect`;\nPitchPerfect.dependencies = [\n    'additionalStats',\n    'downtime',\n    'suggestions',\n    'brokenLog',\n    'timeline',\n];\n","/**\n * @author Ririan\n */\nimport React from 'react';\nimport { Trans, Plural, NumberFormat } from '@lingui/react';\nimport { t } from '@lingui/macro';\nimport { List, Button, Label, Icon, Message } from 'semantic-ui-react';\nimport Module from 'parser/core/Module';\nimport { getDataBy } from 'data';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport STATUSES from 'data/STATUSES';\nimport ACTIONS from 'data/ACTIONS';\nimport { ActionLink } from 'components/ui/DbLink';\nimport { matchClosest } from 'utilities';\n// All of Bards DoTs\nconst DOTS = [\n    STATUSES.CAUSTIC_BITE.id,\n    STATUSES.STORMBITE.id,\n    STATUSES.VENOMOUS_BITE.id,\n    STATUSES.WINDBITE.id,\n];\nconst DHIT_MOD = 1.25;\nconst TRAIT_STRENGTH = 0.20;\nconst MAX_SHADOWBITE_POTENCY = ACTIONS.SHADOWBITE.potency[2];\nconst MAX_SIDEWINDER_POTENCY = ACTIONS.SIDEWINDER.potency[2];\nexport default class Sidewinder extends Module {\n    constructor(...args) {\n        super(...args);\n        this._amountOfBadSidewinders = 0;\n        this._amountOfBadShadowbites = 0;\n        this._amountOfSingleTargetShadowbites = 0;\n        //This is used to determine the severity of their mistakes\n        this._notBothDotsPotencyLoss = 0;\n        this._singleTargetShadowbitesPotencyLoss = 0;\n        this._badCasts = [];\n        this._shadowbiteDamageTimestamps = new Map();\n        this.addHook('cast', {\n            by: 'player',\n            abilityId: ACTIONS.SIDEWINDER.id,\n        }, this._onSidewinderCast);\n        this.addHook('complete', this._onComplete);\n        this.addHook('init', () => {\n            this.addHook(this.fflogsEvents.damageEventName, {\n                by: 'player',\n                abilityId: ACTIONS.SHADOWBITE.id,\n            }, this._onShadowbiteDamage);\n        });\n    }\n    _getDotsOnEnemy(enemy) {\n        const dotsApplied = [];\n        if (enemy) {\n            for (const dotId of DOTS) {\n                if (enemy.hasStatus(dotId)) {\n                    dotsApplied.push(dotId);\n                }\n            }\n        }\n        return dotsApplied;\n    }\n    //For some reason, shadowbite's cast target doesn't work properly in dungeon trash pulls so we gotta do it the hard way\n    _onShadowbiteDamage(event) {\n        const potencyDamageRatio = this.additionalStats.potencyDamageRatio;\n        const rawDamage = this._getRawDamage(event);\n        // We get the approximated potency and then match to the closest real potency\n        const approximatedPotency = rawDamage * 100 / potencyDamageRatio;\n        const potency = matchClosest(ACTIONS.SHADOWBITE.potency, approximatedPotency);\n        // We then infer the amount of stacks\n        const dotsApplied = ACTIONS.SHADOWBITE.potency.indexOf(potency);\n        const timestamp = event.timestamp;\n        const shadowbiteTimestampArray = this._shadowbiteDamageTimestamps.get(timestamp);\n        const shadowbiteDamageEvent = {\n            ...event,\n            abilityId: event.ability.guid,\n            isSingleTargetShadowbite: false,\n            hasBothDots: dotsApplied > 1,\n            // Due to varience, a guess can be less then the actual raw damage, so we have to check to make sure they are actually losing damage first\n            missedDamage: dotsApplied < 2 ? (MAX_SHADOWBITE_POTENCY * potencyDamageRatio / 100) : 0,\n            missedPotency: MAX_SHADOWBITE_POTENCY - ACTIONS.SHADOWBITE.potency[dotsApplied],\n            targetsHit: 0,\n            dotsApplied,\n        };\n        this._notBothDotsPotencyLoss += MAX_SHADOWBITE_POTENCY - matchClosest(ACTIONS.SHADOWBITE.potency, rawDamage * 100 / potencyDamageRatio);\n        if (!shadowbiteTimestampArray) {\n            if (!shadowbiteDamageEvent.hasBothDots) {\n                this._amountOfBadShadowbites++;\n                this._badCasts.push(shadowbiteDamageEvent);\n            }\n            this._shadowbiteDamageTimestamps.set(timestamp, [shadowbiteDamageEvent]);\n        }\n        else {\n            shadowbiteTimestampArray.push(shadowbiteDamageEvent);\n        }\n    }\n    _onSidewinderCast(event) {\n        const target = this.enemies.getEntity(event.targetID);\n        const dotsApplied = this._getDotsOnEnemy(target);\n        if (dotsApplied.length < 2) {\n            this._amountOfBadSidewinders++;\n            const potencyDamageRatio = this.additionalStats.potencyDamageRatio;\n            const thisPotency = ACTIONS.SIDEWINDER.potency[dotsApplied.length];\n            this._notBothDotsPotencyLoss += MAX_SIDEWINDER_POTENCY - thisPotency;\n            this._badCasts.push({\n                ...event,\n                abilityId: event.ability.guid,\n                dotsApplied: dotsApplied.length,\n                isSingleTargetShadowbite: false,\n                hasBothDots: false,\n                missedDamage: (MAX_SIDEWINDER_POTENCY * potencyDamageRatio / 100) - (thisPotency * potencyDamageRatio / 100),\n                missedPotency: MAX_SIDEWINDER_POTENCY - thisPotency,\n                targetsHit: 1,\n            });\n        }\n    }\n    _onComplete() {\n        this._amountOfSingleTargetShadowbites = this._addInSingleTargetShadowbites();\n        if (!this._badCasts.length) {\n            return;\n        }\n        const badSidewinders = this._amountOfBadSidewinders;\n        const badShadowbites = this._amountOfBadShadowbites;\n        if (badSidewinders || badShadowbites) {\n            this.suggestions.add(new TieredSuggestion({\n                icon: ACTIONS.SIDEWINDER.icon,\n                content: <Trans id=\"brd.sidewinder.suggestion.not-both-dots\">\n\t\t\tOnly use <ActionLink {...ACTIONS.SIDEWINDER}/> and <ActionLink {...ACTIONS.SHADOWBITE}/> when you have both <ActionLink {...ACTIONS.CAUSTIC_BITE}/> and <ActionLink {...ACTIONS.STORMBITE}/> active on the target. Remember that a DoT doesn't apply as soon as you cast it, so you have to wait for it to apply before casting <ActionLink showIcon={false} {...ACTIONS.SIDEWINDER}/> or <ActionLink showIcon={false} {...ACTIONS.SHADOWBITE}/>.\n\t\t\t\t</Trans>,\n                tiers: {\n                    1110: SEVERITY.MAJOR,\n                    480: SEVERITY.MEDIUM,\n                    160: SEVERITY.MINOR,\n                },\n                value: this._notBothDotsPotencyLoss,\n                why: <Trans id=\"brd.sidewinder.suggestion.not-both-dots.reason\">\n\t\t\t\t\t{this._notBothDotsPotencyLoss} potency lost to casts on targets missing DoTs\n\t\t\t\t</Trans>,\n            }));\n        }\n        if (this._amountOfSingleTargetShadowbites) {\n            this.suggestions.add(new TieredSuggestion({\n                icon: ACTIONS.SIDEWINDER.icon,\n                content: <Trans id=\"brd.sidewinder.suggestion.single-target-shadowbite\">\n\t\t\t\tOnly cast <ActionLink {...ACTIONS.SHADOWBITE}/> when it will hit multiple targets. Otherwise you lose potency compared to casting <ActionLink {...ACTIONS.SIDEWINDER}/> instead.\n\t\t\t\t</Trans>,\n                tiers: {\n                    200: SEVERITY.MAJOR,\n                    100: SEVERITY.MEDIUM,\n                    40: SEVERITY.MINOR,\n                },\n                value: this._singleTargetShadowbitesPotencyLoss,\n                why: <Trans id=\"brd.sidewinder.suggestion.single-target-shadowbite.reason\">\n\t\t\t\t\t{this._singleTargetShadowbitesPotencyLoss} potency lost on single target casts of <ActionLink {...ACTIONS.SHADOWBITE}/>\n\t\t\t\t</Trans>,\n            }));\n        }\n    }\n    _createTimelineButton(timestamp) {\n        return <Button circular compact icon=\"time\" size=\"small\" floated=\"left\" onClick={() => this.timeline.show(timestamp - this.parser.fight.start_time, timestamp - this.parser.fight.start_time)} content={this.parser.formatTimestamp(timestamp)}/>;\n    }\n    output() {\n        if (!this._badCasts.length) {\n            return;\n        }\n        let totalPotencyLost = 0;\n        // Builds a list item for each incorrect cast\n        const items = this._badCasts.map(cast => {\n            totalPotencyLost += cast.missedPotency;\n            return <List.Item key={cast.timestamp}>\n\t\t\t\t{this._createTimelineButton(cast.timestamp)}\n\t\t\t\t<List.Content verticalAlign=\"middle\">\n\t\t\t\t\t{this._createIssueTag(cast)} <Label horizontal size=\"small\" color=\"red\" pointing=\"left\"><Trans id=\"brd.sidewinder.list.missed-potency\"><Icon name=\"arrow down\"/>Lost {this._formatDamageNumber(cast.missedPotency)} potency</Trans></Label>\n\t\t\t\t</List.Content>\n\t\t\t</List.Item>;\n        });\n        // Output is a List, where every item is an incorrect cast\n        return <>\n\t\t\t<List divided relaxed>\n\t\t\t\t{items}\n\t\t\t</List>\n\t\t\t<Message info attached=\"bottom\"><Trans id=\"brd.sidewinder.total-mistakes\"><Plural value={this._badCasts.length} one=\"# mistake\" other=\"# mistakes\"/> lost a total of <strong>{this._formatDamageNumber(totalPotencyLost)}</strong> potency</Trans></Message>\n\t\t</>;\n    }\n    _createIssueTag(cast) {\n        const ability = getDataBy(ACTIONS, 'id', cast.abilityId);\n        let issue = <></>;\n        if (cast.dotsApplied < 2) {\n            if (ability === ACTIONS.SIDEWINDER) {\n                issue = <Trans id=\"brd.sidewinder.list.sidewinder.missing-dots\">\n\t\t\t\t\t<ActionLink {...ability}/> was cast with <Plural value={cast.dotsApplied} one=\"only one DoT\" other=\"no DoTs\"/> applied to the target.\n\t\t\t\t</Trans>;\n            }\n            else {\n                issue = <Trans id=\"brd.sidewinder.list.shadowbite.missing-dots\">\n\t\t\t\t\t<ActionLink {...ability}/> was cast with <Plural value={cast.dotsApplied} one=\"only one DoT\" other=\"no DoTs\"/> applied to the target and <Plural value={cast.targetsHit} one=\"only hit a single enemy\" other=\"hit # enemies\"/>.\n\t\t\t\t</Trans>;\n            }\n        }\n        else if (cast.isSingleTargetShadowbite) {\n            issue = <Trans id=\"brd.sidewinder.list.shadowbite.one-target\">\n\t\t\t\t<ActionLink {...ability}/> only hit a single enemy.\n\t\t\t</Trans>;\n        }\n        return issue;\n    }\n    _formatDamageNumber(damage) {\n        const truncDamage = Math.trunc(damage);\n        return <NumberFormat value={truncDamage}/>;\n    }\n    _getRawDamage(event) {\n        let fixedMultiplier = event.debugMultiplier;\n        // AND ALSO FOR RANGED TRAIT, BECAUSE APPARENTLY IT'S PHYSICAL DAMAGE ONLY REEEEEEEEEE\n        fixedMultiplier = Math.trunc((fixedMultiplier + TRAIT_STRENGTH) * 100) / 100;\n        // We get the unbuffed damage\n        let rawDamage = event.amount / fixedMultiplier;\n        // And then strip off critical hit and direct hit mods\n        if (event.criticalHit) {\n            rawDamage = Math.trunc(rawDamage / this.additionalStats.critMod);\n        }\n        if (event.directHit) {\n            rawDamage = Math.trunc(rawDamage / DHIT_MOD);\n        }\n        return rawDamage;\n    }\n    _addInSingleTargetShadowbites() {\n        let singleTargetAmount = 0;\n        let needsSort = false;\n        this._shadowbiteDamageTimestamps.forEach(eventArray => {\n            const damageEvent = eventArray[0];\n            const dotsApplied = damageEvent.dotsApplied;\n            if (eventArray.length === 1) {\n                singleTargetAmount++;\n                damageEvent.isSingleTargetShadowbite = true;\n                const missedPotency = ACTIONS.SIDEWINDER.potency[dotsApplied] - ACTIONS.SHADOWBITE.potency[dotsApplied];\n                damageEvent.missedDamage += missedPotency * this.additionalStats.potencyDamageRatio / 100;\n                damageEvent.missedPotency += missedPotency;\n                this._singleTargetShadowbitesPotencyLoss += missedPotency;\n                if (damageEvent.hasBothDots) {\n                    needsSort = true;\n                    this._badCasts.push(damageEvent);\n                }\n            }\n            else if (!damageEvent.hasBothDots) {\n                let lostDamage = 0;\n                for (const damageEvent of eventArray) {\n                    lostDamage += damageEvent.missedDamage;\n                }\n                damageEvent.missedDamage = lostDamage;\n                damageEvent.missedPotency *= eventArray.length;\n            }\n            damageEvent.targetsHit = eventArray.length;\n        });\n        if (needsSort) {\n            this._badCasts.sort((cast1, cast2) => {\n                if (cast1.timestamp > cast2.timestamp) {\n                    return 1;\n                }\n                if (cast1.timestamp < cast2.timestamp) {\n                    return -1;\n                }\n                return 0;\n            });\n        }\n        return singleTargetAmount;\n    }\n}\nSidewinder.handle = 'sidewinder';\nSidewinder.title = t('brd.sidewinder.title') `Sidewinders and Shadowbites`;\nSidewinder.dependencies = [\n    'suggestions',\n    'timeline',\n    'enemies',\n    'additionalStats',\n    'fflogsEvents',\n];\n","/**\n * @author Ririan\n */\nimport React from 'react';\nimport { Trans } from '@lingui/react';\nimport { t } from '@lingui/macro';\nimport { Table } from 'semantic-ui-react';\nimport Module from 'parser/core/Module';\nimport { getDataBy } from 'data';\nimport STATUSES from 'data/STATUSES';\nimport ACTIONS from 'data/ACTIONS';\nimport { ActionLink, StatusLink } from 'components/ui/DbLink';\nexport default class Snapshots extends Module {\n    constructor(...args) {\n        super(...args);\n        this._snapshotEvents = [];\n        this.addHook('cast', {\n            by: 'player',\n            abilityId: [ACTIONS.CAUSTIC_BITE.id, ACTIONS.STORMBITE.id, ACTIONS.IRON_JAWS.id],\n        }, event => this._snapshotEvents.push(event));\n    }\n    output() {\n        const snapshotEvents = this._snapshotEvents;\n        if (snapshotEvents.length === 0) {\n            return;\n        }\n        // Builds a row for each snapshot event\n        const rows = snapshotEvents.map(snapshotEvent => {\n            let snapshot = snapshotEvent.snapshot;\n            if (!snapshot) {\n                // I currently have no idea how this happens, this means that AdditonalStats didn't recieve a cast event for it, but it got added in after or something\n                // So we can show they did cast it, I'm going to generate an empty snapshot\n                snapshot = { statuses: [] };\n            }\n            const snapshotCell = <Table.Cell>\n\t\t\t\t{Object.keys(snapshot.statuses).map(id => {\n                //To avoid showing statuses we do not currently know of, as that will cause an infinite loading circle\n                if (snapshot.statuses[id].isActive && getDataBy(STATUSES, 'id', Number(id))) {\n                    //35px is a purely arbitrary value that I think looks nice.  The default icon size for statuses are too small.\n                    return <StatusLink key={id} showName={false} iconSize=\"35px\" {...getDataBy(STATUSES, 'id', Number(id))}/>;\n                }\n            })}\n\t\t\t</Table.Cell>;\n            return <Table.Row key={snapshotEvent.timestamp}>\n\t\t\t\t<Table.Cell>\n\t\t\t\t\t{this.util.createTimelineButton(snapshotEvent.timestamp)}\n\t\t\t\t</Table.Cell>\n\t\t\t\t<Table.Cell>\n\t\t\t\t\t<ActionLink {...getDataBy(ACTIONS, 'id', snapshotEvent.ability.guid)}/>\n\t\t\t\t</Table.Cell>\n\t\t\t\t{snapshotCell}\n\t\t\t</Table.Row>;\n        });\n        // Output is a Table, where every row after the header contains individual snapshots\n        return <Table>\n\t\t\t<Table.Header>\n\t\t\t\t<Table.Row key=\"header\">\n\t\t\t\t\t<Table.HeaderCell><Trans id=\"brd.snapshots.time\">Time</Trans></Table.HeaderCell>\n\t\t\t\t\t<Table.HeaderCell><Trans id=\"brd.snapshots.snapshotter\">Snapshotter</Trans></Table.HeaderCell>\n\t\t\t\t\t<Table.HeaderCell><Trans id=\"brd.snapshots.statuses\">Statuses</Trans></Table.HeaderCell>\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Header>\n\t\t\t<Table.Body>\n\t\t\t\t{rows}\n\t\t\t</Table.Body>\n\t\t</Table>;\n    }\n}\nSnapshots.handle = 'snapshots';\nSnapshots.title = t('brd.snapshots.title') `Snapshots`;\nSnapshots.dependencies = [\n    //AdditionalStats module is needed because it handles adding snapshots to events.\n    'additionalStats',\n    'util',\n];\n","/**\n * @author Yumiya\n */\nimport React, { Fragment } from 'react';\nimport ACTIONS from 'data/ACTIONS';\nimport Module from 'parser/core/Module';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nconst SETUP_TIME = 3200; // Assuming song being used after second GCD (2.50s from first GCD + 0.70s from second GCD animation lock)\nconst SONG_DURATION = 30000;\nconst TIER = {\n    MAJOR: 15,\n    MEDIUM: 10,\n};\nexport default class SongUptime extends Module {\n    constructor(...args) {\n        super(...args);\n        this._songCastEvents = [];\n        this._deathEvents = [];\n        this.addHook('cast', {\n            by: 'player',\n            abilityId: [ACTIONS.THE_WANDERERS_MINUET.id, ACTIONS.MAGES_BALLAD.id, ACTIONS.ARMYS_PAEON.id],\n        }, this._onSongCast);\n        this.addHook('death', {\n            to: 'player',\n        }, this._onDeath);\n        this.addHook('complete', this._onComplete);\n    }\n    _onSongCast(event) {\n        this._songCastEvents.push(event);\n    }\n    _onDeath(event) {\n        this._deathEvents.push(event);\n    }\n    _onComplete() {\n        const songlessTime = this.util.formatDecimal(this._getSonglessTime());\n        const songlessTolerance = this.util.formatDecimal(this._getTolerance());\n        if (songlessTime > songlessTolerance) {\n            this.suggestions.add(new TieredSuggestion({\n                icon: ACTIONS.THE_WANDERERS_MINUET.icon,\n                tiers: {\n                    [songlessTolerance + TIER.MAJOR]: SEVERITY.MAJOR,\n                    [songlessTolerance + TIER.MEDIUM]: SEVERITY.MEDIUM,\n                    0: SEVERITY.MINOR,\n                },\n                value: songlessTime,\n                why: <Fragment>\n\t\t\t\t\tYou were songless for {songlessTime} seconds.\n\t\t\t\t</Fragment>,\n                content: <Fragment>\n\t\t\t\t\tTry not to be songless during uptime. Bard's core mechanics revolve around its songs and the added effects they bring.\n\t\t\t\t</Fragment>,\n            }));\n        }\n    }\n    _getSonglessTime() {\n        let totalSonglessTime = 0;\n        // Iterate through each song cast\n        for (let i = 0; i < this._songCastEvents.length; i++) {\n            // Timestamps for songless period to be determined\n            const songless = { start: 0, end: 0 };\n            // If this is the last song cast in the encounter, caster is songless until the end of encounter, otherwise songless until the next song is cast\n            if (i === this._songCastEvents.length - 1) {\n                songless.end = this.parser.fight.end_time;\n            }\n            else {\n                songless.end = this._songCastEvents[i + 1].timestamp;\n            }\n            // The start of a songless period can't be after the end of said period, so it's the minimum between the end of first song and end of assumed songless period\n            songless.start = Math.min(this._songCastEvents[i].timestamp + SONG_DURATION, songless.end);\n            // If caster died after first song was cast\n            const deathEvent = this._deathEvents.find(d => d.timestamp > this._songCastEvents[i].timestamp);\n            // If death was before the theoretical songless period\n            if (deathEvent ? deathEvent.timestamp < songless.start : false) {\n                // Then death marks the start of the songless period\n                songless.start = deathEvent.timestamp;\n            }\n            // Just in case it's negative, but it shouldn't be given the previous logic\n            const theoreticalSonglessTime = Math.max(songless.end - songless.start, 0);\n            // If there's songless time between two songs, subtracts the amount of time the target was invulnerable during that interval\n            if (theoreticalSonglessTime > 0) {\n                const effectiveSonglessTime = Math.max(theoreticalSonglessTime - this.downtime.getDowntime(songless.start, songless.end), 0);\n                totalSonglessTime += effectiveSonglessTime;\n            }\n        }\n        return totalSonglessTime / 1000;\n    }\n    _getTolerance() {\n        // For each song, if the end of the song fell into a downtime, next song will require a set-up time\n        // This set-up time is added to the tolerance\n        let tolerance = SETUP_TIME;\n        this._songCastEvents.forEach(c => {\n            if (this.downtime.isDowntime(c.timestamp + SONG_DURATION)) {\n                tolerance += SETUP_TIME;\n            }\n        });\n        return tolerance / 1000;\n    }\n}\nSongUptime.handle = 'songuptime';\nSongUptime.dependencies = [\n    'suggestions',\n    'downtime',\n    'util',\n];\n","/**\n * @author Yumiya\n */\nimport React from 'react';\nimport Module from 'parser/core/Module';\nimport { Button } from 'semantic-ui-react';\nexport default class Util extends Module {\n    hasBuff(status) {\n        return this.combatants.selected.hasStatus(status.id);\n    }\n    getDebuffUptime(status) {\n        const statusTime = this.enemies.getStatusUptime(status.id);\n        const uptime = this.parser.fightDuration - this.invuln.getInvulnerableUptime();\n        return (statusTime / uptime) * 100;\n    }\n    getBuffUptime(status) {\n        const statusTime = this.combatants.getStatusUptime(status.id, this.parser.player.id);\n        const uptime = this.parser.fightDuration - this.invuln.getInvulnerableUptime();\n        return (statusTime / uptime) * 100;\n    }\n    getDowntimeLength(timestamp) {\n        const window = this.downtime.getDowntimeWindows().filter(x => x.start <= timestamp && x.end >= timestamp);\n        return Math.max(0, (window.end - window.start) / 1000);\n    }\n    formatDecimal(number, precision = 2) {\n        if (!Number.isInteger(precision) || precision < 0) {\n            precision = 2;\n        }\n        const BASE = 10;\n        return Math.round(number * Math.pow(BASE, precision)) / Math.pow(BASE, precision);\n    }\n    formatDamageLog(event) {\n        if (event && event.type && event.type !== 'damage') {\n            return;\n        }\n        let modifier = '';\n        if (event.multistrike && event.hitType && event.hitType === 2) {\n            modifier = 'Critical direct hit! ';\n        }\n        else if (!event.multistrike && event.hitType && event.hitType === 2) {\n            modifier = 'Critical! ';\n        }\n        else if (event.multistrike && !event.hitType || event.hitType === 1) {\n            modifier = 'Direct hit! ';\n        }\n        return `${modifier}${event.target && event.target.name ? event.target.name : this.enemies.getEntity(event.targetID).name || 'Target'} takes ${event.amount} damage.`;\n    }\n    formatTimestamp(timestamp) {\n        timestamp = Math.max(timestamp, this.parser.fight.start_time);\n        return this.parser.formatTimestamp(timestamp);\n    }\n    milliToSeconds(time, precision) {\n        return this.formatDecimal(time / 1000, precision);\n    }\n    timeSince(timestamp) {\n        return this.parser.currentTimestamp - timestamp;\n    }\n    timeUntilFinish(timestamp) {\n        return this.parser.fight.end_time - timestamp;\n    }\n    createTimelineButton(timestamp) {\n        return <Button circular compact icon=\"time\" size=\"small\" onClick={() => this.timeline.show(timestamp - this.parser.fight.start_time, timestamp - this.parser.fight.start_time)} content={this.parser.formatTimestamp(timestamp)}/>;\n    }\n    formatDamageNumber(damageNumber) {\n        return damageNumber.toLocaleString({ maximumFractionDigits: 2 });\n    }\n}\nUtil.handle = 'util';\nUtil.dependencies = [\n    'combatants',\n    'downtime',\n    'enemies',\n    'invuln',\n    'timeline',\n];\n","/**\n * @author Yumiya\n */\nimport CoreWeaving from 'parser/core/modules/Weaving';\nimport ACTIONS from 'data/ACTIONS';\nimport _ from 'lodash';\nconst SPECIAL_WEAVE = 3;\nconst ALLOWED_WEAVES = [\n    [\n        ACTIONS.BLOODLETTER.id,\n        ACTIONS.EMPYREAL_ARROW.id,\n        ACTIONS.BLOODLETTER.id,\n    ],\n    [\n        ACTIONS.BARRAGE.id,\n        ACTIONS.PITCH_PERFECT.id,\n        ACTIONS.EMPYREAL_ARROW.id,\n    ],\n    [\n        ACTIONS.BARRAGE.id,\n        ACTIONS.EMPYREAL_ARROW.id,\n        ACTIONS.PITCH_PERFECT.id,\n    ],\n    [\n        ACTIONS.PITCH_PERFECT.id,\n        ACTIONS.BARRAGE.id,\n        ACTIONS.EMPYREAL_ARROW.id,\n    ],\n];\nexport default class Weaving extends CoreWeaving {\n    isBadWeave(weave) {\n        if (weave.weaves.length === SPECIAL_WEAVE) {\n            const weaveSequence = weave.weaves.map(w => w.ability.guid);\n            return !ALLOWED_WEAVES.some((weave) => _.isEqual(weave, weaveSequence));\n        }\n        return super.isBadWeave(weave);\n    }\n}\n","import AdditionalStats from './AdditionalStats';\nimport Barrage from './Barrage';\nimport DoTs from './DoTs';\nimport OGCDDowntime from './OGCDDowntime';\nimport PitchPerfect from './PitchPerfect';\nimport Sidewinder from './Sidewinder';\nimport Snapshots from './Snapshots';\nimport SongUptime from './SongUptime';\nimport Util from './Util';\nimport Weaving from './Weaving';\nexport default [\n    AdditionalStats,\n    Barrage,\n    DoTs,\n    OGCDDowntime,\n    PitchPerfect,\n    Sidewinder,\n    Snapshots,\n    SongUptime,\n    Util,\n    Weaving,\n];\n"],"sourceRoot":""}
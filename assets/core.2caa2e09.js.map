{"version":3,"sources":["webpack:///./src/parser/core/modules/Suggestions/Suggestion.js","webpack:///./src/parser/core/modules/Suggestions/Component.js","webpack:///./src/parser/core/modules/Suggestions/Suggestions.js","webpack:///./src/parser/core/modules/Suggestions/index.js","webpack:///./src/parser/core/modules/Checklist/Rule.js","webpack:///./src/parser/core/modules/Checklist/Component.js","webpack:///./src/parser/core/modules/Checklist/Checklist.js","webpack:///./src/parser/core/modules/Checklist/Requirement.js","webpack:///./src/parser/core/modules/Checklist/index.js","webpack:///./src/components/ui/Rotation.tsx","webpack:///./src/components/ui/RotationTable.tsx","webpack:///./src/parser/core/modules/Cooldowns.js","webpack:///./src/parser/core/modules/Combos.tsx","webpack:///./src/parser/core/modules/Weaving.js","webpack:///./src/mathjsCustom.js","webpack:///./src/components/ui/Rotation.module.css?31d9","webpack:///./src/parser/core/modules/Suggestions/Suggestions.module.css?3c09","webpack:///./src/parser/core/modules/GlobalCooldown.js","webpack:///./src/parser/core/modules/Checklist/Checklist.module.css?cfc9","webpack:///./src/parser/core/modules/Statuses.js","webpack:///./src/parser/core/modules/Downtime.js","webpack:///./src/parser/core/modules/About.module.css?7e68","webpack:///./src/parser/core/modules/ChangeLog/ChangeLog.module.css?d7c0","webpack:///./src/components/ui/ContributorLabel.js","webpack:///./src/parser/core/modules/About.js","webpack:///./src/parser/core/modules/AlwaysBeCasting.js","webpack:///./src/parser/core/modules/AoE.js","webpack:///./src/parser/core/modules/BrokenLog.tsx","webpack:///./src/parser/core/modules/ChangeLog/Component.js","webpack:///./src/parser/core/modules/ChangeLog/ChangeLog.js","webpack:///./src/parser/core/modules/Death.js","webpack:///./src/parser/core/modules/HitType.js","webpack:///./src/parser/core/modules/index.js"],"names":["SEVERITY","MORBID","MAJOR","MEDIUM","MINOR","IGNORE","undefined","Suggestion","constructor","options","this","icon","content","why","severity","Object","keys","forEach","key","TieredSuggestion","super","tiers","value","matcher","matchClosestLower","SEVERITY_LABEL_PROPS","id","color","Suggestions","React","Component","arguments","onToggleShowMinor","_","data","settingsStore","context","setShowMinorSuggestions","checked","render","showMinor","showMinorSuggestions","suggestions","props","filter","suggestion","hasMinor","some","Checkbox","toggle","label","defaultChecked","onChange","className","styles","checkbox","items","map","index","item","src","alt","extra","Label","horizontal","length","contextType","StoreContext","__decorate","observer","Module","_suggestions","add","push","console","error","output","sort","a","b","handle","displayOrder","DISPLAY_ORDER","SUGGESTIONS","displayMode","DISPLAY_MODE","FULL","title","TARGET","SUCCESS","WARN","FAIL","DEFAULT_TARGET","Rule","name","description","requirements","target","DEFAULT","percent","percents","requirement","math","mean","TieredRule","RULE_STYLES","text","autoExpand","Checklist","rules","expanded","panels","rule","ruleStyles","tier","Math","min","Icon","toFixed","Progress","progress","size","Accordion","exclusive","defaultActiveIndex","styled","fluid","_rules","sortedRules","CHECKLIST","Requirement","_percent","overrideDisplay","Rotation","events","container","event","action","getDataBy","ACTIONS","ability","guid","autoAttack","linkClassName","link","ogcd","onGcd","iconSize","gcdSize","ogcdSize","Link","ITEM_ID_OFFSET","ItemLink","ActionLink","cn","showName","RotationTable","targets","notes","onGoto","headerTitle","compact","unstackable","celled","Header","Row","HeaderCell","collapsing","i","textAlign","header","note","Body","entry","start","targetAccessorResolver","accessor","targetsData","actual","expected","notesAccessorResolver","notesMap","TargetCell","Cell","positive","negative","end","rotation","style","marginRight","formatDuration","circular","onClick","targetEntry","noteEntry","Cooldowns","_cooldownGroups","_currentAction","_cooldowns","_groups","actions","_buildGroups","cooldownOrder","addHook","by","_onBeginCast","_onCast","_onComplete","groups","order","getAction","_buildGroup","group","merge","nestedGroups","opts","ItemGroup","showNested","timeline","addGroup","cooldown","startCooldown","cooldownGroup","startCooldownGroup","finishingCast","actionId","_addToTimeline","parseInt","cd","current","history","use","shared","addItem","Item","type","timestamp","parser","fight","start_time","getCooldown","originActionId","sharedCooldown","currentFightDuration","currentTimestamp","resetCooldown","invulnTime","reduceCooldown","reduction","setInvulnTime","previousEndTimestamp","previousCooldown","isFirst","downtime","getDowntime","getCooldownRemaining","getTimeOnCooldown","considerInvulnTime","extension","reduce","time","status","getAdjustedTimeOnCooldown","duration","maximumDuration","dependencies","DEFAULT_GCD","GCD_TIMEOUT_MILLIS","ISSUE_TYPENAMES","uncomboed","combobreak","failedcombo","Combos","lastGcdTime","currentComboChain","issues","init","onCast","onComplete","lastComboEvent","issue","fabricateComboEvent","combo","fabricateEvent","recordBrokenCombo","isAllowableComboBreak","recordUncomboedGcd","recordFailedCombo","checkCombo","lastAction","from","Array","isArray","includes","breaksCombo","successfulHit","addJobSpecificSuggestions","comboBreakers","uncomboedGcds","suggestionIcon","1","2","4","startTime","completeContext","startEvent","endEvent","startAction","endAction","reason","whiteSpace","show","COMBOS","dependency","__metadata","Data","prototype","Timeline","DEFAULT_MAX_WEAVES","MAX_WEAVE_TIERS","0","2.5","WEAVING_SEVERITY","5","Weaving","_weaves","_ongoingCastEvent","_leadingGcdEvent","_trailingGcdEvent","_badWeaves","isOgcd","_saveIfBad","badWeaves","href","scrollTo","message","leadingGcdEvent","gcdTimeDiff","invuln","getUntargetableUptime","weave","trailingGcdEvent","weaves","isBadWeave","maxWeaves","weaveCount","isUntargetable","castTime","forEvent","closest","speedmod","get","gcdLength","gcd","getEstimate","formatTimestamp","create","meanDependencies","modeDependencies","stdDependencies","module","exports","MIN_GCD","MAX_GCD","BASE_GCD","CASTER_TAX","DEBUG_LOG_SAVED_GCDS","GlobalCooldown","_castingEvent","_estimatedBaseGcd","_estimateGcdCount","_lastGcd","isInstant","gcds","gcdGroupId","normalise","byPlayer","hasBeginCast","relevantEvent","saveGcd","_debugLogSavedGcds","instant","taxed","casterTaxed","log","normalizedLength","speedMod","Group","_getGcdLength","estimate","statistics","SimpleStatistic","ATTACK","info","gcdInfo","isCasterTaxed","round","correctedCooldown","gcdRecast","normaliseWith","normalizedGcd","bound","lengths","mode","max","getUptime","carry","cooldownRatio","STATUS_APPLY_ON_PARTY_THRESHOLD_MILLISECONDS","Statuses","_statuses","_statusToActionMap","_actionToMergeNameMap","byFilter","player","pets","p","_onApply","_onRefresh","_onRemove","cooldowns","ac","values","statusesApplied","statusKey","statuses","_isStatusAppliedToPet","_addStatus","_endPrevStatus","getStatus","statusEntry","prev","usages","it","abs","_createGroupForStatus","st","stid","statusesStackMapping","attachToGroup","report","friendlyPets","targetID","Downtime","_internalDowntime","downtimePeriods","unableToAct","getDowntimes","getInvulns","finalDowntimes","shift","dt","last","isDowntime","when","uptime","minimumDowntimeLength","aggregator","getDowntimeWindows","minimumWindowSize","ContributorLabel","PureComponent","contributor","detail","jobs","job","backgroundColor","colour","Color","isDark","image","avatar","Detail","About","Description","contributors","supportedPatches","field","meta","Message","warning","Content","to","supported","patchSupported","languageToEdition","lang","parseDate","Grid","Column","mobile","computer","patch","Segment","as","user","role","NormalisedMessage","ABOUT","AlwaysBeCasting","fightDuration","checklist","INTERNAL_EVENT_TYPE","Symbol","DEFAULT_AOE_THRESHOLD","STATUS_AOE_THRESHOLD","SUPPORTED_EVENTS","AoE","_onAoe","fflogsEvents","damageEventName","healEventName","trackers","getTracker","sourceID","source","abilityId","insertAfter","toAdd","addEvent","tracker","eventType","lastHitTimestamp","groupLastHit","AOE_THRESHOLD","sourceId","shouldCleanup","offset","splice","hitsByTarget","isValidHit","bind","targetInstance","times","amount","instance","fabricatedEvent","replace","hits","total","hit","hasOwnProperty","sourceResources","validTarget","enemies","getEntity","zeroAmount","overkill","EXPECTED_ABILITY_EVENTS","BrokenLog","triggers","Map","UNKNOWN","trigger","triggerKey","has","getReportPatch","branch","Sentry","scope","setTags","setExtras","code","set","Table","basic","i18n_id","BROKEN_LOG","RAW","ChangeLog","state","activeIndexes","Set","handleClick","newIndexes","delete","setState","changelog","dateString","date","toLocaleDateString","active","Fragment","Title","change","Changes","CHANGELOG","RAISE_STATUSES","Death","_count","_deadTime","_timestamp","raiseStatuses","_onDeath","_onRaise","checkLb3","shouldCountDeath","addDeathToTimeline","kill","end_time","RAISE","ACTION_EVENT_TYPES","FAILED_HITS","EventHitType","MISS","IMMUNE","HitType","criticalHit","hitType","CRITICAL","directHit","multistrike","AdditionalEvents","CastTime","Combatants","Enemies","FFLogsEventNormaliser","Invulnerability","PrecastAction","PrecastStatus","RaidBuffs","Speedmod","Statistics","UnableToAct"],"mappings":"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","file":"assets/core.2caa2e09.js","sourcesContent":["import { matchClosestLower } from 'utilities';\nexport const SEVERITY = {\n    // NOTE: Don't use MORBID, It's for deaths. I _will_ block the PRs on this.\n    MORBID: 0,\n    MAJOR: 1,\n    MEDIUM: 2,\n    MINOR: 3,\n    // The matchClosest fall back to undefined, so let's use that for ignore too\n    IGNORE: undefined,\n};\nexport default class Suggestion {\n    constructor(options) {\n        this.icon = ''; // TODO: default image\n        this.content = '';\n        this.why = '';\n        this.severity = SEVERITY.MEDIUM;\n        Object.keys(options || {}).forEach(key => {\n            this[key] = options[key];\n        });\n    }\n}\nexport class TieredSuggestion extends Suggestion {\n    constructor(options) {\n        super({\n            tiers: {},\n            value: 0,\n            matcher: matchClosestLower,\n            ...options,\n        });\n    }\n    get severity() {\n        return this.matcher(this.tiers, this.value);\n    }\n    // noop setter so it doesn't die from the base class\n    set severity(value) { }\n}\n","import { __decorate } from \"tslib\";\nimport { Trans } from '@lingui/react';\nimport { observer } from 'mobx-react';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { Checkbox, Label } from 'semantic-ui-react';\n// Direct path import 'cus it'll be a dep loop otherwise\nimport { SEVERITY } from 'parser/core/modules/Suggestions/Suggestion';\nimport { SettingsStore } from 'store/settings';\nimport styles from './Suggestions.module.css';\nimport { StoreContext } from 'store';\nconst SEVERITY_LABEL_PROPS = {\n    [SEVERITY.MORBID]: { content: <Trans id=\"core.suggestions.severity.morbid\">Morbid</Trans>, color: 'black', icon: 'times' },\n    [SEVERITY.MAJOR]: { content: <Trans id=\"core.suggestions.severity.major\">Major</Trans>, color: 'red', icon: 'arrow up' },\n    [SEVERITY.MEDIUM]: { content: <Trans id=\"core.suggestions.severity.medium\">Medium</Trans>, color: 'orange' },\n    [SEVERITY.MINOR]: { content: <Trans id=\"core.suggestions.severity.minor\">Minor</Trans>, color: 'blue', icon: 'arrow down' },\n};\nlet Suggestions = class Suggestions extends React.Component {\n    constructor() {\n        super(...arguments);\n        this.onToggleShowMinor = (_, data) => {\n            const { settingsStore } = this.context;\n            settingsStore.setShowMinorSuggestions(data.checked);\n        };\n    }\n    render() {\n        const showMinor = this.context.settingsStore.showMinorSuggestions;\n        const suggestions = this.props.suggestions.filter(suggestion => showMinor || suggestion.severity !== SEVERITY.MINOR);\n        const hasMinor = this.props.suggestions.some(suggestion => suggestion.severity === SEVERITY.MINOR);\n        return <>\n\t\t\t{hasMinor && <Checkbox toggle label={<label><Trans id=\"core.suggestion.show-minor\">Show minor</Trans></label>} defaultChecked={showMinor} onChange={this.onToggleShowMinor} className={styles.checkbox}/>}\n\t\t\t<div className={styles.items}>\n\t\t\t\t{suggestions.map((suggestion, index) => <div key={index} className={styles.item}>\n\t\t\t\t\t<img src={suggestion.icon} alt=\"\"/>\n\t\t\t\t\t<div>\n\t\t\t\t\t\t{suggestion.content}\n\t\t\t\t\t\t<div className={styles.extra}>\n\t\t\t\t\t\t\t<Label horizontal {...SEVERITY_LABEL_PROPS[suggestion.severity]}/>\n\t\t\t\t\t\t\t{suggestion.why}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>)}\n\t\t\t\t{suggestions.length === 0 && <div className={styles.item}>\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<strong><Trans id=\"core.suggestion.nothing\">There's nothing here!</Trans></strong><br />\n\t\t\t\t\t\t{hasMinor && <Trans id=\"core.suggestion.nothing-but-minor\">You can check over the minor suggestions by flicking the \"Show minor\" switch in the top right.</Trans>}\n\t\t\t\t\t</div>\n\t\t\t\t</div>}\n\t\t\t</div>\n\t\t</>;\n    }\n};\nSuggestions.propTypes = {\n    settingsStore: PropTypes.instanceOf(SettingsStore),\n    suggestions: PropTypes.arrayOf(PropTypes.shape({\n        icon: PropTypes.string.isRequired,\n        content: PropTypes.node.isRequired,\n        why: PropTypes.node.isRequired,\n        severity: PropTypes.number.isRequired,\n    })).isRequired,\n};\nSuggestions.contextType = StoreContext;\nSuggestions = __decorate([\n    observer\n], Suggestions);\nexport default Suggestions;\n","import { t } from '@lingui/macro';\nimport React from 'react';\nimport Suggestion, { SEVERITY } from './Suggestion';\nimport SuggestionsComponent from './Component';\nimport Module, { DISPLAY_MODE } from 'parser/core/Module';\nimport DISPLAY_ORDER from '../DISPLAY_ORDER';\nexport default class Suggestions extends Module {\n    constructor() {\n        super(...arguments);\n        this._suggestions = [];\n    }\n    add(suggestion) {\n        if (!(suggestion instanceof Suggestion)) {\n            console.error('TODO: Proper error message for passing a non-suggestion to the suggestion add handler');\n            return;\n        }\n        this._suggestions.push(suggestion);\n    }\n    output() {\n        // Only show the suggestions module if it's had things sent to it\n        if (this._suggestions.length === 0) {\n            return false;\n        }\n        // Sort suggestions with most important at the top, and remove ignored\n        const suggestions = this._suggestions\n            .filter(suggestion => suggestion.severity !== SEVERITY.IGNORE)\n            .sort((a, b) => a.severity - b.severity);\n        // Rendering is in a specialised component so it's got some state to work with\n        return <SuggestionsComponent suggestions={suggestions}/>;\n    }\n}\nSuggestions.handle = 'suggestions';\nSuggestions.displayOrder = DISPLAY_ORDER.SUGGESTIONS;\nSuggestions.displayMode = DISPLAY_MODE.FULL;\nSuggestions.title = t('core.suggestions.title') `Suggestions`;\n","export { default } from './Suggestions';\nexport { default as Suggestion } from './Suggestion';\nexport * from './Suggestion';\n","import math from 'mathjsCustom';\nimport { matchClosestLower } from 'utilities';\nimport { DISPLAY_ORDER } from 'parser/core/Module';\nexport const TARGET = {\n    SUCCESS: 2,\n    WARN: 1,\n    FAIL: undefined,\n};\nconst DEFAULT_TARGET = 95;\nexport default class Rule {\n    constructor(options) {\n        this.name = '';\n        this.description = null;\n        this.requirements = [];\n        this.target = DEFAULT_TARGET;\n        this.displayOrder = DISPLAY_ORDER.DEFAULT;\n        Object.keys(options || {}).forEach(key => {\n            this[key] = options[key];\n        });\n    }\n    get tier() {\n        return matchClosestLower({ [this.target]: TARGET.SUCCESS }, this.percent);\n    }\n    get percent() {\n        // WoWA has a bunch of different modes for this stuff, I'm just going to use mean for now. Because I'm mean. Hue.\n        // TODO: different requirement modes\n        const percents = this.requirements.map(requirement => requirement.percent);\n        return percents.length ? math.mean(percents) : 0;\n    }\n}\nexport class TieredRule extends Rule {\n    constructor(options) {\n        super({\n            tiers: {},\n            matcher: matchClosestLower,\n            ...options,\n        });\n    }\n    get tier() {\n        return this.matcher(this.tiers, this.percent);\n    }\n}\n","import PropTypes from 'prop-types';\nimport React, { Component } from 'react';\nimport { Accordion, Icon, Progress } from 'semantic-ui-react';\nimport { TARGET } from 'parser/core/modules/Checklist/Rule';\nimport styles from './Checklist.module.css';\nconst RULE_STYLES = {\n    [TARGET.SUCCESS]: { text: 'text-success', color: 'green', icon: 'checkmark', autoExpand: false },\n    [TARGET.WARN]: { text: 'text-warning', color: 'yellow', icon: 'warning sign', autoExpand: true },\n    [TARGET.FAIL]: { text: 'text-error', color: 'red', icon: 'remove', autoExpand: true },\n};\nclass Checklist extends Component {\n    render() {\n        const { rules } = this.props;\n        // If there's no rules, just stop now\n        if (!rules.length) {\n            return false;\n        }\n        const expanded = [];\n        const panels = rules.map((rule, index) => {\n            const ruleStyles = RULE_STYLES[rule.tier];\n            // We cap the percent @ 100 in production mode - calculations can always be a bit janky\n            let percent = rule.percent;\n            if (process.env.NODE_ENV === 'production') {\n                percent = Math.min(percent, 100);\n            }\n            if (ruleStyles.autoExpand) {\n                expanded.push(index);\n            }\n            return {\n                // This should be a handle of some sort\n                key: index,\n                title: {\n                    className: styles.title,\n                    content: <>\n\t\t\t\t\t\t<Icon name={ruleStyles.icon} className={ruleStyles.text}/>\n\t\t\t\t\t\t{rule.name}\n\t\t\t\t\t\t<div className={styles.percent + ' ' + ruleStyles.text}>\n\t\t\t\t\t\t\t{percent.toFixed(1)}%\n\t\t\t\t\t\t\t<Progress percent={percent} className={styles.progress} size=\"small\" color={ruleStyles.color}/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</>,\n                },\n                content: {\n                    content: <>\n\t\t\t\t\t\t{rule.description && <div className={styles.description}>\n\t\t\t\t\t\t\t<Icon name=\"info\" size=\"large\"/>\n\t\t\t\t\t\t\t<p>{rule.description}</p>\n\t\t\t\t\t\t</div>}\n\t\t\t\t\t\t\n\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t\t{rule.requirements.map((requirement, index) => <li key={index}>\n\t\t\t\t\t\t\t\t\t{requirement.name}: {requirement.content}\n\t\t\t\t\t\t\t\t</li>)}\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t</>,\n                },\n            };\n        });\n        return <Accordion exclusive={false} panels={panels} defaultActiveIndex={expanded} styled fluid/>;\n    }\n}\nChecklist.propTypes = {\n    rules: PropTypes.arrayOf(PropTypes.shape({\n        percent: PropTypes.number.isRequired,\n        tier: PropTypes.oneOf(Object.values(TARGET)),\n        name: PropTypes.node.isRequired,\n        requirements: PropTypes.arrayOf(PropTypes.shape({\n            name: PropTypes.node.isRequired,\n            content: PropTypes.string.isRequired,\n        })),\n    })),\n};\nexport default (Checklist);\n","import { t } from '@lingui/macro';\nimport React from 'react';\nimport Rule from './Rule';\nimport ChecklistComponent from './Component';\nimport Module, { DISPLAY_MODE } from 'parser/core/Module';\nimport DISPLAY_ORDER from '../DISPLAY_ORDER';\nexport default class Checklist extends Module {\n    constructor() {\n        super(...arguments);\n        this._rules = [];\n    }\n    add(rule) {\n        if (!(rule instanceof Rule)) {\n            console.error('TODO: This error message');\n            return;\n        }\n        this._rules.push(rule);\n    }\n    output() {\n        const sortedRules = [...this._rules];\n        sortedRules.sort((a, b) => a.displayOrder - b.displayOrder);\n        return <ChecklistComponent rules={sortedRules}/>;\n    }\n}\nChecklist.handle = 'checklist';\nChecklist.title = t('core.checklist.title') `Checklist`;\nChecklist.displayOrder = DISPLAY_ORDER.CHECKLIST;\nChecklist.displayMode = DISPLAY_MODE.FULL;\n","export default class Requirement {\n    constructor(options) {\n        this.name = '';\n        this._percent = null;\n        this.value = null;\n        this.target = 100;\n        this.overrideDisplay = null;\n        Object.keys(options || {}).forEach(key => {\n            this[key] = options[key];\n        });\n    }\n    get content() {\n        if (this.overrideDisplay !== null) {\n            return this.overrideDisplay;\n        }\n        if (this._percent !== null || this.value === null) {\n            return `${this.percent.toFixed(2)}%`;\n        }\n        return `${this.value.toFixed(0)}/${this.target.toFixed(0)}`; //avoid weird floating point shit\n    }\n    get percent() {\n        if (this._percent === null) {\n            if (this.value === null) {\n                return 0;\n            }\n            return 100 * (((typeof this.value === 'function') ? this.value() : this.value) || 0) / this.target;\n        }\n        return ((typeof this._percent === 'function') ? this._percent() : this._percent) || 0;\n    }\n    set percent(value) {\n        this._percent = value;\n    }\n}\n","export { default } from './Checklist';\nexport { default as Rule, TieredRule, TARGET } from './Rule';\nexport { default as Requirement } from './Requirement';\n","import cn from 'classnames';\nimport { ActionLink, ItemLink } from 'components/ui/DbLink';\nimport { getDataBy } from 'data';\nimport ACTIONS, { ITEM_ID_OFFSET } from 'data/ACTIONS';\nimport PropTypes from 'prop-types';\nimport React, { Component } from 'react';\nimport styles from './Rotation.module.css';\nexport default class Rotation extends Component {\n    render() {\n        const { events } = this.props;\n        return <div className={styles.container}>\n\t\t\t{events.map((event, index) => {\n            const action = getDataBy(ACTIONS, 'id', event.ability.guid);\n            // Don't bother showing the icon for autos\n            if (!action || action.autoAttack) {\n                return;\n            }\n            // Stuff like the duty action doesn't have an icon mapping yet.\n            // TODO: Sort this out if it's a problem\n            if (!action.icon) {\n                console.error(event, 'event ability has no icon');\n                return false;\n            }\n            const linkClassName = [\n                styles.link,\n                { [styles.ogcd]: !action.onGcd },\n            ];\n            const iconSize = action.onGcd ? styles.gcdSize : styles.ogcdSize;\n            const isItem = action.id >= ITEM_ID_OFFSET;\n            const Link = isItem ? ItemLink : ActionLink;\n            return <div key={index} className={cn(...linkClassName)}>\n\t\t\t\t\t<Link showName={false} iconSize={iconSize} {...action}/>\n\t\t\t\t</div>;\n        })}\n\t\t</div>;\n    }\n}\nRotation.propTypes = {\n    events: PropTypes.arrayOf(PropTypes.shape({\n        ability: PropTypes.shape({\n            guid: PropTypes.number.isRequired,\n        }).isRequired,\n    })).isRequired,\n};\n","import { Trans } from '@lingui/react';\nimport Rotation from 'components/ui/Rotation';\nimport React from 'react';\nimport { Button, Table } from 'semantic-ui-react';\nimport { formatDuration } from 'utilities';\nexport class RotationTable extends React.Component {\n    render() {\n        const { targets, notes, data, onGoto, headerTitle, } = this.props;\n        return <Table compact unstackable celled>\n\t\t\t<Table.Header>\n\t\t\t\t<Table.Row>\n\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t<strong><Trans id=\"core.ui.rotation-table.header.time\">Time</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(targets || []).map((target, i) => <Table.HeaderCell key={`target_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{target.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t\t<Table.HeaderCell>\n\t\t\t\t\t\t<strong>{(headerTitle) ? headerTitle : <Trans id=\"core.ui.rotation-table.header.rotation\">Rotation</Trans>}</strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(notes || []).map((note, i) => <Table.HeaderCell key={`note_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{note.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Header>\n\t\t\t<Table.Body>\n\t\t\t\t{data.map((entry) => <RotationTable.Row key={entry.start} onGoto={onGoto} targets={targets || []} notes={notes || []} {...entry}/>)}\n\t\t\t</Table.Body>\n\t\t</Table>;\n    }\n}\nRotationTable.targetAccessorResolver = (entry, target) => {\n    if (typeof target.accessor === 'string' && entry.targetsData != null) {\n        return entry.targetsData[target.accessor];\n    }\n    else if (typeof target.accessor === 'function') {\n        return target.accessor(entry);\n    }\n    else {\n        return {\n            actual: 0,\n            expected: 0,\n        };\n    }\n};\nRotationTable.notesAccessorResolver = (entry, note) => {\n    if (typeof note.accessor === 'string' && entry.notesMap != null) {\n        return entry.notesMap[note.accessor];\n    }\n    else if (typeof note.accessor === 'function') {\n        return note.accessor(entry);\n    }\n    else {\n        return null;\n    }\n};\nRotationTable.TargetCell = ({ actual, expected }) => <Table.Cell textAlign=\"center\" positive={expected === undefined ? false : actual >= expected} negative={expected === undefined ? false : actual < expected}>\n\t\t\t{actual}/{expected === undefined ? '-' : expected}\n\t\t</Table.Cell>;\nRotationTable.Row = ({ onGoto, targets, notes, notesMap, start, end, targetsData, rotation }) => <Table.Row>\n\t\t\t<Table.Cell textAlign=\"center\">\n\t\t\t\t<span style={{ marginRight: 5 }}>{formatDuration(start / 1000)}</span>\n\t\t\t\t{typeof onGoto === 'function' && <Button circular compact size=\"mini\" icon=\"time\" onClick={() => onGoto(start, end)}/>}\n\t\t\t</Table.Cell>\n\t\t\t{targets\n    .map(target => RotationTable.targetAccessorResolver({ start, end, targetsData, rotation }, target))\n    .map((targetEntry, i) => <RotationTable.TargetCell key={`target_${i}`} {...targetEntry}/>)}\n\t\t\t<Table.Cell>\n\t\t\t\t<Rotation events={rotation}/>\n\t\t\t</Table.Cell>\n\t\t\t{notes\n    .map(note => RotationTable.notesAccessorResolver({ start, end, targetsData, notesMap, rotation }, note))\n    .map((noteEntry, i) => <Table.Cell key={`notes_${i}`} textAlign=\"center\">\n\t\t\t\t\t\t\t{noteEntry}\n\t\t\t\t\t\t</Table.Cell>)}\n\t\t</Table.Row>;\n","import _ from 'lodash';\nimport Module from 'parser/core/Module';\nimport { ItemGroup, Item } from './Timeline';\nimport React from 'react';\n// Track the cooldowns on actions and shit\nexport default class Cooldowns extends Module {\n    constructor(...args) {\n        super(...args);\n        this._cooldownGroups = {};\n        this._currentAction = null;\n        this._cooldowns = {};\n        this._groups = {};\n        this._cooldownGroups = _.groupBy(this.data.actions, 'cooldownGroup');\n        // Pre-build groups for actions explicitly set by subclasses\n        this._buildGroups(this.constructor.cooldownOrder);\n        this.addHook('begincast', { by: 'player' }, this._onBeginCast);\n        this.addHook('cast', { by: 'player' }, this._onCast);\n        this.addHook('complete', this._onComplete);\n    }\n    _buildGroups(groups) {\n        // If there's no groups, noop\n        if (!groups) {\n            return;\n        }\n        const ids = groups.map((data, i) => {\n            const order = -(groups.length - i);\n            // If it's just an action id, build a group for it and stop\n            if (typeof data === 'number') {\n                const action = this.data.getAction(data);\n                this._buildGroup({\n                    id: data,\n                    content: action && action.name,\n                    order,\n                });\n                return data;\n            }\n            // Build the base group\n            const group = this._buildGroup({\n                id: data.name,\n                content: data.name,\n                order,\n            });\n            if (data.merge) {\n                // If it's a merge group, we only need to register our group for each of the IDs\n                data.actions.forEach(id => {\n                    this._groups[id] = group;\n                });\n            }\n            else {\n                // Otherwise, build nested groups for each action\n                group.nestedGroups = this._buildGroups(data.actions);\n            }\n            return data.name;\n        });\n        return ids;\n    }\n    _buildGroup(opts) {\n        const group = new ItemGroup({ showNested: false, ...opts });\n        this.timeline.addGroup(group);\n        this._groups[opts.id] = group;\n        return group;\n    }\n    // cooldown starts at the beginning of the casttime\n    // (though 99% of CD based abilities have no cast time)\n    // TODO: Should I be tracking pet CDs too? I mean, contagion/radiant are a thing.\n    _onBeginCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.cooldown == null) {\n            return;\n        }\n        this._currentAction = action;\n        this.startCooldown(action.id);\n        if (!_.isNil(action.cooldownGroup)) {\n            this.startCooldownGroup(action.id, action.cooldownGroup);\n        }\n    }\n    _onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.cooldown == null) {\n            return;\n        }\n        const finishingCast = this._currentAction && this._currentAction.id === action.id;\n        this._currentAction = null;\n        if (finishingCast) {\n            return;\n        }\n        this.startCooldown(action.id);\n        if (!_.isNil(action.cooldownGroup)) {\n            this.startCooldownGroup(action.id, action.cooldownGroup);\n        }\n    }\n    _onComplete() {\n        Object.keys(this._cooldowns).forEach(actionId => {\n            this._addToTimeline(parseInt(actionId, 10));\n        });\n    }\n    _addToTimeline(actionId) {\n        const cd = this._cooldowns[actionId];\n        if (!cd) {\n            return false;\n        }\n        // Clean out any 'current' cooldowns into the history\n        if (cd.current) {\n            cd.history.push(cd.current);\n            cd.current = null;\n        }\n        const action = this.data.getAction(actionId);\n        // If the action is on the GCD, GlobalCooldown will be managing its own group\n        if (!action || action.onGcd) {\n            return false;\n        }\n        // Ensure we've got a group for this item\n        if (!this._groups[actionId]) {\n            this._buildGroup({\n                id: actionId,\n                content: action.name,\n                order: actionId,\n            });\n        }\n        // Add CD info to the timeline\n        cd.history\n            .forEach(use => {\n            if (!use.shared) {\n                this._groups[actionId].addItem(new Item({\n                    type: 'background',\n                    start: use.timestamp - this.parser.fight.start_time,\n                    length: use.length,\n                    content: <img src={action.icon} alt={action.name}/>,\n                }));\n            }\n        });\n        return true;\n    }\n    getCooldown(actionId) {\n        return this._cooldowns[actionId] || {\n            current: null,\n            history: [],\n        };\n    }\n    startCooldownGroup(originActionId, cooldownGroup) {\n        const sharedCooldownActions = _.get(this._cooldownGroups, cooldownGroup, []);\n        sharedCooldownActions\n            .map(action => action.id)\n            .filter(id => id !== originActionId)\n            .forEach(id => this.startCooldown(id, true));\n    }\n    startCooldown(actionId, sharedCooldown = false) {\n        // TODO: handle shared CDs\n        const action = this.data.getAction(actionId);\n        if (!action) {\n            return;\n        }\n        // Get the current cooldown status, falling back to a new cooldown\n        const cd = this.getCooldown(actionId);\n        // If there's a current object, move it into the history\n        // TODO: handle errors on CD overlap\n        if (cd.current) {\n            const currentFightDuration = this.parser.currentTimestamp - this.parser.fight.start_time;\n            if (cd.current.timestamp < this.parser.fight.start_time && cd.current.length > currentFightDuration) {\n                // Pre-pull usage, reset the cooldown to prevent overlap on timeline since we don't know exactly when cooldown was used pre-pull\n                this.resetCooldown(actionId);\n            }\n            else {\n                cd.history.push(cd.current);\n            }\n        }\n        cd.current = {\n            timestamp: this.parser.currentTimestamp,\n            length: action.cooldown * 1000,\n            shared: sharedCooldown,\n            invulnTime: 0,\n        };\n        // Save the info back out (to ensure propagation if we've got a new info)\n        this._cooldowns[actionId] = cd;\n    }\n    reduceCooldown(actionId, reduction) {\n        const cd = this.getCooldown(actionId);\n        const currentTimestamp = this.parser.currentTimestamp;\n        // Check if current isn't current\n        if (cd.current && cd.current.timestamp + cd.current.length < currentTimestamp) {\n            cd.history.push(cd.current);\n            cd.current = null;\n        }\n        // TODO: Do I need to warn if they're reducing cooldown on something _with_ no cooldown?\n        if (cd.current === null) {\n            return;\n        }\n        // Reduce the CD\n        cd.current.length -= reduction * 1000;\n        // If the reduction would have made it come off CD earlier than now, reset it - the extra time reduction should be lost.\n        if (cd.current.timestamp + cd.current.length < currentTimestamp) {\n            this.resetCooldown(actionId);\n        }\n    }\n    setInvulnTime(actionId) {\n        const cd = this.getCooldown(actionId);\n        let previousEndTimestamp = this.parser.fight.start_time;\n        let previousCooldown = {};\n        let isFirst = true;\n        for (const cooldown of cd.history) {\n            if (isFirst) {\n                previousEndTimestamp = (cooldown.timestamp + cooldown.length);\n                isFirst = false;\n                previousCooldown = cooldown;\n            }\n            //We invuln time is the time the boss was invuln from when the CD came off CD and when it was next executed\n            previousCooldown.invulnTime = this.downtime.getDowntime(previousEndTimestamp, cooldown.timestamp);\n            previousEndTimestamp = (cooldown.timestamp + cooldown.length);\n            previousCooldown = cooldown;\n        }\n    }\n    resetCooldown(actionId) {\n        const cd = this.getCooldown(actionId);\n        // If there's nothing running, we can just stop\n        // TODO: need to warn?\n        if (cd.current === null) {\n            return;\n        }\n        // Fix up the length\n        cd.current.length = this.parser.currentTimestamp - cd.current.timestamp;\n        // Move the CD into the history\n        cd.history.push(cd.current);\n        cd.current = null;\n    }\n    getCooldownRemaining(actionId) {\n        const current = this.getCooldown(actionId).current;\n        if (!current) {\n            return 0;\n        }\n        return current.length - (this.parser.currentTimestamp - current.timestamp);\n    }\n    // TODO: Should this be here?\n    getTimeOnCooldown(actionId, considerInvulnTime = false, extension = 0) {\n        const cd = this.getCooldown(actionId);\n        const currentTimestamp = this.parser.currentTimestamp;\n        if (considerInvulnTime) {\n            this.setInvulnTime(actionId);\n        }\n        else {\n            cd.history.map(cooldown => {\n                cooldown.invulnTime = 0;\n            });\n        }\n        return cd.history.reduce((time, status) => time + this.getAdjustedTimeOnCooldown(status, currentTimestamp, extension), cd.current ? this.getAdjustedTimeOnCooldown(cd.current, currentTimestamp, extension) : 0);\n    }\n    getAdjustedTimeOnCooldown(cooldown, currentTimestamp, extension) {\n        // Doesn't count time on CD outside the bounds of the current fight, it'll throw calcs off\n        // Add to the length of the cooldown any invuln time for the boss\n        // Additionally account for any extension the caller allowed to the CD Length\n        const duration = currentTimestamp - cooldown.timestamp;\n        const maximumDuration = cooldown.length + cooldown.invulnTime + extension;\n        return _.clamp(duration, 0, maximumDuration);\n    }\n    get used() {\n        return Object.keys(this._cooldowns);\n    }\n}\nCooldowns.handle = 'cooldowns';\nCooldowns.dependencies = [\n    'data',\n    'downtime',\n    'timeline',\n];\n// Array used to sort cooldowns in the timeline. Elements should be either IDs for\n// top-level groups, or objects of the format {name: string, actions: array} for\n// nested groups. Actions not specified here will be sorted by their ID below.\n// Check the NIN and SMN modules for examples.\nCooldowns.cooldownOrder = [];\n","// If you can make it through this entire file without hitting semantic saturation of the word \"combo\", hats off to you. IT DOESN'T LOOK REAL ANYMORE.\nimport { __decorate, __metadata } from \"tslib\";\nimport { t } from '@lingui/macro';\nimport { Plural, Trans } from '@lingui/react';\nimport { RotationTable } from 'components/ui/RotationTable';\nimport _ from 'lodash';\nimport Module, { dependency } from 'parser/core/Module';\nimport DISPLAY_ORDER from 'parser/core/modules/DISPLAY_ORDER';\nimport Suggestions, { SEVERITY, TieredSuggestion } from 'parser/core/modules/Suggestions';\nimport Timeline from 'parser/core/modules/Timeline';\nimport React from 'react';\nimport { Data } from './Data';\nconst DEFAULT_GCD = 2.5;\nconst GCD_TIMEOUT_MILLIS = 15000;\nconst ISSUE_TYPENAMES = {\n    uncomboed: <Trans id=\"core.combos.issuetypenames.uncomboed\">Uncomboed</Trans>,\n    combobreak: <Trans id=\"core.combos.issuetypenames.combobreak\">Broken Combo</Trans>,\n    failedcombo: <Trans id=\"core.combos.issuetypenames.failed\">Missed or Invulnerable</Trans>,\n};\nexport default class Combos extends Module {\n    constructor() {\n        super(...arguments);\n        this.lastGcdTime = this.parser.fight.start_time;\n        this.currentComboChain = [];\n        this.issues = [];\n    }\n    init() {\n        this.addHook('aoedamage', { by: 'player' }, this.onCast);\n        this.addHook('complete', this.onComplete);\n    }\n    get lastComboEvent() {\n        return _.last(this.currentComboChain) || null;\n    }\n    get lastAction() {\n        const lastComboEvent = this.lastComboEvent;\n        if (!lastComboEvent) {\n            return null;\n        }\n        return lastComboEvent.ability.guid;\n    }\n    get comboBreakers() {\n        return this.issues\n            .filter(issue => issue.type === 'combobreak')\n            .map(issue => issue.event);\n    }\n    get uncomboedGcds() {\n        return this.issues\n            .filter(issue => issue.type === 'uncomboed')\n            .map(issue => issue.event);\n    }\n    fabricateComboEvent(event) {\n        const combo = {\n            ...event,\n            type: 'combo',\n        };\n        delete combo.timestamp; // Since fabricateEvent adds that in anyway\n        this.parser.fabricateEvent(combo);\n    }\n    recordBrokenCombo(event, context) {\n        if (!this.isAllowableComboBreak(event, context)) {\n            this.issues.push({\n                type: 'combobreak',\n                event,\n                context,\n            });\n        }\n        this.currentComboChain = [];\n    }\n    recordUncomboedGcd(event) {\n        this.issues.push({\n            type: 'uncomboed',\n            event,\n            context: [],\n        });\n        this.currentComboChain = [];\n    }\n    recordFailedCombo(event, context) {\n        this.issues.push({\n            type: 'failedcombo',\n            event,\n            context,\n        });\n        this.currentComboChain = [];\n    }\n    /**\n     *\n     * @param combo\n     * @param event\n     * @return true if combo, false otherwise\n     */\n    checkCombo(combo /* Should be an Action type */, event) {\n        // Not in a combo\n        if (this.lastAction == null) {\n            // Combo starter, we good\n            if (combo.start) {\n                this.fabricateComboEvent(event);\n                return true;\n            }\n            // Combo action that isn't a starter, that's a paddlin'\n            if (combo.from) {\n                this.recordUncomboedGcd(event);\n                return false;\n            }\n        }\n        if (combo.start) {\n            // Broken combo - starting a new combo while in a current combo\n            this.recordBrokenCombo(event, this.currentComboChain);\n            return true; // Start a new combo\n        }\n        // Check if action continues existing combo\n        if (combo.from) {\n            const fromOptions = Array.isArray(combo.from) ? combo.from : [combo.from];\n            if (fromOptions.includes(this.lastAction)) {\n                // Combo continued correctly\n                this.fabricateComboEvent(event);\n                // If it's a finisher, reset the combo\n                return !combo.end;\n            }\n        }\n        // Action did not continue combo correctly and is not a new combo starter\n        this.recordBrokenCombo(event, this.currentComboChain);\n        return false;\n    }\n    onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action) {\n            return;\n        }\n        // Only track GCDs that either progress or break combos so actions like Drill and Shadow Fang don't falsely extend the simulated combo timer\n        if (action.onGcd && (action.combo || action.breaksCombo)) {\n            if (event.timestamp - this.lastGcdTime > GCD_TIMEOUT_MILLIS) {\n                // If we've had enough downtime between GCDs to let the combo expire, reset the state so we don't count erroneous combo breaks\n                this.currentComboChain = [];\n            }\n            this.lastGcdTime = event.timestamp;\n        }\n        // If it's a combo action, run it through the combo checking logic\n        if (action.combo) {\n            if (!event.successfulHit) {\n                // Failed attacks break combo\n                this.recordFailedCombo(event, this.currentComboChain);\n                return;\n            }\n            const continueCombo = this.checkCombo(action.combo, event);\n            if (continueCombo) {\n                this.currentComboChain.push(event);\n            }\n            else {\n                this.currentComboChain = [];\n            }\n        }\n        if (action.breaksCombo && this.lastAction !== null) {\n            // Combo breaking action, that's a paddlin'\n            this.recordBrokenCombo(event, this.currentComboChain);\n        }\n    }\n    onComplete() {\n        if (this.addJobSpecificSuggestions(this.comboBreakers, this.uncomboedGcds)) {\n            return;\n        }\n        this.suggestions.add(new TieredSuggestion({\n            icon: this.constructor.suggestionIcon,\n            content: <Trans id=\"core.combos.content\">\n\t\t\t\t<p>Avoid breaking combos, as failing to complete combos costs you a significant amount of DPS and important secondary effects.</p>\n\t\t\t\t<p>Using a combo GCD at the wrong combo step, using non-combo GCDs while inside a combo, missing, or attacking a target that is invulnerable will cause your combo to break.</p>\n\t\t\t</Trans>,\n            tiers: {\n                1: SEVERITY.MINOR,\n                2: SEVERITY.MEDIUM,\n                4: SEVERITY.MAJOR,\n            },\n            value: this.issues.length,\n            why: <Plural id=\"core.combos.why\" value={this.issues.length} one=\"You misused # combo action.\" other=\"You misused # combo actions.\"/>,\n        }));\n    }\n    /**\n     * To be overridden by subclasses. This is called in _onComplete() and passed two arrays of event objects - one for events that\n     * broke combos, and one for combo GCDs used outside of combos. Subclassing modules can add job-specific suggestions based on\n     * what particular actions were misused and when in the fight.\n     * The overriding module should return true if the default suggestion is not wanted\n     */\n    addJobSpecificSuggestions(comboBreakers, uncomboedGcds) {\n        return false;\n    }\n    /**\n     * To be overridden by subclasses. This is called in recordBrokenCombo, and receives the event triggering the broken combo,\n     * and the context information for that break. Jobs can override this to indicate whether this broken combo is allowed. If so,\n     * the event and context will not be recorded, and the current combo will be cleared with no other side effects.\n     * Returning false will allow the break to be recorded, and displayed to the user\n     */\n    isAllowableComboBreak(event, context) {\n        return false;\n    }\n    output() {\n        if (this.issues.length <= 0) {\n            return false;\n        }\n        // Access Alias\n        const startTime = this.parser.fight.start_time;\n        const data = this.issues\n            .sort((a, b) => a.event.timestamp - b.event.timestamp)\n            .map(issue => {\n            const completeContext = [...(issue.context || []), issue.event];\n            const startEvent = _.first(completeContext);\n            const endEvent = _.last(completeContext);\n            const startAction = this.data.getAction(startEvent.ability.guid);\n            const endAction = this.data.getAction(endEvent.ability.guid);\n            return ({\n                start: startEvent.timestamp - startTime + (startAction?.cooldown ?? DEFAULT_GCD),\n                end: endEvent.timestamp - startTime + (endAction?.cooldown ?? DEFAULT_GCD),\n                rotation: completeContext,\n                notesMap: {\n                    reason: <span style={{ whiteSpace: 'nowrap' }}>{ISSUE_TYPENAMES[issue.type]}</span>,\n                },\n            });\n        });\n        return <RotationTable notes={[\n            {\n                header: <Trans id=\"core.combos.rotationtable.header.reason\">Reason</Trans>,\n                accessor: 'reason',\n            },\n        ]} data={data} onGoto={this.timeline.show}/>;\n    }\n}\nCombos.handle = 'combos';\nCombos.title = t('core.combos.title') `Combo Issues`;\nCombos.displayOrder = DISPLAY_ORDER.COMBOS;\n// This should be redefined by subclassing modules; the default is the basic 'Attack' icon\nCombos.suggestionIcon = 'https://xivapi.com/i/000000/000405.png';\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Data)\n], Combos.prototype, \"data\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Suggestions)\n], Combos.prototype, \"suggestions\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Timeline)\n], Combos.prototype, \"timeline\", void 0);\n","import { t } from '@lingui/macro';\nimport { Trans, Plural } from '@lingui/react';\nimport React from 'react';\nimport { Accordion } from 'semantic-ui-react';\nimport Rotation from 'components/ui/Rotation';\nimport NormalisedMessage from 'components/ui/NormalisedMessage';\nimport Module from 'parser/core/Module';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport { matchClosestLower } from 'utilities';\n// BRD weaves, ninjustsu, etc. should be handled by subclasses w/ isBadWeave overrides\nconst DEFAULT_MAX_WEAVES = 2; // Default castTime is 0\nconst MAX_WEAVE_TIERS = {\n    0: 2,\n    1: 1,\n    2.5: 0,\n};\nconst WEAVING_SEVERITY = {\n    1: SEVERITY.MEDIUM,\n    5: SEVERITY.MAJOR,\n};\nexport default class Weaving extends Module {\n    constructor(...args) {\n        super(...args);\n        this._weaves = [];\n        this._ongoingCastEvent = null;\n        this._leadingGcdEvent = null;\n        this._trailingGcdEvent = null;\n        this._badWeaves = [];\n        this.addHook('begincast', { by: 'player' }, this._onBeginCast);\n        this.addHook('cast', { by: 'player' }, this._onCast);\n        this.addHook('complete', this._onComplete);\n    }\n    _onBeginCast(event) {\n        this._ongoingCastEvent = event;\n    }\n    _onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        // If the action is an auto, just ignore it\n        if (!action || action.autoAttack) {\n            return;\n        }\n        // If it's not a GCD, just bump the weave count\n        if (this.isOgcd(action)) {\n            this._weaves.push(event);\n            return;\n        }\n        if (this._ongoingCastEvent && this._ongoingCastEvent.ability.guid === action.id) {\n            // This event is the end of a GCD cast\n            this._trailingGcdEvent = {\n                ...event,\n                // Override the timestamp of the GCD with when its cast began\n                timestamp: this._ongoingCastEvent.timestamp,\n            };\n        }\n        else {\n            // This event was an instant GCD (or log missed the cast starting)\n            this._trailingGcdEvent = event;\n        }\n        // Always reset the ongoing cast\n        this._ongoingCastEvent = null;\n        // Throw the current state onto the history\n        this._saveIfBad();\n        // Reset\n        this._leadingGcdEvent = this._trailingGcdEvent;\n        this._weaves = [];\n    }\n    _onComplete() {\n        // If there's been at least one gcd, run a cleanup on any remnant data\n        if (this._leadingGcdEvent) {\n            this._saveIfBad();\n        }\n        // Few triples is medium, any more is major\n        const badWeaves = this._badWeaves;\n        this.suggestions.add(new TieredSuggestion({\n            // WVR Focused synth lmao\n            icon: 'https://xivapi.com/i/001000/001785.png',\n            content: <Trans id=\"core.weaving.content\">\n\t\t\t\tAvoid weaving more actions than you have time for in a single GCD window. Doing so will delay your next GCD, reducing possible uptime. Check the <a href=\"javascript:void(0);\" onClick={() => this.parser.scrollTo(this.constructor.handle)}><NormalisedMessage message={this.constructor.title}/></a> module below for more detailed analysis.\n\t\t\t</Trans>,\n            why: <Plural id=\"core.weaving.why\" value={badWeaves.length} _1=\"# instance of incorrect weaving\" other=\"# instances of incorrect weaving\"/>,\n            tiers: WEAVING_SEVERITY,\n            value: badWeaves.length,\n        }));\n    }\n    _saveIfBad() {\n        const leadingGcdEvent = this._leadingGcdEvent || { timestamp: this.parser.fight.start_time };\n        const gcdTimeDiff = this._trailingGcdEvent.timestamp -\n            leadingGcdEvent.timestamp -\n            this.invuln.getUntargetableUptime('all', leadingGcdEvent.timestamp, this._trailingGcdEvent.timestamp);\n        const weave = {\n            leadingGcdEvent,\n            trailingGcdEvent: this._trailingGcdEvent,\n            gcdTimeDiff,\n            weaves: this._weaves,\n        };\n        if (weave.weaves.length === 0) {\n            return;\n        }\n        if (this.isBadWeave(weave)) {\n            this._badWeaves.push(weave);\n        }\n    }\n    isOgcd(action) {\n        return !action.onGcd\n            && !action.autoAttack;\n    }\n    // Basic weave check. For job-specific weave concerns, subclass Weaving and override this method. Make sure it's included under the same module key to override the base implementation.\n    isBadWeave(weave, maxWeaves) {\n        // Calc. the no. of weaves - we're ignoring any made while the boss is untargetable\n        const weaveCount = weave.weaves.filter(event => !this.invuln.isUntargetable('all', event.timestamp)).length;\n        // Just using maxWeaves to allow potential subclasses to utilise standard functionality with custom max\n        if (!maxWeaves) {\n            // If there's no leading ability, it's the first GCD. Allow the 'default' cast time's amount\n            if (!weave.leadingGcdEvent.ability) {\n                maxWeaves = DEFAULT_MAX_WEAVES;\n            }\n            else {\n                const castTime = this.castTime.forEvent(weave.leadingGcdEvent);\n                const closest = matchClosestLower(MAX_WEAVE_TIERS, castTime);\n                maxWeaves = closest !== undefined ? closest : DEFAULT_MAX_WEAVES;\n            }\n        }\n        // It's possible that they did a bunch of weaves during downtime or similar - that's fine.\n        const speedmod = this.speedmod.get(this.parser.timestamp);\n        const gcdLength = this.gcd.getEstimate() * speedmod;\n        return weave.gcdTimeDiff > gcdLength && weaveCount > maxWeaves;\n    }\n    output() {\n        const badWeaves = this._badWeaves;\n        if (badWeaves.length === 0) {\n            return false;\n        }\n        const panels = badWeaves.map(item => ({\n            key: item.leadingGcdEvent.timestamp,\n            title: {\n                content: <>\n\t\t\t\t\t<strong>{this.parser.formatTimestamp(item.leadingGcdEvent.timestamp)}</strong>\n\t\t\t\t\t&nbsp;-&nbsp;\n\t\t\t\t\t<Plural id=\"core.weaving.panel-count\" value={item.weaves.length} _1=\"# weave\" other=\"# weaves\"/>\n\t\t\t\t\t&nbsp;(\n\t\t\t\t\t{this.parser.formatDuration(item.gcdTimeDiff)}\n\t\t\t\t\t&nbsp;\n\t\t\t\t\t<Trans id=\"core.weaving.between-gcds\">between GCDs</Trans>\n\t\t\t\t\t)\n\t\t\t\t</>,\n            },\n            content: {\n                content: <Rotation events={[\n                    ...(item.leadingGcdEvent.ability ? [item.leadingGcdEvent] : []),\n                    ...item.weaves,\n                ]}/>,\n            },\n        }));\n        return <Accordion exclusive={false} panels={panels} styled fluid/>;\n    }\n}\nWeaving.handle = 'weaving';\nWeaving.dependencies = [\n    'castTime',\n    'data',\n    'gcd',\n    'invuln',\n    'speedmod',\n    'suggestions',\n];\nWeaving.title = t('core.weaving.title') `Weaving Issues`;\n","import { create, meanDependencies, modeDependencies, stdDependencies, } from 'mathjs/number';\nexport default create({\n    meanDependencies,\n    modeDependencies,\n    stdDependencies,\n});\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"gcdSize\":\"40px\",\"ogcdSize\":\"30px\",\"container\":\"Rotation-module_container__32KS2\",\"link\":\"Rotation-module_link__2T3fu\",\"ogcd\":\"Rotation-module_ogcd__3oBO8\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"gutter\":\"20px\",\"checkbox\":\"Suggestions-module_checkbox__1Z22N\",\"items\":\"Suggestions-module_items__3sCkP\",\"item\":\"Suggestions-module_item__1yy1-\",\"extra\":\"Suggestions-module_extra__3WN2d\"};","import { t } from '@lingui/macro';\nimport { Trans } from '@lingui/react';\nimport math from 'mathjsCustom';\nimport React from 'react';\nimport Module from 'parser/core/Module';\nimport { Group, Item } from './Timeline';\nimport { SimpleStatistic } from './Statistics';\nconst MIN_GCD = 1500;\nconst MAX_GCD = 2500;\nconst BASE_GCD = 2500;\nconst CASTER_TAX = 100;\nconst DEBUG_LOG_SAVED_GCDS = false && process.env.NODE_ENV !== 'production';\n// NOTE: Caster tax refers to spells taking 0.1s longer than their tooltip claims if their cast time is at least as long as their recast time.\n// See https://www.reddit.com/r/ffxiv/comments/8s05rn/the_recast_time_on_your_tooltip_can_be_up_to_85/, specifically:\n//    There is also another issue that influences how long recast times actually take that isn’t as heavily influenced by fps but is still affected,\n//    which is animation delay that happen between casts, this means that if you have a spell with a cast time that is equal to or\n//    greater than the recast time you will end up taking longer between casts than the (re)cast time. The delay is around 100 ms at 100+ fps\nexport default class GlobalCooldown extends Module {\n    constructor(...args) {\n        super(...args);\n        this._castingEvent = null;\n        this._estimatedBaseGcd = null;\n        this._estimateGcdCount = -1;\n        this._lastGcd = {\n            isInstant: false,\n            event: null,\n        };\n        this.gcds = [];\n        this.gcdGroupId = 'gcd';\n        this.addHook('complete', this._onComplete);\n    }\n    // Using normalise so the estimate can be used throughout the parse\n    normalise(events) {\n        for (let i = 0; i < events.length; i++) {\n            const event = events[i];\n            // Only care about player GCDs\n            if (!this.parser.byPlayer(event) || !event.ability) {\n                continue;\n            }\n            const action = this.data.getAction(event.ability.guid);\n            if (!action || !action.onGcd) {\n                continue;\n            }\n            // eslint-disable-next-line default-case\n            switch (event.type) {\n                // wowa uses beginchannel for this...? need info for flamethrower/that ast skill/passage of arms\n                case 'begincast':\n                    // Can I check for cancels?\n                    this._castingEvent = event;\n                    break;\n                case 'cast':\n                    const hasBeginCast = this._castingEvent !== null && this._castingEvent.ability.guid === action.id;\n                    const relevantEvent = hasBeginCast ? this._castingEvent : event;\n                    this.saveGcd({ ...this._lastGcd }, relevantEvent.timestamp); // Save last gcd with current timestamp\n                    this._lastGcd.isInstant = !hasBeginCast;\n                    this._lastGcd.event = relevantEvent;\n                    this._castingEvent = null;\n                    break;\n            }\n        }\n        if (events.length) {\n            this.saveGcd({ ...this._lastGcd }, events[events.length - 1].timestamp);\n        }\n        this._debugLogSavedGcds();\n        return events;\n    }\n    _debugLogSavedGcds() {\n        if (!DEBUG_LOG_SAVED_GCDS) {\n            return;\n        }\n        // NOTE: Please sanity-check results when changing normalise or saveGcd. Good test cases include:\n        // - Attributing 1.5s and 2.2s to correct RDM melee gcds\n        // - Sub-0.5s speedmod for BLM fast-casts and correct Instant/CasterTaxed flagging\n        // - Correct timestamp for last event before long gaps (ie: Kefka normal)\n        this.gcds.forEach((gcd) => {\n            const timestamp = this.parser.formatTimestamp(gcd.timestamp);\n            const action = this.data.getAction(gcd.actionId);\n            const instant = gcd.isInstant ? ' Instant' : '';\n            const taxed = gcd.casterTaxed ? ' CasterTaxed' : '';\n            console.log(`${timestamp} ${action.name}[${gcd.length}|${gcd.normalizedLength}] Speedmod[${gcd.speedMod}]${instant}${taxed}`);\n        });\n    }\n    _onComplete() {\n        const startTime = this.parser.fight.start_time;\n        // Timeline output\n        // TODO: Look into adding items to groups? Maybe?\n        this.timeline.addGroup(new Group({\n            id: this.gcdGroupId,\n            content: 'GCD',\n            order: -99,\n        }));\n        this.gcds.forEach(gcd => {\n            const action = this.data.getAction(gcd.actionId);\n            if (!action) {\n                return;\n            }\n            this.timeline.addItem(new Item({\n                type: 'background',\n                start: gcd.timestamp - startTime,\n                length: this._getGcdLength(gcd),\n                title: action.name,\n                group: this.gcdGroupId,\n                content: <img src={action.icon} alt={action.name} title={action.name}/>,\n            }));\n        });\n        // Statistic box\n        const estimate = this.getEstimate(false);\n        this.statistics.add(new SimpleStatistic({\n            title: <Trans id=\"core.gcd.estimated-gcd\">Estimated GCD</Trans>,\n            icon: this.data.actions.ATTACK.icon,\n            value: this.parser.formatDuration(estimate),\n            info: (<Trans id=\"core.gcd.no-statistics\">\n\t\t\t\t\tUnfortunately, player statistics are not available from FF Logs. As such, the calculated GCD length is an <em>estimate</em>, and may well be incorrect. If it is reporting a GCD length <em>longer</em> than reality, you likely need to focus on keeping your GCD rolling.\n\t\t\t\t</Trans>),\n        }));\n    }\n    //saveGcd(event, isInstant) {\n    saveGcd(gcdInfo, timestamp) {\n        if (!gcdInfo.event) {\n            return;\n        }\n        const action = this.data.getAction(gcdInfo.event.ability.guid);\n        if (!action || !action.id) {\n            return;\n        }\n        let speedMod = this.speedmod.get(gcdInfo.event.timestamp);\n        let castTime = action.castTime;\n        // HACK NOTE TODO: Need to properly account for abilities that alter only the cast or recast of attacks.\n        // Thinking of moving this into a module like speedmod, that can be called with a timestamp to grab modified base castTime/cooldown values\n        const HACK_ASTRAL_UMBRAL_SPEED_SCALAR = 0.5;\n        if (speedMod <= HACK_ASTRAL_UMBRAL_SPEED_SCALAR) {\n            speedMod /= HACK_ASTRAL_UMBRAL_SPEED_SCALAR;\n            castTime *= HACK_ASTRAL_UMBRAL_SPEED_SCALAR;\n        }\n        let isCasterTaxed = false;\n        // GCD is only to two decimal places, so round it there. Storing in Ms.\n        // eslint-disable-next-line no-magic-numbers\n        let gcdLength = Math.round((timestamp - gcdInfo.event.timestamp) / 10) * 10;\n        if (!gcdInfo.isInstant && castTime >= action.cooldown) {\n            gcdLength -= CASTER_TAX;\n            isCasterTaxed = true;\n        }\n        const correctedCooldown = action.gcdRecast != null\n            ? action.gcdRecast\n            : action.cooldown;\n        const normaliseWith = gcdInfo.isInstant || castTime < correctedCooldown\n            ? correctedCooldown\n            : castTime;\n        const normalizedGcd = Math.round(gcdLength\n            * ((BASE_GCD / 1000) / normaliseWith)\n            * (1 / speedMod));\n        this.gcds.push({\n            timestamp: gcdInfo.event.timestamp,\n            length: gcdLength,\n            normalizedLength: normalizedGcd,\n            speedMod,\n            castTime,\n            cooldown: correctedCooldown,\n            casterTaxed: isCasterTaxed,\n            actionId: action.id,\n            isInstant: gcdInfo.isInstant,\n        });\n    }\n    getEstimate(bound = true) {\n        const gcdLength = this.gcds.length;\n        // If we don't have cache, need to recaculate it\n        if (this._estimatedBaseGcd === null || gcdLength !== this._estimateGcdCount) {\n            // Calculate the lengths of the GCD\n            const lengths = this.gcds.map(gcd => gcd.normalizedLength);\n            // Mode seems to get best results. Using mean in case there's multiple modes.\n            this._estimatedBaseGcd = lengths.length ? math.mean(math.mode(lengths)) : MAX_GCD;\n            this._estimateGcdCount = gcdLength;\n        }\n        // Bound the result if requested\n        if (bound) {\n            this._estimatedBaseGcd = Math.max(MIN_GCD, Math.min(MAX_GCD, this._estimatedBaseGcd));\n        }\n        return this._estimatedBaseGcd;\n    }\n    getUptime() {\n        return this.gcds.reduce((carry, gcd) => {\n            const duration = this._getGcdLength(gcd);\n            const downtime = this.downtime.getDowntime(gcd.timestamp, gcd.timestamp + duration);\n            return carry + duration - downtime;\n        }, 0);\n    }\n    _getGcdLength(gcd) {\n        let cooldown = (gcd.isInstant || gcd.castTime <= gcd.cooldown)\n            ? gcd.cooldown\n            : Math.max(gcd.castTime, gcd.cooldown);\n        cooldown *= 1000;\n        // Some actions are lower than or equal to min gcd, only adjust with ratios when they are not\n        if (cooldown > MIN_GCD) {\n            const cooldownRatio = this.getEstimate() / MAX_GCD;\n            cooldown = Math.max(MIN_GCD, cooldown * cooldownRatio * gcd.speedMod);\n        }\n        const duration = Math.round(cooldown + (gcd.casterTaxed ? CASTER_TAX : 0));\n        return duration;\n    }\n}\nGlobalCooldown.handle = 'gcd';\nGlobalCooldown.dependencies = [\n    // We need this to normalise before us\n    'precastAction',\n    'castTime',\n    'data',\n    'downtime',\n    'speedmod',\n    'statistics',\n    'timeline',\n];\nGlobalCooldown.title = t('core.gcd.title') `Global Cooldown`;\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"lg\":\"(min-width: 992px)\",\"title\":\"Checklist-module_title__2ro7x\",\"percent\":\"Checklist-module_percent__EKBdj\",\"progress\":\"Checklist-module_progress__28lgp\",\"description\":\"Checklist-module_description__3Bf5O\"};","import Module from 'parser/core/Module';\nimport { ItemGroup, Item } from './Timeline';\nimport React from 'react';\nconst STATUS_APPLY_ON_PARTY_THRESHOLD_MILLISECONDS = 2 * 1000;\n// Track statuses applied by actions\nexport default class Statuses extends Module {\n    constructor(...args) {\n        super(...args);\n        this._statuses = {};\n        this._groups = {};\n        this._statusToActionMap = {};\n        this._actionToMergeNameMap = {};\n        const ids = [this.parser.player.id, ...this.parser.player.pets.map(p => p.id)];\n        const byFilter = { by: ids };\n        this.addHook('complete', this._onComplete);\n        this.addHook(['applybuff', 'applydebuff'], byFilter, this._onApply);\n        this.addHook(['refreshdebuff', 'refreshbuff'], byFilter, this._onRefresh);\n        this.addHook(['removebuff', 'removedebuff'], byFilter, this._onRemove);\n        this.cooldowns.constructor.cooldownOrder.forEach(cd => {\n            if (cd && typeof cd === 'object' && cd.merge) {\n                cd.actions.forEach(ac => {\n                    this._actionToMergeNameMap[ac] = cd.name;\n                });\n            }\n        });\n        // Map statuses to actions\n        Object.values(this.data.actions).forEach(action => {\n            if (!action.statusesApplied) {\n                return;\n            }\n            action.statusesApplied.forEach(statusKey => {\n                const status = this.data.statuses[statusKey];\n                this._statusToActionMap[status.id] = action;\n            });\n        });\n    }\n    _onApply(event) {\n        if (this._isStatusAppliedToPet(event)) {\n            return;\n        }\n        this._addStatus(event);\n    }\n    _onRefresh(event) {\n        if (this._isStatusAppliedToPet(event)) {\n            return;\n        }\n        this._endPrevStatus(event);\n        this._addStatus(event);\n    }\n    _onRemove(event) {\n        if (this._isStatusAppliedToPet(event)) {\n            return;\n        }\n        this._endPrevStatus(event);\n    }\n    _endPrevStatus(event) {\n        const status = this.data.getStatus(event.ability.guid);\n        if (!status) {\n            return;\n        }\n        const statusEntry = this._statuses[status.id];\n        if (statusEntry) {\n            const prev = statusEntry.usages[statusEntry.usages.length - 1];\n            if (!prev.end) {\n                prev.end = event.timestamp - this.parser.fight.start_time;\n            }\n        }\n    }\n    _addStatus(event) {\n        const status = this.data.getStatus(event.ability.guid);\n        if (!status) {\n            return;\n        }\n        let statusEntry = this._statuses[status.id];\n        if (!statusEntry) {\n            statusEntry = this._statuses[status.id] = {\n                status: status,\n                usages: [],\n            };\n        }\n        if (statusEntry.usages.some(it => {\n            const diff = Math.abs(event.timestamp - this.parser.fight.start_time - it.start);\n            return diff <= STATUS_APPLY_ON_PARTY_THRESHOLD_MILLISECONDS;\n        })) {\n            return;\n        }\n        statusEntry.usages.push({\n            start: event.timestamp - this.parser.fight.start_time,\n        });\n    }\n    _onComplete() {\n        Object.values(this._statuses).forEach(entry => {\n            const group = this._createGroupForStatus(entry.status);\n            if (!group) {\n                return;\n            }\n            entry.usages.forEach(st => {\n                group.addItem(new Item({\n                    type: 'background',\n                    start: st.start,\n                    end: st.end || st.start + entry.status.duration * 1000,\n                    content: <img src={entry.status.icon} alt={entry.status.name}/>,\n                }));\n            });\n        });\n    }\n    _createGroupForStatus(status) {\n        const stid = 'status-' + (this.constructor.statusesStackMapping[status.id] || status.id);\n        if (this._groups[stid]) {\n            return this._groups[stid];\n        }\n        // find action for status\n        const action = this._statusToActionMap[status.id];\n        if (!action) {\n            return undefined;\n        }\n        const group = new ItemGroup({\n            id: stid,\n            content: status.name,\n            showNested: false,\n        });\n        this._groups[stid] = group;\n        this.timeline.attachToGroup(action.onGcd ? this.gcd.gcdGroupId : (this._actionToMergeNameMap[action.id] || action.id), group);\n        return group;\n    }\n    _isStatusAppliedToPet(event) {\n        return (this.parser.report.friendlyPets.some(p => p.id === event.targetID));\n    }\n}\nStatuses.handle = 'statuses';\nStatuses.dependencies = [\n    'data',\n    'timeline',\n    'cooldowns',\n    'gcd',\n];\nStatuses.statusesStackMapping = {};\n","import Module from 'parser/core/Module';\nexport default class Downtime extends Module {\n    _internalDowntime(start = 0, end = this.parser.currentTimestamp) {\n        // Get all the downtime from both unableToAct and invuln, and sort it\n        const downtimePeriods = [\n            ...this.unableToAct.getDowntimes(start, end),\n            ...this.invuln.getInvulns('all', start, end, 'untargetable'),\n        ].sort((a, b) => a.start - b.start);\n        // If there's nothing, just stop now\n        if (!downtimePeriods.length) {\n            return [];\n        }\n        // Merge the downtimes that overlap\n        const finalDowntimes = [downtimePeriods.shift()];\n        downtimePeriods.forEach(dt => {\n            const last = finalDowntimes[finalDowntimes.length - 1];\n            if (dt.start <= last.end) {\n                if (dt.end > last.end) {\n                    last.end = dt.end;\n                }\n            }\n            else {\n                finalDowntimes.push(dt);\n            }\n        });\n        return finalDowntimes;\n    }\n    isDowntime(when = this.parser.currentTimestamp) {\n        return this._internalDowntime(when, when).length > 0;\n    }\n    getDowntime(start = 0, end = this.parser.currentTimestamp) {\n        // Return the final number\n        return this._internalDowntime(start, end).reduce((uptime, invuln) => uptime + Math.min(invuln.end, end) - Math.max(invuln.start, start), 0);\n    }\n    getDowntimes(start = 0, end = this.parser.currentTimestamp, minimumDowntimeLength = -1) {\n        return this._internalDowntime(start, end).reduce((aggregator, invuln) => {\n            if (Math.min(invuln.end, end) - Math.max(invuln.start, start) > Math.min(minimumDowntimeLength, 0)) {\n                aggregator.push(Math.min(invuln.end, end) - Math.max(invuln.start, start));\n            }\n            return aggregator;\n        }, []);\n    }\n    getDowntimeWindows(start = 0, end = this.parser.currentTimestamp, minimumWindowSize = -1) {\n        return this._internalDowntime(start, end).reduce((aggregator, invuln) => {\n            if (Math.min(invuln.end, end) - Math.max(invuln.start, start) > Math.min(minimumWindowSize, 0)) {\n                aggregator.push({ start: Math.max(invuln.start, start), end: Math.min(invuln.end, end) });\n            }\n            return aggregator;\n        }, []);\n    }\n}\nDowntime.handle = 'downtime';\nDowntime.dependencies = [\n    'invuln',\n    'unableToAct',\n];\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"meta\":\"About-module_meta__bVZ7F\",\"contributor\":\"About-module_contributor__2ELgI\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"change\":\"ChangeLog-module_change__4IR3G\",\"date\":\"ChangeLog-module_date__3MEFU\",\"message\":\"ChangeLog-module_message__3Ns1X\",\"contributors\":\"ChangeLog-module_contributors__1tGd5\"};","import Color from 'color';\nimport PropTypes from 'prop-types';\nimport React, { PureComponent } from 'react';\nimport { Label } from 'semantic-ui-react';\nexport default class ContributorLabel extends PureComponent {\n    render() {\n        const { contributor, detail } = this.props;\n        const name = typeof contributor === 'string' ? contributor : contributor.name;\n        const style = {};\n        if (contributor.jobs && contributor.jobs.length) {\n            // I'm assuming the first job they list is their 'main'\n            const job = contributor.jobs[0];\n            style.backgroundColor = job.colour;\n            const colour = Color(job.colour);\n            if (colour.isDark()) {\n                style.color = 'white';\n            }\n        }\n        return <Label image style={style}>\n\t\t\t{contributor.avatar && <img src={contributor.avatar} alt={name}/>}\n\t\t\t{name}\n\t\t\t{detail && <Label.Detail>{detail}</Label.Detail>}\n\t\t</Label>;\n    }\n}\nContributorLabel.propTypes = {\n    contributor: PropTypes.oneOfType([\n        PropTypes.string,\n        PropTypes.shape({\n            name: PropTypes.string.isRequired,\n            avatar: PropTypes.string,\n        }),\n    ]).isRequired,\n    detail: PropTypes.node,\n};\n","import { t } from '@lingui/macro';\nimport { Trans } from '@lingui/react';\nimport React from 'react';\nimport { Grid, Message, Icon, Segment } from 'semantic-ui-react';\nimport ContributorLabel from 'components/ui/ContributorLabel';\nimport NormalisedMessage from 'components/ui/NormalisedMessage';\nimport { patchSupported, languageToEdition } from 'data/PATCHES';\nimport Module, { DISPLAY_MODE } from 'parser/core/Module';\nimport DISPLAY_ORDER from './DISPLAY_ORDER';\nimport styles from './About.module.css';\nexport default class About extends Module {\n    constructor(...args) {\n        super(...args);\n        this.Description = null;\n        this.contributors = [];\n        this.supportedPatches = null;\n        // Merge the parser's metadata in\n        const fields = ['Description', 'contributors', 'supportedPatches'];\n        fields.forEach(field => {\n            this[field] = this.parser.meta[field];\n        });\n    }\n    // {\n    //\t\tfrom: ...,\n    //\t\tto: ...,\n    // }\n    set supportedPatch(value) {\n        // Warn the dev that they're using a deprecated prop\n        if (process.env.NODE_ENV === 'development') {\n            console.warn('About.suportedPatch has been deprecated. Please use the About.supportedPatches object instead.');\n        }\n        this.supportedPatches.from = value;\n    }\n    output() {\n        // If they've not set the supported patch range, we're assuming it's not supported at all\n        if (!this.supportedPatches) {\n            return <Message warning icon>\n\t\t\t\t<Icon name=\"warning sign\"/>\n\t\t\t\t<Message.Content>\n\t\t\t\t\t<Message.Header>\n\t\t\t\t\t\t<Trans id=\"core.about.unsupported.title\">This job is currently unsupported</Trans>\n\t\t\t\t\t</Message.Header>\n\t\t\t\t\t<Trans id=\"core.about.unsupported.description\">\n\t\t\t\t\t\tThe output shown below will not contain any job-specific analysis, and may be missing critical data required to generate an accurate result.\n\t\t\t\t\t</Trans>\n\t\t\t\t</Message.Content>\n\t\t\t</Message>;\n        }\n        // Work out the supported patch range (and if we're in it)\n        const { from, to = from } = this.supportedPatches;\n        const supported = patchSupported(languageToEdition(this.parser.report.lang), from, to, this.parser.parseDate);\n        return <Grid>\n\t\t\t<Grid.Column mobile={16} computer={10}>\n\t\t\t\t<this.Description />\n\t\t\t\t{!supported && <Message error icon>\n\t\t\t\t\t<Icon name=\"times circle outline\"/>\n\t\t\t\t\t<Message.Content>\n\t\t\t\t\t\t<Message.Header>\n\t\t\t\t\t\t\t<Trans id=\"core.about.patch-unsupported.title\">Report patch unsupported</Trans>\n\t\t\t\t\t\t</Message.Header>\n\t\t\t\t\t\t<Trans id=\"core.about.patch-unsupported.description\">\n\t\t\t\t\t\t\tThis report was logged during patch {this.parser.patch.key}, which is not supported by the analyser. Calculations and suggestions may be impacted by changes in the interim.\n\t\t\t\t\t\t</Trans>\n\t\t\t\t\t</Message.Content>\n\t\t\t\t</Message>}\n\t\t\t</Grid.Column>\n\n\t\t\t\n\t\t\t\n\t\t\t<Grid.Column mobile={16} computer={6}>\n\t\t\t\t<Segment as=\"dl\" className={styles.meta}>\n\t\t\t\t\t<dt><Trans id=\"core.about.supported-patches\">Supported Patches:</Trans></dt>\n\t\t\t\t\t<dd>{from}{from !== to && `–${to}`}</dd>\n\n\t\t\t\t\t{this.contributors.length > 0 && <>\n\t\t\t\t\t\t<dt><Trans id=\"core.about.contributors\">Contributors:</Trans></dt>\n\t\t\t\t\t\t<dd>\n\t\t\t\t\t\t\t{this.contributors.map(contributor => {\n            const { user, role } = contributor;\n            return <div key={typeof user === 'string' ? user : user.name} className={styles.contributor}>\n\t\t\t\t\t\t\t\t\t<ContributorLabel contributor={user} detail={role && <NormalisedMessage message={role.text}/>}/>\n\t\t\t\t\t\t\t\t</div>;\n        })}\n\t\t\t\t\t\t</dd>\n\t\t\t\t\t</>}\n\t\t\t\t</Segment>\n\t\t\t</Grid.Column>\n\t\t</Grid>;\n    }\n}\nAbout.handle = 'about';\nAbout.displayOrder = DISPLAY_ORDER.ABOUT;\nAbout.displayMode = DISPLAY_MODE.FULL;\nAbout.title = t('core.about.title') `About`;\n","import Module from 'parser/core/Module';\nimport { Rule, Requirement } from 'parser/core/modules/Checklist';\nimport React from 'react';\nimport { Trans } from '@lingui/react';\nexport default class AlwaysBeCasting extends Module {\n    constructor(...args) {\n        super(...args);\n        this.addHook('complete', this._onComplete);\n    }\n    // Just using this for the suggestion for now\n    _onComplete() {\n        const numGcds = this.gcd.gcds.length;\n        if (!numGcds) {\n            return;\n        }\n        const fightDuration = this.parser.fightDuration - this.downtime.getDowntime();\n        this.checklist.add(new Rule({\n            name: <Trans id=\"core.always-cast.title\">Always be casting</Trans>,\n            description: <Trans id=\"core.always-cast.description\">\n\t\t\t\tMake sure you're always doing something. It's often better to make small\n\t\t\t\tmistakes while keeping the GCD rolling than it is to perform the correct\n\t\t\t\trotation slowly.\n\t\t\t</Trans>,\n            requirements: [\n                new Requirement({\n                    name: <Trans id=\"core.always-cast.gcd-uptime\">GCD Uptime</Trans>,\n                    percent: this.gcd.getUptime() / fightDuration * 100,\n                }),\n            ],\n        }));\n    }\n}\nAlwaysBeCasting.handle = 'abc';\nAlwaysBeCasting.dependencies = [\n    'checklist',\n    'downtime',\n    'gcd',\n];\n","import Module from 'parser/core/Module';\n// Blame Meishu. No touchy.\nconst INTERNAL_EVENT_TYPE = Symbol('aoe');\n// Sequential damage events with more than this time diff (in ms) will be considered seperate damage pulses\n// Consecutive staus events seem to have a longer sequential gap\n// At the moment, 200ms threshold seems to parse it correctly\nconst DEFAULT_AOE_THRESHOLD = 20;\nconst STATUS_AOE_THRESHOLD = 200;\nconst SUPPORTED_EVENTS = [\n    'refreshbuff',\n    'applybuff',\n];\nexport default class AoE extends Module {\n    constructor(...args) {\n        super(...args);\n        // Listen to our own event from normalisation\n        this.addHook(INTERNAL_EVENT_TYPE, this._onAoe);\n    }\n    // Need to normalise so the final events can go out at the right time\n    normalise(events) {\n        // Determine which name to use for damage and heal events (calculated vs normal)\n        SUPPORTED_EVENTS.push(this.fflogsEvents.damageEventName, this.fflogsEvents.healEventName);\n        // Track hits by source\n        const trackers = {};\n        function getTracker(event) {\n            if (!event.ability) {\n                return {};\n            }\n            if (!trackers[event.sourceID]) {\n                trackers[event.sourceID] = {};\n            }\n            const source = trackers[event.sourceID];\n            const abilityId = event.ability.guid;\n            return source[abilityId] = source[abilityId] || {\n                events: {},\n                insertAfter: 0,\n                timestamp: null,\n            };\n        }\n        const toAdd = [];\n        function addEvent(tracker) {\n            // Set the timestamp to be the very first of all the events\n            for (const eventType in tracker.events) {\n                if (tracker.events[eventType].length !== 0) {\n                    tracker.timestamp = tracker.timestamp || tracker.events[eventType][0].timestamp;\n                    tracker.timestamp = tracker.timestamp < tracker.events[eventType][0].timestamp ? tracker.timestamp : tracker.events[eventType][0].timestamp;\n                }\n            }\n            toAdd.push({\n                ...tracker,\n                type: INTERNAL_EVENT_TYPE,\n            });\n        }\n        for (let i = 0; i < events.length; i++) {\n            const event = events[i];\n            if (!SUPPORTED_EVENTS.includes(event.type)) {\n                continue;\n            }\n            const tracker = getTracker(event);\n            // Get the timestamp of the last event\n            let lastHitTimestamp = null;\n            if (Object.keys(tracker.events).length) {\n                for (const eventType in tracker.events) {\n                    // compare all event groups for the absolute last hit\n                    const groupLastHit = tracker.events[eventType][tracker.events[eventType].length - 1];\n                    if (lastHitTimestamp < groupLastHit.timestamp) {\n                        lastHitTimestamp = groupLastHit.timestamp;\n                    }\n                }\n            }\n            // It seems to be that status events have a longer application gap\n            const AOE_THRESHOLD = event.type === 'refreshbuff' || event.type === 'applybuff' ? STATUS_AOE_THRESHOLD : DEFAULT_AOE_THRESHOLD;\n            // If the last event was too long ago, generate an event\n            if (lastHitTimestamp && event.timestamp - lastHitTimestamp > AOE_THRESHOLD) {\n                addEvent(tracker);\n                tracker.events = {};\n                tracker.timestamp = null;\n            }\n            // If this is the first event of it's type, make a new property for it\n            if (!tracker.events[event.type]) {\n                tracker.events[event.type] = [];\n            }\n            event.i = i;\n            tracker.events[event.type].push(event);\n            tracker.insertAfter = i;\n        }\n        // Run a cleanup\n        for (const sourceId in trackers) {\n            for (const abilityId in trackers[sourceId]) {\n                const tracker = trackers[sourceId][abilityId];\n                let shouldCleanup = false;\n                for (const eventType in tracker.events) {\n                    if (tracker.events[eventType].length !== 0) {\n                        shouldCleanup = true;\n                    }\n                }\n                if (shouldCleanup) {\n                    addEvent(tracker);\n                }\n            }\n        }\n        // Add all the events we gathered up in, in order\n        let offset = 0;\n        toAdd.sort((a, b) => a.insertAfter - b.insertAfter).forEach(event => {\n            events.splice(event.insertAfter + 1 + offset, 0, event);\n            offset++;\n        });\n        return events;\n    }\n    _onAoe(event) {\n        if (!Object.keys(event.events).length) {\n            return;\n        }\n        for (const eventType in event.events) {\n            // Filter out any damage events that don't pass muster\n            let hitsByTarget = event.events[eventType];\n            if (eventType === 'damage') {\n                hitsByTarget = hitsByTarget.filter(this.isValidHit.bind(this));\n            }\n            // Transform into a simplified format\n            hitsByTarget = hitsByTarget.reduce((carry, event) => {\n                const key = `${event.targetID}-${event.targetInstance}`;\n                if (carry[key]) {\n                    carry[key].times++;\n                    carry[key].amount += event.amount;\n                    carry[key].successfulHit = carry[key].successfulHit || event.successfulHit;\n                }\n                else {\n                    carry[key] = {\n                        id: event.targetID,\n                        instance: event.targetInstance,\n                        times: 1,\n                        amount: event.amount,\n                        successfulHit: event.successfulHit,\n                    };\n                }\n                return carry;\n            }, {});\n            const fabricatedEvent = {\n                type: 'aoe' + eventType.replace('calculated', ''),\n                timestamp: event.events[eventType][0].timestamp,\n                ability: event.events[eventType][0].ability,\n                hits: Object.values(hitsByTarget),\n                sourceID: event.events[eventType][0].sourceID,\n                amount: Object.values(hitsByTarget).reduce((total, hit) => total + hit.amount, 0),\n                successfulHit: Object.values(hitsByTarget).reduce((successfulHit, hit) => successfulHit || hit.successfulHit, false),\n            };\n            if (event.events[eventType][0].hasOwnProperty('sourceResources')) {\n                fabricatedEvent.sourceResources = event.events[eventType][0].sourceResources;\n            }\n            this.parser.fabricateEvent(fabricatedEvent);\n        }\n    }\n    isValidHit(event) {\n        // Checking the event's target - if we get a falsey value back, it's an invalid target\n        const validTarget = !!this.enemies.getEntity(event.targetID);\n        // If there's an amount key but it's 0, it was likely a hit on an invuln target\n        // Allow hits w/ overkill, as the fflogs algo for that shit is flakey\n        const zeroAmount = event.amount === 0 && !event.overkill;\n        return validTarget && !zeroAmount;\n    }\n}\nAoE.handle = 'aoe';\nAoE.dependencies = [\n    // Need the precasts to fire first so we've got full info for the aoe calcs\n    'precastAction',\n    'precastStatus',\n    'enemies',\n    'fflogsEvents',\n];\n","import { __decorate, __metadata } from \"tslib\";\nimport { t } from '@lingui/macro';\nimport { Trans } from '@lingui/react';\nimport * as Sentry from '@sentry/browser';\nimport { Message, Segment } from 'akkd';\nimport NormalisedMessage from 'components/ui/NormalisedMessage';\nimport { getReportPatch } from 'data/PATCHES';\nimport Module, { dependency, DISPLAY_MODE } from 'parser/core/Module';\nimport React from 'react';\nimport { Table } from 'semantic-ui-react';\nimport { Data } from './Data';\nimport DISPLAY_ORDER from './DISPLAY_ORDER';\nconst EXPECTED_ABILITY_EVENTS = [\n    'begincast',\n    'cast',\n    'damage',\n    'calculateddamage',\n    'heal',\n    'calculatedheal',\n    'applybuff',\n    'applydebuff',\n    'refreshbuff',\n    'refreshdebuff',\n    'removebuff',\n    'removedebuff',\n    'applybuffstack',\n    'applydebuffstack',\n    'removebuffstack',\n    'removedebuffstack',\n];\nexport default class BrokenLog extends Module {\n    constructor() {\n        super(...arguments);\n        this.triggers = new Map();\n    }\n    init() {\n        // Unknown actions are unparseable\n        this.addHook(EXPECTED_ABILITY_EVENTS, { by: 'player', abilityId: this.data.actions.UNKNOWN.id }, () => {\n            this.trigger(this, 'unknown action', (<Trans id=\"core.broken-log.trigger.unknown-action\">\n\t\t\t\t\t\tOne or more actions were recorded incorrectly, and could not be parsed.\n\t\t\t\t\t</Trans>));\n        });\n    }\n    /**\n     * Trigger the module to display the broken log error.\n     * @param key Unique key that represents the BL trigger\n     * @param module Module that is triggering BL\n     * @param reason Short description of why BL was triggered\n     */\n    trigger(module, key, reason) {\n        const constructor = module.constructor;\n        const { handle } = constructor;\n        const triggerKey = `${handle}.${key}`;\n        // If this is the first time this issue has been triggered, try and report it to Sentry\n        if (!this.triggers.has(triggerKey) &&\n            !getReportPatch(this.parser.report).branch) {\n            const job = this.parser.player.type;\n            Sentry.withScope(scope => {\n                scope.setTags({\n                    job,\n                    module: handle,\n                });\n                scope.setExtras({\n                    report: this.parser.report.code,\n                    fight: this.parser.fight.id,\n                    player: this.parser.player.id,\n                });\n                Sentry.captureMessage(`${job}.${triggerKey}`);\n            });\n        }\n        this.triggers.set(triggerKey, {\n            module: constructor,\n            reason,\n        });\n    }\n    output() {\n        if (this.triggers.size === 0) {\n            return false;\n        }\n        return <Segment>\n\t\t\t<Message error icon=\"times circle outline\">\n\t\t\t\t<Trans id=\"core.broken-log.broken-log.title\" render={<Message.Header />}>\n\t\t\t\t\tThis log is broken.\n\t\t\t\t</Trans>\n\t\t\t\t<Trans id=\"core.broken-log.broken-log.description\">\n\t\t\t\t\tOne or more modules have reported that this log contains inconsistencies that would suggest data is missing or incorrect. While the system does try to maintain sane results in this situation, some statistics may be inaccurate.\n\t\t\t\t</Trans>\n\t\t\t</Message>\n\n\t\t\t<Table basic=\"very\" compact=\"very\">\n\t\t\t\t<Table.Header>\n\t\t\t\t\t<Table.Row>\n\t\t\t\t\t\t<Trans id=\"core.broken-log.list.module\" render={<Table.HeaderCell />}>Module</Trans>\n\t\t\t\t\t\t<Trans id=\"core.broken-log.list.reason\" render={<Table.HeaderCell />}>Reason</Trans>\n\t\t\t\t\t</Table.Row>\n\t\t\t\t</Table.Header>\n\t\t\t\t<Table.Body>\n\t\t\t\t\t{Array.from(this.triggers.values()).map(({ module, reason }) => (<Table.Row>\n\t\t\t\t\t\t\t<Table.Cell><NormalisedMessage message={module.title} id={module.i18n_id}/></Table.Cell>\n\t\t\t\t\t\t\t<Table.Cell>{reason}</Table.Cell>\n\t\t\t\t\t\t</Table.Row>))}\n\t\t\t\t</Table.Body>\n\t\t\t</Table>\n\t\t</Segment>;\n    }\n}\nBrokenLog.handle = 'brokenLog';\nBrokenLog.title = t('core.broken-log.title') `Broken Log`;\nBrokenLog.displayOrder = DISPLAY_ORDER.BROKEN_LOG;\nBrokenLog.displayMode = DISPLAY_MODE.RAW;\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Data)\n], BrokenLog.prototype, \"data\", void 0);\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport { Accordion } from 'semantic-ui-react';\nimport ContributorLabel from 'components/ui/ContributorLabel';\nimport styles from './ChangeLog.module.css';\nexport default class ChangeLog extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            activeIndexes: new Set(),\n        };\n        this.handleClick = (event, props) => {\n            const { index } = props;\n            const { activeIndexes } = this.state;\n            const newIndexes = new Set(activeIndexes);\n            if (newIndexes.has(index)) {\n                newIndexes.delete(index);\n            }\n            else {\n                newIndexes.add(index);\n            }\n            this.setState({ activeIndexes: newIndexes });\n        };\n    }\n    render() {\n        const { activeIndexes } = this.state;\n        return <Accordion fluid styled>\n\t\t\t{this.props.changelog.map((item, index) => {\n            const dateString = item.date.toLocaleDateString();\n            const active = activeIndexes.has(index);\n            return <React.Fragment key={index}>\n\t\t\t\t\t<Accordion.Title index={index} active={active} onClick={this.handleClick} className={styles.change}>\n\t\t\t\t\t\t<strong className={styles.date}>{dateString}</strong>\n\n\t\t\t\t\t\t{!active && <span className={styles.message}><item.Changes /></span>}\n\n\t\t\t\t\t\t{item.contributors && item.contributors.length > 0 && (<div className={styles.contributors}>\n\t\t\t\t\t\t\t\t{item.contributors.map(contributor => (<ContributorLabel key={contributor.name} contributor={contributor}/>))}\n\t\t\t\t\t\t\t</div>)}\n\t\t\t\t\t</Accordion.Title>\n\n\t\t\t\t\t<Accordion.Content active={active}>\n\t\t\t\t\t\t<item.Changes />\n\t\t\t\t\t</Accordion.Content>\n\t\t\t\t</React.Fragment>;\n        })}\n\t\t</Accordion>;\n    }\n}\nChangeLog.propTypes = {\n    changelog: PropTypes.arrayOf(PropTypes.shape({\n        date: PropTypes.instanceOf(Date),\n        contributors: PropTypes.array,\n        changes: PropTypes.string,\n    })),\n};\n","import { t } from '@lingui/macro';\nimport React from 'react';\nimport { default as ChangelogComponent } from './Component';\nimport Module, { DISPLAY_MODE } from 'parser/core/Module';\nimport DISPLAY_ORDER from '../DISPLAY_ORDER';\nexport default class ChangeLog extends Module {\n    output() {\n        const { changelog } = this.parser.meta;\n        if (changelog.length === 0) {\n            return false;\n        }\n        // Sorts the changelog by date. New to old.\n        changelog.sort((a, b) => b.date - a.date);\n        return <ChangelogComponent changelog={changelog}/>;\n    }\n}\nChangeLog.handle = 'changelog';\nChangeLog.displayOrder = DISPLAY_ORDER.CHANGELOG;\nChangeLog.displayMode = DISPLAY_MODE.FULL;\nChangeLog.title = t('core.changelog.title') `Changelog`;\n","import React from 'react';\nimport { Plural, Trans } from '@lingui/react';\nimport Module from 'parser/core/Module';\nimport { Item } from 'parser/core/modules/Timeline';\nimport { Suggestion, SEVERITY } from 'parser/core/modules/Suggestions';\n// One of these being applied to an actor signifies they're back up\nconst RAISE_STATUSES = [\n    'WEAKNESS',\n    'BRINK_OF_DEATH',\n];\nexport default class Death extends Module {\n    constructor(...args) {\n        super(...args);\n        this._count = 0;\n        this._deadTime = 0;\n        this._timestamp = null;\n        const raiseStatuses = RAISE_STATUSES.map(key => this.data.statuses[key]);\n        this.addHook('death', { to: 'player' }, this._onDeath);\n        this.addHook('applydebuff', {\n            to: 'player',\n            abilityId: raiseStatuses,\n        }, this._onRaise);\n        this.addHook('complete', this._onComplete);\n        // If they (begin)cast, they were probably LB3'd, just mark end of death\n        // TODO: I mean there's an actual LB3 action cast, it's just not in the logs because of my filter. Look into it.\n        const checkLb3 = event => this._timestamp && this._onRaise(event);\n        this.addHook('begincast', { by: 'player' }, checkLb3);\n        this.addHook('cast', { by: 'player' }, checkLb3);\n    }\n    _onDeath(event) {\n        if (!this.shouldCountDeath(event)) {\n            return;\n        }\n        this._count++;\n        this._timestamp = event.timestamp;\n    }\n    _onRaise(event) {\n        this.addDeathToTimeline(event.timestamp);\n        this.parser.fabricateEvent({\n            type: 'raise',\n            targetID: event.targetID,\n        });\n    }\n    _onComplete() {\n        // If the parse was a wipe, and they didn't res after their last death, refund the death - the wipe itself is\n        // pretty meaningless to complain about.\n        // Max at 0 because dummy parses aren't counted as kills, though.\n        if (!this.parser.fight.kill &&\n            this._timestamp) {\n            this._count = Math.max(this._count - 1, 0);\n        }\n        if (this._timestamp) {\n            this.addDeathToTimeline(this.parser.fight.end_time);\n        }\n        if (!this._count) {\n            return;\n        }\n        // Deaths are always major\n        this.suggestions.add(new Suggestion({\n            icon: this.data.actions.RAISE.icon,\n            content: <Trans id=\"core.deaths.content\">\n\t\t\t\tDon't die. Between downtime, lost gauge resources, and resurrection debuffs, dying is absolutely <em>crippling</em> to damage output.\n\t\t\t</Trans>,\n            severity: SEVERITY.MORBID,\n            why: <Plural id=\"core.deaths.why\" value={this._count} _1=\"# death\" other=\"# deaths\"/>,\n        }));\n    }\n    // Override this if a fight mechanic is a forced death *cough*ucob*cough* and shouldn't be counted towards the player\n    shouldCountDeath( /* event */) {\n        return true;\n    }\n    addDeathToTimeline(end) {\n        const startTime = this.parser.fight.start_time;\n        this.timeline.addItem(new Item({\n            type: 'background',\n            style: 'background-color: #ce909085;',\n            start: this._timestamp - startTime,\n            end: end - startTime,\n        }));\n        this._deadTime += (end - this._timestamp);\n        this._timestamp = null;\n    }\n    get deadTime() { return this._deadTime; }\n}\nDeath.handle = 'death';\nDeath.dependencies = [\n    'data',\n    'suggestions',\n    'timeline',\n];\n","import Module from 'parser/core/Module';\nimport { HitType as EventHitType } from 'fflogs';\nconst ACTION_EVENT_TYPES = [\n    'damage',\n    'heal',\n    'calculateddamage',\n    'calculatedheal',\n];\nconst FAILED_HITS = [\n    EventHitType.MISS,\n    EventHitType.IMMUNE,\n];\nexport default class HitType extends Module {\n    normalise(events) {\n        for (let i = 0; i < events.length; i++) {\n            const event = events[i];\n            // Prune to only damage and heals since nothing else can crit/direct hit\n            if (!ACTION_EVENT_TYPES.includes(event.type)) {\n                continue;\n            }\n            event.criticalHit = event.hitType === EventHitType.CRITICAL;\n            event.directHit = event.multistrike === true;\n            event.successfulHit = !FAILED_HITS.includes(event.hitType);\n        }\n        return events;\n    }\n}\nHitType.handle = 'hitType';\n","import About from './About';\nimport AdditionalEvents from './AdditionalEvents';\nimport AlwaysBeCasting from './AlwaysBeCasting';\nimport AoE from './AoE';\nimport BrokenLog from './BrokenLog';\nimport ChangeLog from './ChangeLog';\nimport CastTime from './CastTime';\nimport Checklist from './Checklist';\nimport Combatants from './Combatants';\nimport Combos from './Combos';\nimport Cooldowns from './Cooldowns';\nimport { Data } from './Data';\nimport Death from './Death';\nimport Downtime from './Downtime';\nimport Enemies from './Enemies';\nimport { FFLogsEventNormaliser } from './FFLogsEventNormaliser';\nimport GlobalCooldown from './GlobalCooldown';\nimport HitType from './HitType';\nimport Invulnerability from './Invulnerability';\nimport PrecastAction from './PrecastAction';\nimport PrecastStatus from './PrecastStatus';\nimport RaidBuffs from './RaidBuffs';\nimport Speedmod from './Speedmod';\nimport { Statistics } from './Statistics';\nimport Statuses from './Statuses';\nimport Suggestions from './Suggestions';\nimport Timeline from './Timeline';\nimport UnableToAct from './UnableToAct';\nimport Weaving from './Weaving';\nexport default [\n    About,\n    AdditionalEvents,\n    AlwaysBeCasting,\n    AoE,\n    BrokenLog,\n    ChangeLog,\n    CastTime,\n    Checklist,\n    Combatants,\n    Combos,\n    Cooldowns,\n    Data,\n    Death,\n    Downtime,\n    Enemies,\n    FFLogsEventNormaliser,\n    GlobalCooldown,\n    HitType,\n    Invulnerability,\n    PrecastAction,\n    PrecastStatus,\n    RaidBuffs,\n    Speedmod,\n    Statistics,\n    Statuses,\n    Suggestions,\n    Timeline,\n    UnableToAct,\n    Weaving,\n];\n"],"sourceRoot":""}
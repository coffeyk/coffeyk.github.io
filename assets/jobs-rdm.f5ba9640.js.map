{"version":3,"sources":["webpack:///./src/components/ui/RotationTable.tsx","webpack:///./src/components/ui/TimeLineChart.js","webpack:///./src/parser/core/modules/Combos.tsx","webpack:///./src/parser/jobs/rdm/statistics/DualStatistic.module.css?85d5","webpack:///./src/parser/jobs/rdm/statistics/DualStatistic.tsx","webpack:///./src/parser/jobs/rdm/modules/Gauge.js","webpack:///./src/parser/jobs/rdm/modules/DualCastEnums.js","webpack:///./src/parser/jobs/rdm/modules/Dualcast.js","webpack:///./src/parser/jobs/rdm/modules/GeneralCDDowntime.ts","webpack:///./src/parser/jobs/rdm/modules/ProcsEnum.js","webpack:///./src/parser/jobs/rdm/modules/Procs.js","webpack:///./src/parser/jobs/rdm/modules/Combos.js","webpack:///./src/parser/jobs/rdm/modules/MeleeCombos.js","webpack:///./src/parser/jobs/rdm/modules/MovementSkills.js","webpack:///./src/parser/jobs/rdm/modules/index.js"],"names":["RotationTable","React","Component","render","targets","notes","data","onGoto","headerTitle","this","props","compact","unstackable","celled","Header","Row","HeaderCell","collapsing","id","map","target","i","key","textAlign","header","note","Body","entry","start","targetAccessorResolver","accessor","targetsData","actual","expected","notesAccessorResolver","notesMap","TargetCell","Cell","positive","undefined","negative","end","rotation","style","marginRight","formatDuration","circular","size","icon","onClick","targetEntry","events","noteEntry","DEFAULT_OPTIONS","aspectRatio","scales","xAxes","type","time","displayFormats","minute","second","millisecond","tooltipFormat","TimeLineChart","PureComponent","options","width","height","DEFAULT_GCD","GCD_TIMEOUT_MILLIS","ISSUE_TYPENAMES","uncomboed","combobreak","failedcombo","Combos","Module","constructor","super","arguments","lastGcdTime","parser","fight","start_time","currentComboChain","issues","init","addHook","by","onCast","onComplete","lastComboEvent","ability","guid","filter","issue","event","fabricateComboEvent","combo","timestamp","fabricateEvent","recordBrokenCombo","context","isAllowableComboBreak","push","recordUncomboedGcd","recordFailedCombo","checkCombo","lastAction","from","Array","isArray","includes","action","getAction","onGcd","breaksCombo","successfulHit","addJobSpecificSuggestions","comboBreakers","uncomboedGcds","suggestions","add","TieredSuggestion","suggestionIcon","content","tiers","1","SEVERITY","MINOR","2","MEDIUM","4","MAJOR","value","length","why","output","startTime","sort","a","b","completeContext","startEvent","endEvent","startAction","endAction","cooldown","reason","whiteSpace","timeline","show","handle","title","displayOrder","DISPLAY_ORDER","COMBOS","__decorate","dependency","__metadata","Data","prototype","Suggestions","Timeline","module","exports","DualStatistic","AbstractStatistic","opts","Content","className","styles","dualStatistic","label","titleWrapper","src","icon2","title2","value2","MANA_GAIN","ACTIONS","VERSTONE","white","black","VERFIRE","VERAERO","VERTHUNDER","VERHOLY","VERFLARE","JOLT","JOLT_II","VERAERO_II","VERTHUNDER_II","IMPACT","ENCHANTED_RIPOSTE","ENCHANTED_ZWERCHHAU","ENCHANTED_REDOUBLEMENT","ENCHANTED_MOULINET","ENCHANTED_REPRISE","SCORCH","SEVERITY_WASTED_MANA","20","80","SEVERITY_LOST_MANA","MANA_DIFFERENCE_THRESHOLD","MANA_LOST_DIVISOR","MANA_CAP","MANAFICATION_MULTIPLIER","MANA_FLOOR","GaugeAction","startingWhite","startingBlack","mana","beforeCast","afterCast","overCapLoss","imbalanceLoss","invulnLoss","manaficationLoss","calculateManaFicationManaGained","calculateManaOvercap","calculateCastManaGained","abilityId","missOrInvuln","calculateManaImbalance","Math","ceil","isManafication","Gauge","_whiteMana","_blackMana","_whiteManaWasted","_blackManaWasted","_whiteManaLostToImbalance","_blackManaLostToImbalance","_whiteManaLostToInvulnerable","_blackManaLostToInvulnerable","_whiteManaLostToManafication","_blackManaLostToManafication","_history","MANAFICATION","_gaugeEvent","to","_onDeath","_onComplete","_pushToGraph","currentTimestamp","t","y","gaugeAction","cooldowns","resetCooldown","CORPS_A_CORPS","DISPLACEMENT","fabricatedEvent","missOrInvlun","statistics","info","whm","Color","JOBS","WHITE_MAGE","colour","blm","BLACK_MAGE","datasets","backgroundColor","fade","borderColor","steppedLine","dependencies","CAST_TYPE","NA","HardCast","SwiftCast","CORRECT_GCDS","VERRAISE","SCATTER","enumify","DualCast","_castType","_ctIndex","_usedCast","_missedDualCasts","_wastedDualCasts","_castTypeLastChanged","_severityMissedDualcast","3","_severityWastedDualcast","5","_onCast","STATUSES","DUALCAST","_onGain","_onRemove","abilityID","getDataBy","castTime","invuln","downtime","getDowntime","set","casts","name","casttype","reset","panels","formatTimestamp","Rotation","Accordion","exclusive","styled","fluid","DEFAULT_ALLOWED_DOWNTIME","GeneralCDDowntime","CooldownDowntime","defaultAllowedAverageDowntime","trackedCds","ACCELERATION","allowedAverageDowntime","SWIFTCAST","firstUseOffset","EMBOLDEN","FLECHE","CONTRE_SIXTE","SEVERITY_OVERWRITTEN_PROCS","SEVERITY_INVULN_PROCS","SEVERITY_MISSED_PROCS","7","PROCS","STATUS","VERSTONE_READY","VERFIRE_READY","Procs","_invulnCasts","_castStateMap","_doNotCastMap","_currentProcs","_castState","_previousCast","_targetWasInvuln","_playerWasInDowntime","_lastTargetID","_onRefresh","_initializeHistory","isInvulnerable","targetID","overWritten","missed","wasted","statusID","gcdTimeDiff","lastTargetName","lastTarget","enemies","getEntity","invulnEvent","missedFire","invulnFire","overWrittenFire","missedStone","invulnStone","overWrittenStone","invulnEvents","item","CoreCombos","_derpComboActions","_severityDerpComboActions","_notEnoughManaActions","RIPOSTE","ZWERCHHAU","REDOUBLEMENT","_severityNotEnoughManaActions","_severityGenericActions","derpComboCount","notEnoughManaCount","breaker","theRest","FINISHERS","SEVERITY_WASTED_FINISHER","IGNORE_FINISHER_PROCS_MANA_LOSS_THRESHOLD","WHITE_MANA_ACTIONS","proc","dualcast","finisher","BLACK_MANA_ACTIONS","DELAY_ACCELERATION_AVAILABLE_THRESHOLD","MeleeCombos","_meleeCombos","_incorrectFinishers","verholy","verflare","delay","_startCombo","_currentCombo","startMana","startProcs","verstone","combatants","selected","hasStatus","verfire","acceleration","_breakComboIfExists","broken","_endCombo","_handleFinisher","recommendedActions","recommendation","whiteState","amount","procReady","actions","blackState","recommendedFinisher","_outOfBalanceFinisher","_inBalanceFinisher","used","apply","lowerManaState","higherManaState","isAccelerationUp","comboDelayResults","_manaLossToDelayCombo","finisherManaGain","manaLoss","firstManaState","secondManaState","possibleDelays","newLowerMana","newHigherMana","max","min","getCooldownRemaining","firstDelaySkill","Table","Object","keys","Button","showName","CACS_PER_MANAFICATION","DISPS_PER_MANAFICATION","ENGAGEMENTS_PER_MANAFICATION","GRACE_FOR_PULL","MovementSkills","_lastManafic","cac","disp","engagement","ENGAGEMENT","requirements","description","summary","reduce","acc","manafic","manafics","cacs","_checkCac","_checkDisp","checklist","Rule","threshold","finalValue","Requirement","percent","disps","engagements","dispID","leftoverDisps","totalThreshold","Message","Dualcast"],"mappings":"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","file":"assets/jobs-rdm.f5ba9640.js","sourcesContent":["import { Trans } from '@lingui/react';\nimport Rotation from 'components/ui/Rotation';\nimport React from 'react';\nimport { Button, Table } from 'semantic-ui-react';\nimport { formatDuration } from 'utilities';\nexport class RotationTable extends React.Component {\n    render() {\n        const { targets, notes, data, onGoto, headerTitle, } = this.props;\n        return <Table compact unstackable celled>\n\t\t\t<Table.Header>\n\t\t\t\t<Table.Row>\n\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t<strong><Trans id=\"core.ui.rotation-table.header.time\">Time</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(targets || []).map((target, i) => <Table.HeaderCell key={`target_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{target.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t\t<Table.HeaderCell>\n\t\t\t\t\t\t<strong>{(headerTitle) ? headerTitle : <Trans id=\"core.ui.rotation-table.header.rotation\">Rotation</Trans>}</strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(notes || []).map((note, i) => <Table.HeaderCell key={`note_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{note.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Header>\n\t\t\t<Table.Body>\n\t\t\t\t{data.map((entry) => <RotationTable.Row key={entry.start} onGoto={onGoto} targets={targets || []} notes={notes || []} {...entry}/>)}\n\t\t\t</Table.Body>\n\t\t</Table>;\n    }\n}\nRotationTable.targetAccessorResolver = (entry, target) => {\n    if (typeof target.accessor === 'string' && entry.targetsData != null) {\n        return entry.targetsData[target.accessor];\n    }\n    else if (typeof target.accessor === 'function') {\n        return target.accessor(entry);\n    }\n    else {\n        return {\n            actual: 0,\n            expected: 0,\n        };\n    }\n};\nRotationTable.notesAccessorResolver = (entry, note) => {\n    if (typeof note.accessor === 'string' && entry.notesMap != null) {\n        return entry.notesMap[note.accessor];\n    }\n    else if (typeof note.accessor === 'function') {\n        return note.accessor(entry);\n    }\n    else {\n        return null;\n    }\n};\nRotationTable.TargetCell = ({ actual, expected }) => <Table.Cell textAlign=\"center\" positive={expected === undefined ? false : actual >= expected} negative={expected === undefined ? false : actual < expected}>\n\t\t\t{actual}/{expected === undefined ? '-' : expected}\n\t\t</Table.Cell>;\nRotationTable.Row = ({ onGoto, targets, notes, notesMap, start, end, targetsData, rotation }) => <Table.Row>\n\t\t\t<Table.Cell textAlign=\"center\">\n\t\t\t\t<span style={{ marginRight: 5 }}>{formatDuration(start / 1000)}</span>\n\t\t\t\t{typeof onGoto === 'function' && <Button circular compact size=\"mini\" icon=\"time\" onClick={() => onGoto(start, end)}/>}\n\t\t\t</Table.Cell>\n\t\t\t{targets\n    .map(target => RotationTable.targetAccessorResolver({ start, end, targetsData, rotation }, target))\n    .map((targetEntry, i) => <RotationTable.TargetCell key={`target_${i}`} {...targetEntry}/>)}\n\t\t\t<Table.Cell>\n\t\t\t\t<Rotation events={rotation}/>\n\t\t\t</Table.Cell>\n\t\t\t{notes\n    .map(note => RotationTable.notesAccessorResolver({ start, end, targetsData, notesMap, rotation }, note))\n    .map((noteEntry, i) => <Table.Cell key={`notes_${i}`} textAlign=\"center\">\n\t\t\t\t\t\t\t{noteEntry}\n\t\t\t\t\t\t</Table.Cell>)}\n\t\t</Table.Row>;\n","import _ from 'lodash';\nimport PropTypes from 'prop-types';\nimport React, { PureComponent } from 'react';\nimport { Line } from 'react-chartjs-2';\nconst DEFAULT_OPTIONS = {\n    aspectRatio: 3,\n    scales: {\n        xAxes: [{\n                type: 'time',\n                time: {\n                    displayFormats: {\n                        minute: 'm:ss',\n                        second: 'm:ss',\n                        millisecond: 'm:ss.SS',\n                    },\n                    // This tooltip format displays similar to a \"relative\" timestamp,\n                    // since react assumes UNIX epoch timestamps for the data.\n                    tooltipFormat: 'mm:ss.SSS',\n                },\n            }],\n    },\n};\nexport default class TimeLineChart extends PureComponent {\n    render() {\n        const options = _.merge({}, DEFAULT_OPTIONS, this.props.options || {});\n        return <Line data={this.props.data} options={options} \n        // Using this trash 'cus aspectRatio doesn't work with the react wrapper\n        width={options.aspectRatio} height={1}/>;\n    }\n}\nTimeLineChart.propTypes = {\n    data: PropTypes.object.isRequired,\n    options: PropTypes.object,\n};\n","// If you can make it through this entire file without hitting semantic saturation of the word \"combo\", hats off to you. IT DOESN'T LOOK REAL ANYMORE.\nimport { __decorate, __metadata } from \"tslib\";\nimport { t } from '@lingui/macro';\nimport { Plural, Trans } from '@lingui/react';\nimport { RotationTable } from 'components/ui/RotationTable';\nimport _ from 'lodash';\nimport Module, { dependency } from 'parser/core/Module';\nimport DISPLAY_ORDER from 'parser/core/modules/DISPLAY_ORDER';\nimport Suggestions, { SEVERITY, TieredSuggestion } from 'parser/core/modules/Suggestions';\nimport Timeline from 'parser/core/modules/Timeline';\nimport React from 'react';\nimport { Data } from './Data';\nconst DEFAULT_GCD = 2.5;\nconst GCD_TIMEOUT_MILLIS = 15000;\nconst ISSUE_TYPENAMES = {\n    uncomboed: <Trans id=\"core.combos.issuetypenames.uncomboed\">Uncomboed</Trans>,\n    combobreak: <Trans id=\"core.combos.issuetypenames.combobreak\">Broken Combo</Trans>,\n    failedcombo: <Trans id=\"core.combos.issuetypenames.failed\">Missed or Invulnerable</Trans>,\n};\nexport default class Combos extends Module {\n    constructor() {\n        super(...arguments);\n        this.lastGcdTime = this.parser.fight.start_time;\n        this.currentComboChain = [];\n        this.issues = [];\n    }\n    init() {\n        this.addHook('aoedamage', { by: 'player' }, this.onCast);\n        this.addHook('complete', this.onComplete);\n    }\n    get lastComboEvent() {\n        return _.last(this.currentComboChain) || null;\n    }\n    get lastAction() {\n        const lastComboEvent = this.lastComboEvent;\n        if (!lastComboEvent) {\n            return null;\n        }\n        return lastComboEvent.ability.guid;\n    }\n    get comboBreakers() {\n        return this.issues\n            .filter(issue => issue.type === 'combobreak')\n            .map(issue => issue.event);\n    }\n    get uncomboedGcds() {\n        return this.issues\n            .filter(issue => issue.type === 'uncomboed')\n            .map(issue => issue.event);\n    }\n    fabricateComboEvent(event) {\n        const combo = {\n            ...event,\n            type: 'combo',\n        };\n        delete combo.timestamp; // Since fabricateEvent adds that in anyway\n        this.parser.fabricateEvent(combo);\n    }\n    recordBrokenCombo(event, context) {\n        if (!this.isAllowableComboBreak(event, context)) {\n            this.issues.push({\n                type: 'combobreak',\n                event,\n                context,\n            });\n        }\n        this.currentComboChain = [];\n    }\n    recordUncomboedGcd(event) {\n        this.issues.push({\n            type: 'uncomboed',\n            event,\n            context: [],\n        });\n        this.currentComboChain = [];\n    }\n    recordFailedCombo(event, context) {\n        this.issues.push({\n            type: 'failedcombo',\n            event,\n            context,\n        });\n        this.currentComboChain = [];\n    }\n    /**\n     *\n     * @param combo\n     * @param event\n     * @return true if combo, false otherwise\n     */\n    checkCombo(combo /* Should be an Action type */, event) {\n        // Not in a combo\n        if (this.lastAction == null) {\n            // Combo starter, we good\n            if (combo.start) {\n                this.fabricateComboEvent(event);\n                return true;\n            }\n            // Combo action that isn't a starter, that's a paddlin'\n            if (combo.from) {\n                this.recordUncomboedGcd(event);\n                return false;\n            }\n        }\n        if (combo.start) {\n            // Broken combo - starting a new combo while in a current combo\n            this.recordBrokenCombo(event, this.currentComboChain);\n            return true; // Start a new combo\n        }\n        // Check if action continues existing combo\n        if (combo.from) {\n            const fromOptions = Array.isArray(combo.from) ? combo.from : [combo.from];\n            if (fromOptions.includes(this.lastAction)) {\n                // Combo continued correctly\n                this.fabricateComboEvent(event);\n                // If it's a finisher, reset the combo\n                return !combo.end;\n            }\n        }\n        // Action did not continue combo correctly and is not a new combo starter\n        this.recordBrokenCombo(event, this.currentComboChain);\n        return false;\n    }\n    onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action) {\n            return;\n        }\n        // Only track GCDs that either progress or break combos so actions like Drill and Shadow Fang don't falsely extend the simulated combo timer\n        if (action.onGcd && (action.combo || action.breaksCombo)) {\n            if (event.timestamp - this.lastGcdTime > GCD_TIMEOUT_MILLIS) {\n                // If we've had enough downtime between GCDs to let the combo expire, reset the state so we don't count erroneous combo breaks\n                this.currentComboChain = [];\n            }\n            this.lastGcdTime = event.timestamp;\n        }\n        // If it's a combo action, run it through the combo checking logic\n        if (action.combo) {\n            if (!event.successfulHit) {\n                // Failed attacks break combo\n                this.recordFailedCombo(event, this.currentComboChain);\n                return;\n            }\n            const continueCombo = this.checkCombo(action.combo, event);\n            if (continueCombo) {\n                this.currentComboChain.push(event);\n            }\n            else {\n                this.currentComboChain = [];\n            }\n        }\n        if (action.breaksCombo && this.lastAction !== null) {\n            // Combo breaking action, that's a paddlin'\n            this.recordBrokenCombo(event, this.currentComboChain);\n        }\n    }\n    onComplete() {\n        if (this.addJobSpecificSuggestions(this.comboBreakers, this.uncomboedGcds)) {\n            return;\n        }\n        this.suggestions.add(new TieredSuggestion({\n            icon: this.constructor.suggestionIcon,\n            content: <Trans id=\"core.combos.content\">\n\t\t\t\t<p>Avoid breaking combos, as failing to complete combos costs you a significant amount of DPS and important secondary effects.</p>\n\t\t\t\t<p>Using a combo GCD at the wrong combo step, using non-combo GCDs while inside a combo, missing, or attacking a target that is invulnerable will cause your combo to break.</p>\n\t\t\t</Trans>,\n            tiers: {\n                1: SEVERITY.MINOR,\n                2: SEVERITY.MEDIUM,\n                4: SEVERITY.MAJOR,\n            },\n            value: this.issues.length,\n            why: <Plural id=\"core.combos.why\" value={this.issues.length} one=\"You misused # combo action.\" other=\"You misused # combo actions.\"/>,\n        }));\n    }\n    /**\n     * To be overridden by subclasses. This is called in _onComplete() and passed two arrays of event objects - one for events that\n     * broke combos, and one for combo GCDs used outside of combos. Subclassing modules can add job-specific suggestions based on\n     * what particular actions were misused and when in the fight.\n     * The overriding module should return true if the default suggestion is not wanted\n     */\n    addJobSpecificSuggestions(comboBreakers, uncomboedGcds) {\n        return false;\n    }\n    /**\n     * To be overridden by subclasses. This is called in recordBrokenCombo, and receives the event triggering the broken combo,\n     * and the context information for that break. Jobs can override this to indicate whether this broken combo is allowed. If so,\n     * the event and context will not be recorded, and the current combo will be cleared with no other side effects.\n     * Returning false will allow the break to be recorded, and displayed to the user\n     */\n    isAllowableComboBreak(event, context) {\n        return false;\n    }\n    output() {\n        if (this.issues.length <= 0) {\n            return false;\n        }\n        // Access Alias\n        const startTime = this.parser.fight.start_time;\n        const data = this.issues\n            .sort((a, b) => a.event.timestamp - b.event.timestamp)\n            .map(issue => {\n            const completeContext = [...(issue.context || []), issue.event];\n            const startEvent = _.first(completeContext);\n            const endEvent = _.last(completeContext);\n            const startAction = this.data.getAction(startEvent.ability.guid);\n            const endAction = this.data.getAction(endEvent.ability.guid);\n            return ({\n                start: startEvent.timestamp - startTime + (startAction?.cooldown ?? DEFAULT_GCD),\n                end: endEvent.timestamp - startTime + (endAction?.cooldown ?? DEFAULT_GCD),\n                rotation: completeContext,\n                notesMap: {\n                    reason: <span style={{ whiteSpace: 'nowrap' }}>{ISSUE_TYPENAMES[issue.type]}</span>,\n                },\n            });\n        });\n        return <RotationTable notes={[\n            {\n                header: <Trans id=\"core.combos.rotationtable.header.reason\">Reason</Trans>,\n                accessor: 'reason',\n            },\n        ]} data={data} onGoto={this.timeline.show}/>;\n    }\n}\nCombos.handle = 'combos';\nCombos.title = t('core.combos.title') `Combo Issues`;\nCombos.displayOrder = DISPLAY_ORDER.COMBOS;\n// This should be redefined by subclassing modules; the default is the basic 'Attack' icon\nCombos.suggestionIcon = 'https://xivapi.com/i/000000/000405.png';\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Data)\n], Combos.prototype, \"data\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Suggestions)\n], Combos.prototype, \"suggestions\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Timeline)\n], Combos.prototype, \"timeline\", void 0);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"gutter\":\"20px\",\"dualStatistic\":\"DualStatistic-module_dualStatistic__oUsEH\",\"titleWrapper\":\"DualStatistic-module_titleWrapper__1RmR8\",\"icon\":\"DualStatistic-module_icon__1bhx6\",\"title\":\"DualStatistic-module_title__2W808\",\"value\":\"DualStatistic-module_value__1lthp\"};","import { AbstractStatistic } from 'parser/core/modules/Statistics/AbstractStatistic';\nimport React from 'react';\nimport styles from './DualStatistic.module.css';\nexport class DualStatistic extends AbstractStatistic {\n    constructor(opts) {\n        // \tsuper({\n        // \t\t...opts,\n        // \t\twidth: opts.width || 0 < 2? 2 : opts.width,\n        // })\n        super(opts);\n        this.Content = () => (<div className={styles.dualStatistic}>\n\t\t\t{this.label}\n\t\t\t<div className={styles.titleWrapper}>\n\t\t\t\t{this.icon && <img src={this.icon} className={styles.icon}/>}\n\t\t\t\t<div className={styles.title}>{this.title}</div>\n\t\t\t\t<div className={styles.value}>{this.value}</div>\n\t\t\t</div>\n\t\t\t<div className={styles.titleWrapper}>\n\t\t\t\t{this.icon && <img src={this.icon2} className={styles.icon}/>}\n\t\t\t\t<div className={styles.title}>{this.title2}</div>\n\t\t\t\t<div className={styles.value}>{this.value2}</div>\n\t\t\t</div>\n\t\t</div>);\n        this.label = opts.label;\n        this.title = opts.title;\n        this.title2 = opts.title2;\n        this.icon = opts.icon;\n        this.icon2 = opts.icon2;\n        this.value = opts.value;\n        this.value2 = opts.value2;\n    }\n}\n","import { t } from '@lingui/macro';\nimport { Trans } from '@lingui/react';\nimport Color from 'color';\nimport React, { Fragment } from 'react';\nimport TimeLineChart from 'components/ui/TimeLineChart';\nimport ACTIONS from 'data/ACTIONS';\nimport JOBS from 'data/JOBS';\nimport Module from 'parser/core/Module';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport { DualStatistic } from 'parser/jobs/rdm/statistics/DualStatistic';\n//import {getCooldownRemaining} from 'parser/core/modules/Cooldowns'\n//import {ActionLink} from 'components/ui/DbLink'\n//TODO: Should possibly look into different Icons for things in Suggestions\n//Mana Gains and Expenditures\nexport const MANA_GAIN = {\n    [ACTIONS.VERSTONE.id]: { white: 9, black: 0 },\n    [ACTIONS.VERFIRE.id]: { white: 0, black: 9 },\n    [ACTIONS.VERAERO.id]: { white: 11, black: 0 },\n    [ACTIONS.VERTHUNDER.id]: { white: 0, black: 11 },\n    [ACTIONS.VERHOLY.id]: { white: 21, black: 0 },\n    [ACTIONS.VERFLARE.id]: { white: 0, black: 21 },\n    [ACTIONS.JOLT.id]: { white: 3, black: 3 },\n    [ACTIONS.JOLT_II.id]: { white: 3, black: 3 },\n    [ACTIONS.VERAERO_II.id]: { white: 7, black: 0 },\n    [ACTIONS.VERTHUNDER_II.id]: { white: 0, black: 7 },\n    [ACTIONS.IMPACT.id]: { white: 3, black: 3 },\n    [ACTIONS.ENCHANTED_RIPOSTE.id]: { white: -30, black: -30 },\n    [ACTIONS.ENCHANTED_ZWERCHHAU.id]: { white: -25, black: -25 },\n    [ACTIONS.ENCHANTED_REDOUBLEMENT.id]: { white: -25, black: -25 },\n    [ACTIONS.ENCHANTED_MOULINET.id]: { white: -20, black: -20 },\n    [ACTIONS.ENCHANTED_REPRISE.id]: { white: -5, black: -5 },\n    [ACTIONS.SCORCH.id]: { white: 7, black: 7 },\n};\nexport const SEVERITY_WASTED_MANA = {\n    1: SEVERITY.MINOR,\n    20: SEVERITY.MEDIUM,\n    80: SEVERITY.MAJOR,\n};\nexport const SEVERITY_LOST_MANA = {\n    1: SEVERITY.MINOR,\n    20: SEVERITY.MEDIUM,\n    80: SEVERITY.MAJOR,\n};\nexport const MANA_DIFFERENCE_THRESHOLD = 30;\nconst MANA_LOST_DIVISOR = 2;\nexport const MANA_CAP = 100;\nconst MANAFICATION_MULTIPLIER = 2;\nconst MANA_FLOOR = 0;\nclass GaugeAction {\n    constructor(startingWhite, startingBlack) {\n        this.mana = {\n            white: {\n                beforeCast: 0,\n                afterCast: 0,\n                overCapLoss: 0,\n                imbalanceLoss: 0,\n                invulnLoss: 0,\n                manaficationLoss: 0,\n            },\n            black: {\n                beforeCast: 0,\n                afterCast: 0,\n                overCapLoss: 0,\n                imbalanceLoss: 0,\n                invulnLoss: 0,\n                manaficationLoss: 0,\n            },\n        };\n        this.mana.white.beforeCast = startingWhite;\n        this.mana.black.beforeCast = startingBlack;\n        this.mana.white.afterCast = startingWhite;\n        this.mana.black.afterCast = startingBlack;\n    }\n    calculateManaFicationManaGained() {\n        this.mana.white.afterCast = this.mana.white.beforeCast * MANAFICATION_MULTIPLIER;\n        this.mana.black.afterCast = this.mana.black.beforeCast * MANAFICATION_MULTIPLIER;\n        this.calculateManaOvercap(true);\n    }\n    calculateCastManaGained(event) {\n        //Determine if the ability we used should yield any mana gain.\n        //console.log(`White: ${this._whiteMana}, Black: ${this._blackMana}`)\n        //console.log(`Ability: ${event.ability.name}, timestamp: ${this.parser.formatTimestamp(event.timestamp)}`)\n        const abilityId = event.ability.guid;\n        const { white, black } = MANA_GAIN[abilityId] || {};\n        if (white || black) {\n            if (!event.successfulHit) {\n                // Melee combo skills will still consume mana but will not continue the combo, set an invuln/missed flag for downstream consumers\n                this.missOrInvuln = true;\n                if (white > 0 || black > 0) {\n                    // No mana gained from spells that do no damage due to missing or targeting an invulnerable boss (e.g. Omega M/F firewall)\n                    this.mana.white.invulnLoss = white;\n                    this.mana.black.invulnLoss = black;\n                    return;\n                }\n            }\n            this.mana.white.afterCast = this.mana.white.beforeCast + white;\n            this.mana.black.afterCast = this.mana.black.beforeCast + black;\n            this.calculateManaImbalance(white, black);\n            this.calculateManaOvercap(false);\n        }\n    }\n    calculateManaImbalance(white, black) {\n        if (white && this.mana.black.beforeCast - this.mana.white.beforeCast > MANA_DIFFERENCE_THRESHOLD) {\n            //console.log(`Imbalance White Lost, Current White: ${this._mana.white.beforecast} Current Black: ${this._mana.black.beforecast}`)\n            //If we have more than 30 Black mana over White, our White gains are halved\n            this.mana.white.imbalanceLoss = Math.ceil(white / MANA_LOST_DIVISOR);\n            this.mana.white.afterCast -= this.mana.white.imbalanceLoss;\n        }\n        if (black && this.mana.white.beforeCast - this.mana.black.beforeCast > MANA_DIFFERENCE_THRESHOLD) {\n            //console.log(`Imbalance Black Lost, Current Black: ${this._mana.black.beforecast} Current White: ${this._mana.white.beforecast}`)\n            //If we have more than 30 White mana over Black, our Black gains are halved\n            this.mana.black.imbalanceLoss = Math.ceil(black / MANA_LOST_DIVISOR);\n            this.mana.black.afterCast -= this.mana.black.imbalanceLoss;\n        }\n    }\n    calculateManaOvercap(isManafication) {\n        if (this.mana.white.afterCast > MANA_CAP) {\n            if (isManafication) {\n                this.mana.white.manaficationLoss = this.mana.white.afterCast - MANA_CAP;\n            }\n            else {\n                this.mana.white.overCapLoss = this.mana.white.afterCast - MANA_CAP;\n            }\n            this.mana.white.afterCast = MANA_CAP;\n        }\n        if (this.mana.black.afterCast > MANA_CAP) {\n            if (isManafication) {\n                this.mana.black.manaficationLoss = this.mana.black.afterCast - MANA_CAP;\n            }\n            else {\n                this.mana.black.overCapLoss = this.mana.black.afterCast - MANA_CAP;\n            }\n            this.mana.black.afterCast = MANA_CAP;\n        }\n    }\n}\nexport default class Gauge extends Module {\n    constructor(...args) {\n        super(...args);\n        //Keeps track of our current mana gauge.\n        this._whiteMana = 0;\n        this._blackMana = 0;\n        //Keeps track of overall wasted mana\n        this._whiteManaWasted = 0;\n        this._blackManaWasted = 0;\n        this._whiteManaLostToImbalance = 0;\n        this._blackManaLostToImbalance = 0;\n        this._whiteManaLostToInvulnerable = 0;\n        this._blackManaLostToInvulnerable = 0;\n        this._whiteManaLostToManafication = 0;\n        this._blackManaLostToManafication = 0;\n        // Chart handling\n        this._history = {\n            white: [],\n            black: [],\n        };\n        this.addHook('cast', {\n            by: 'player',\n            abilityId: ACTIONS.MANAFICATION.id,\n        }, this._gaugeEvent);\n        this.addHook('aoedamage', { by: 'player' }, this._gaugeEvent);\n        this.addHook('death', { to: 'player' }, this._onDeath);\n        this.addHook('complete', this._onComplete);\n    }\n    _pushToGraph() {\n        const timestamp = this.parser.currentTimestamp - this.parser.fight.start_time;\n        this._history.white.push({ t: timestamp, y: this._whiteMana });\n        this._history.black.push({ t: timestamp, y: this._blackMana });\n    }\n    _gaugeEvent(event) {\n        //If the RDM had resources going into the fight eventually we'll hit a negative number.\n        //This is very bad, so what we'll do is before we initialize the Action or any calculations we'll insure the base\n        //Inputs are at the Floor of 0.\n        if (this._whiteMana && this._whiteMana < MANA_FLOOR) {\n            this._whiteMana = MANA_FLOOR;\n        }\n        if (this._blackMana && this._blackMana < MANA_FLOOR) {\n            this._blackMana = MANA_FLOOR;\n        }\n        const gaugeAction = new GaugeAction(this._whiteMana, this._blackMana);\n        const abilityId = event.ability.guid;\n        //console.log(`White: ${this._whiteMana} Black: ${this._blackMana}`)\n        if (abilityId === ACTIONS.MANAFICATION.id) {\n            //console.log('Manafication')\n            gaugeAction.calculateManaFicationManaGained();\n            // Manafication resets movement abilities\n            this.cooldowns.resetCooldown(ACTIONS.CORPS_A_CORPS.id);\n            this.cooldowns.resetCooldown(ACTIONS.DISPLACEMENT.id);\n        }\n        else {\n            //Leaving this here, we have an issue where in an overkill returns an amount of 0\n            //But the game treats it as an ability that hit, this causes a trigger of our invuln logic\n            //Sadly removing the amount check would cause even more inaccurate information to go out.\n            //This log shows the issue with verthunder overkill of mustardseed 1 (ID 21), Verholy overkill of mustardseed 2 (ID 25)\n            //And a verthunder overkill of Titania herself.  https://www.fflogs.com/reports/FkVjcbGqBhXyNtg7/#fight=6&type=summary\n            // if (event.amount === 0) {\n            // \tconsole.log(`${JSON.stringify(event, null, 4)}`)\n            // \tconsole.log(`Cast: ${event.ability.name}, timestamp: ${this.parser.formatTimestamp(event.timestamp)}`)\n            // }\n            gaugeAction.calculateCastManaGained(event);\n        }\n        this._whiteMana = gaugeAction.mana.white.afterCast;\n        this._blackMana = gaugeAction.mana.black.afterCast;\n        this._whiteManaWasted += gaugeAction.mana.white.overCapLoss;\n        this._blackManaWasted += gaugeAction.mana.black.overCapLoss;\n        this._whiteManaLostToImbalance += gaugeAction.mana.white.imbalanceLoss;\n        this._blackManaLostToImbalance += gaugeAction.mana.black.imbalanceLoss;\n        this._whiteManaLostToInvulnerable += gaugeAction.mana.white.invulnLoss;\n        this._blackManaLostToInvulnerable += gaugeAction.mana.black.invulnLoss;\n        this._whiteManaLostToManafication += gaugeAction.mana.white.manaficationLoss;\n        this._blackManaLostToManafication += gaugeAction.mana.black.manaficationLoss;\n        if (abilityId in MANA_GAIN || abilityId === ACTIONS.MANAFICATION.id) {\n            this._pushToGraph();\n        }\n        const fabricatedEvent = {\n            ...event,\n            type: 'rdmcast',\n            mana: gaugeAction.mana,\n            missOrInvlun: gaugeAction.missOrInvuln,\n        };\n        //console.log(`${JSON.stringify(fabricatedEvent, null, 4)}`)\n        this.parser.fabricateEvent(fabricatedEvent);\n    }\n    _onDeath() {\n        this._whiteMana = 0;\n        this._blackMana = 0;\n        this._pushToGraph();\n    }\n    _onComplete() {\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.VERHOLY.icon,\n            content: <Fragment>\n\t\t\t\t\t<Trans id=\"rdm.gauge.suggestions.white-mana-wasted-content\">Ensure you don't overcap your White Mana before a combo, overcapping White Mana indicates your balance was off; and you potentially lost out on Enchanted Combo damage.  You should look to execute at 80/80 or as close to it as possible.</Trans>\n\t\t\t\t</Fragment>,\n            tiers: SEVERITY_WASTED_MANA,\n            value: this._whiteManaWasted,\n            why: <Fragment>\n\t\t\t\t\t<Trans id=\"rdm.gauge.suggestions.white-mana-wasted-why\">You lost {this._whiteManaWasted} White Mana due to capped Gauge resources</Trans>\n\t\t\t\t</Fragment>,\n        }));\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.VERHOLY.icon,\n            content: <Fragment>\n\t\t\t\t\t<Trans id=\"rdm.gauge.suggestions.white-mana-lost-content\">Ensure you don't allow a difference of more than 30 betwen mana types, you lost white Mana due to Imbalance which reduces your overall mana gain and potentially costs you one or more Enchanted Combos</Trans>\n\t\t\t\t</Fragment>,\n            tiers: SEVERITY_LOST_MANA,\n            value: this._whiteManaLostToImbalance,\n            why: <Fragment>\n\t\t\t\t\t<Trans id=\"rdm.gauge.suggestions.white-mana-lost-why\">You lost {this._whiteManaLostToImbalance} White Mana due to overage of black Mana</Trans>\n\t\t\t\t</Fragment>,\n        }));\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.VERHOLY.icon,\n            content: <Fragment>\n\t\t\t\t\t<Trans id=\"rdm.gauge.suggestions.white-mana-invuln-content\">Ensure you don't target a boss that you cannot damage with your damaging spells.  Spells that do no damage due to an invulnerable target or due to missing result in no mana gained, which potentially costs you one or more Enchanted Combos.</Trans>\n\t\t\t\t</Fragment>,\n            tiers: SEVERITY_LOST_MANA,\n            value: this._whiteManaLostToInvulnerable,\n            why: <Fragment>\n\t\t\t\t\t<Trans id=\"rdm.gauge.suggestions.white-mana-invuln-why\">You lost {this._whiteManaLostToInvulnerable} White Mana due to misses or spells that targeted an invulnerable target</Trans>\n\t\t\t\t</Fragment>,\n        }));\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.VERFLARE.icon,\n            content: <Fragment>\n\t\t\t\t\t<Trans id=\"rdm.gauge.suggestions.black-mana-wasted-content\">Ensure you don't overcap your Black Mana before a combo, overcapping Black Mana indicates your balance was off; and you potentially lost out on Enchanted Combo damage.  You should look to execute at 80/80 or as close to it as possible.</Trans>\n\t\t\t\t</Fragment>,\n            tiers: SEVERITY_WASTED_MANA,\n            value: this._blackManaWasted,\n            why: <Fragment>\n\t\t\t\t\t<Trans id=\"rdm.gauge.suggestions.black-mana-wasted-why\">You lost {this._blackManaWasted} Black Mana due to capped Gauge resources</Trans>\n\t\t\t\t</Fragment>,\n        }));\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.VERFLARE.icon,\n            content: <Fragment>\n\t\t\t\t\t<Trans id=\"rdm.gauge.suggestions.black-mana-lost-content\">Ensure you don't allow a difference of more than 30 betwen mana types, you lost Black Mana due to Imbalance which reduces your overall mana gain and potentially costs you one or more Enchanted Combos</Trans>\n\t\t\t\t</Fragment>,\n            tiers: SEVERITY_LOST_MANA,\n            value: this._blackManaLostToImbalance,\n            why: <Fragment>\n\t\t\t\t\t<Trans id=\"rdm.gauge.suggestions.black-mana-lost-why\">You lost {this._blackManaLostToImbalance} Black Mana due to overage of White Mana</Trans>\n\t\t\t\t</Fragment>,\n        }));\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.VERFLARE.icon,\n            content: <Fragment>\n\t\t\t\t\t<Trans id=\"rdm.gauge.suggestions.black-mana-invuln-content\">Ensure you don't target a boss that you cannot damage with your damaging spells.  Spells that do no damage due to an invulnerable target or due to missing result in no mana gained, which potentially costs you one or more Enchanted Combos.</Trans>\n\t\t\t\t</Fragment>,\n            tiers: SEVERITY_LOST_MANA,\n            value: this._blackManaLostToInvulnerable,\n            why: <Fragment>\n\t\t\t\t\t<Trans id=\"rdm.gauge.suggestions.black-mana-invuln-why\">You lost {this._blackManaLostToInvulnerable} Black Mana due to misses or spells that targeted an invulnerable target</Trans>\n\t\t\t\t</Fragment>,\n        }));\n        this.statistics.add(new DualStatistic({\n            label: <Trans id=\"rdm.gauge.title-mana-lost-to-manafication\">Manafication Loss:</Trans>,\n            title: <Trans id=\"rdm.gauge.white-mana-lost-to-manafication\">White</Trans>,\n            title2: <Trans id=\"rdm.gauge.black-mana-lost-to-manafication\">Black</Trans>,\n            icon: ACTIONS.VERHOLY.icon,\n            icon2: ACTIONS.VERFLARE.icon,\n            value: this._whiteManaLostToManafication,\n            value2: this._blackManaLostToManafication,\n            info: (<Trans id=\"rdm.gauge.white-mana-lost-to-manafication-statistics\">\n\t\t\t\t\t\tIt is ok to lose some mana to manafication over the course of a fight, you should however strive to keep this number as low as possible.\n\t\t\t\t\t</Trans>),\n        }));\n    }\n    output() {\n        const whm = Color(JOBS.WHITE_MAGE.colour);\n        const blm = Color(JOBS.BLACK_MAGE.colour);\n        // Disabling magic numbers for the chart, 'cus it's a chart\n        /* eslint-disable no-magic-numbers */\n        const data = {\n            datasets: [{\n                    label: 'White Mana',\n                    data: this._history.white,\n                    backgroundColor: whm.fade(0.5),\n                    borderColor: whm.fade(0.2),\n                    steppedLine: true,\n                }, {\n                    label: 'Black Mana',\n                    data: this._history.black,\n                    backgroundColor: blm.fade(0.5),\n                    borderColor: blm.fade(0.2),\n                    steppedLine: true,\n                }],\n        };\n        return <TimeLineChart data={data}/>;\n        /* eslint-enable no-magic-numbers */\n    }\n    /**\n    * Get the current White Mana as calculated from the most recent OnCast event\n    */\n    get whiteMana() {\n        return this._whiteMana;\n    }\n    /**\n    * Get the current Black Mana as calculated from the most recent OnCast event\n    */\n    get blackMana() {\n        return this._blackMana;\n    }\n}\nGauge.handle = 'gauge';\nGauge.title = t('rdm.gauge.title') `Gauge`;\nGauge.dependencies = [\n    'cooldowns',\n    'suggestions',\n    'statistics',\n];\n","import ACTIONS from 'data/ACTIONS';\nimport { enumify } from 'utilities';\n/**\n * Cast Type Methods available to RDMs\n */\nexport const CAST_TYPE = {\n    NA: 0,\n    HardCast: 1,\n    SwiftCast: 2,\n};\n/**\n * Actions that are good for DualCast usage\n */\nexport const CORRECT_GCDS = [\n    ACTIONS.VERAERO.id,\n    ACTIONS.VERTHUNDER.id,\n    ACTIONS.VERRAISE.id,\n    //Allowing globally for now, however I need to do some extra logic in relation to Scatter\n    ACTIONS.SCATTER.id,\n    ACTIONS.IMPACT.id,\n];\n/**\n * Returns the Key name of the given Value\n */\nenumify(CAST_TYPE);\n","import { t } from '@lingui/macro';\nimport { Trans, Plural } from '@lingui/react';\nimport React, { Fragment } from 'react';\nimport { Accordion } from 'semantic-ui-react';\nimport { ActionLink, StatusLink } from 'components/ui/DbLink';\nimport Rotation from 'components/ui/Rotation';\nimport { getDataBy } from 'data';\nimport ACTIONS from 'data/ACTIONS';\nimport STATUSES from 'data/STATUSES';\nimport Module from 'parser/core/Module';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport { CAST_TYPE, CORRECT_GCDS } from 'parser/jobs/rdm/modules/DualCastEnums';\n//const util = require('util')\nexport default class DualCast extends Module {\n    constructor(...args) {\n        super(...args);\n        //Default CastState\n        this._castType = CAST_TYPE.HardCast;\n        //Used to 0 out CastTimes\n        this._ctIndex = null;\n        //Specifies if the buff has been used this cast\n        this._usedCast = false;\n        //Array of historical casts to do metrics against\n        this._history = [];\n        //Faded without being used\n        this._missedDualCasts = 0;\n        //Used on anything other than Verthunder/Verareo/Verraise\n        this._wastedDualCasts = 0;\n        //The last timestamp for a change in CastType\n        this._castTypeLastChanged = null;\n        this._severityMissedDualcast = {\n            1: SEVERITY.MINOR,\n            2: SEVERITY.MEDIUM,\n            3: SEVERITY.MAJOR,\n        };\n        this._severityWastedDualcast = {\n            1: SEVERITY.MINOR,\n            3: SEVERITY.MEDIUM,\n            5: SEVERITY.MAJOR,\n        };\n        this.addHook('cast', { by: 'player' }, this._onCast);\n        this.addHook('applybuff', {\n            to: 'player',\n            abilityId: STATUSES.DUALCAST.id,\n        }, this._onGain);\n        this.addHook('removebuff', {\n            to: 'player',\n            abilityId: STATUSES.DUALCAST.id,\n        }, this._onRemove);\n        this.addHook('complete', this._onComplete);\n    }\n    _onCast(event) {\n        //TODO: Handle HardCast opener for thunder/areo properly\n        //TODO: Scatter and target counts?\n        const abilityID = event.ability.guid;\n        const action = getDataBy(ACTIONS, 'id', abilityID);\n        const castTime = action ? action.castTime : 0;\n        const invuln = this.downtime.getDowntime(this._castTypeLastChanged || 0, event.timestamp);\n        //console.log('Invuln:' + invuln)\n        //console.log(`Cast: ${event.ability.name}, timestamp: ${this.parser.formatTimestamp(event.timestamp)}`)\n        if (castTime > 0 && this._castType === CAST_TYPE.DualCast) {\n            this._ctIndex = this.castTime.set('all', 0);\n            if (!CORRECT_GCDS.includes(abilityID) && invuln === 0) {\n                this._wastedDualCasts += 1;\n                const casts = {\n                    id: abilityID,\n                    timestamp: event.timestamp,\n                    name: event.ability.name,\n                    casttype: this._castType,\n                    events: [],\n                };\n                casts.events.push(event);\n                this._history.push(casts);\n            }\n            this._usedCast = true;\n        }\n    }\n    _onGain(event) {\n        this._castType = CAST_TYPE.DualCast;\n        this._usedCast = false;\n        this._castTypeLastChanged = event.timestamp;\n    }\n    _onRemove(event) {\n        if (!this._usedCast) {\n            const invuln = this.downtime.getDowntime(this._castTypeLastChanged || 0, event.timestamp);\n            if (invuln === 0) {\n                this._missedDualCasts += 1;\n            }\n        }\n        this._castType = CAST_TYPE.HardCast;\n        if (this._ctIndex != null) {\n            this.castTime.reset(this._ctIndex);\n        }\n        this._ctIndex = null;\n        this._castTypeLastChanged = event.timestamp;\n    }\n    _onComplete() {\n        if (this._castType === CAST_TYPE.DualCast) {\n            this._castType = CAST_TYPE.HardCast;\n        }\n        //Process Wasted DualCasts\n        if (this._wastedDualCasts) {\n            this.suggestions.add(new TieredSuggestion({\n                icon: STATUSES.DUALCAST.icon,\n                content: <Trans id=\"rdm.dualcast.suggestions.wasted.content\">\n\t\t\t\t\tSpells used while <StatusLink {...STATUSES.DUALCAST}/> is up should be limited to <ActionLink {...ACTIONS.VERAERO}/>, <ActionLink {...ACTIONS.VERTHUNDER}/>, or <ActionLink {...ACTIONS.VERRAISE}/>\n\t\t\t\t</Trans>,\n                tiers: this._severityWastedDualcast,\n                value: this._wastedDualCasts,\n                why: <Trans id=\"rdm.dualcast.suggestions.wasted.why\">{this._wastedDualCasts} <Plural value={this._wastedDualCasts} one=\"Dualcast was\" other=\"Dualcasts were\"/> wasted on low cast-time spells.</Trans>,\n            }));\n        }\n        //Process Missed DualCasts\n        if (this._missedDualCasts) {\n            this.suggestions.add(new TieredSuggestion({\n                icon: STATUSES.DUALCAST.icon,\n                content: <Trans id=\"rdm.dualcast.suggestions.missed.content\">\n\t\t\t\t\tYou should avoid wasting DualCast procs entirely as it is lost potency overtime.\n\t\t\t\t</Trans>,\n                tiers: this._severityMissedDualcast,\n                value: this._missedDualCasts,\n                why: <Trans id=\"rdm.dualcast.suggestions.missed.why\">{this._missedDualCasts} <Plural value={this._missedDualCasts} one=\"Dualcast was\" other=\"Dualcasts were\"/> lost due to not casting.</Trans>,\n            }));\n        }\n    }\n    output() {\n        if (this._history.length === 0) {\n            return false;\n        }\n        const panels = this._history.map(casts => {\n            //console.log(util.inspect(casts, {showHidden: true, depth: null}))\n            return {\n                key: casts.timestamp,\n                title: {\n                    content: <Fragment>\n\t\t\t\t\t\t{this.parser.formatTimestamp(casts.timestamp)}\n\t\t\t\t\t\t&nbsp;-&nbsp;{casts.name}\n\t\t\t\t\t</Fragment>,\n                },\n                content: {\n                    content: <Rotation events={casts.events}/>,\n                },\n            };\n        });\n        return <Accordion exclusive={false} panels={panels} styled fluid/>;\n    }\n}\nDualCast.handle = 'dualCast';\nDualCast.dependencies = [\n    'castTime',\n    'downtime',\n    'suggestions',\n];\nDualCast.title = t('rdm.dualcast.title') `Dualcast`;\n","import ACTIONS from 'data/ACTIONS';\nimport { CooldownDowntime } from 'parser/core/modules/CooldownDowntime';\n// Time that Jump deems ok for a OGCD to be down : ^)\nconst DEFAULT_ALLOWED_DOWNTIME = 4000;\nexport default class GeneralCDDowntime extends CooldownDowntime {\n    constructor() {\n        super(...arguments);\n        this.defaultAllowedAverageDowntime = DEFAULT_ALLOWED_DOWNTIME;\n        this.trackedCds = [\n            // With the changes to Acceleration, we have a lot of instances where we should hold the skill.\n            // Since it's not really possible to always know when during analysis we give a blanket grace of 20 and\n            // hope that it's accurate enough\n            {\n                cooldowns: [ACTIONS.ACCELERATION],\n                allowedAverageDowntime: 20000,\n            },\n            {\n                cooldowns: [ACTIONS.SWIFTCAST],\n                firstUseOffset: 15000,\n            },\n            {\n                cooldowns: [ACTIONS.MANAFICATION],\n                firstUseOffset: 25000,\n            },\n            {\n                cooldowns: [ACTIONS.EMBOLDEN],\n                firstUseOffset: 15000,\n            },\n            {\n                cooldowns: [ACTIONS.FLECHE],\n            },\n            {\n                cooldowns: [ACTIONS.CONTRE_SIXTE],\n            },\n        ];\n    }\n}\n","import STATUS from 'data/STATUSES';\nimport { SEVERITY } from 'parser/core/modules/Suggestions';\n//For use when I refactor DualCast\nexport const SEVERITY_WASTED_PROCS = {\n    1: SEVERITY.MINOR,\n    3: SEVERITY.MEDIUM,\n    7: SEVERITY.MAJOR,\n};\nexport const SEVERITY_OVERWRITTEN_PROCS = {\n    1: SEVERITY.MINOR,\n    2: SEVERITY.MEDIUM,\n    5: SEVERITY.MAJOR,\n};\nexport const SEVERITY_INVULN_PROCS = {\n    1: SEVERITY.MINOR,\n    2: SEVERITY.MEDIUM,\n    3: SEVERITY.MAJOR,\n};\nexport const SEVERITY_MISSED_PROCS = {\n    1: SEVERITY.MINOR,\n    2: SEVERITY.MEDIUM,\n    7: SEVERITY.MAJOR,\n};\n/**\n * Procs that a RDM gains over a fight caused by the RDM themselves\n */\nexport const PROCS = [\n    STATUS.VERSTONE_READY.id,\n    STATUS.VERFIRE_READY.id,\n];\n","import { t } from '@lingui/macro';\nimport { Trans, Plural } from '@lingui/react';\nimport React, { Fragment } from 'react';\nimport { ActionLink, StatusLink } from 'components/ui/DbLink';\nimport ACTIONS from 'data/ACTIONS';\nimport STATUSES from 'data/STATUSES';\nimport Module from 'parser/core/Module';\nimport { TieredSuggestion } from 'parser/core/modules/Suggestions';\nimport { PROCS, SEVERITY_MISSED_PROCS, SEVERITY_OVERWRITTEN_PROCS, SEVERITY_INVULN_PROCS } from 'parser/jobs/rdm/modules/ProcsEnum';\nexport default class Procs extends Module {\n    constructor(...args) {\n        super(...args);\n        this._history = {};\n        this._invulnCasts = [];\n        this._castStateMap = {\n            [STATUSES.VERSTONE_READY.id]: ACTIONS.VERSTONE,\n            [STATUSES.VERFIRE_READY.id]: ACTIONS.VERFIRE,\n        };\n        this._doNotCastMap = {\n            [STATUSES.VERSTONE_READY.id]: ACTIONS.VERAERO,\n            [STATUSES.VERFIRE_READY.id]: ACTIONS.VERTHUNDER,\n        };\n        //Global timestamp tracking per Proc\n        this._currentProcs = {};\n        this._castState = null;\n        this._previousCast = null;\n        this._targetWasInvuln = false;\n        this._playerWasInDowntime = false;\n        this._lastTargetID = 0;\n        this.addHook('cast', { by: 'player' }, this._onCast);\n        this.addHook('applybuff', {\n            to: 'player',\n            abilityId: PROCS,\n        }, this._onGain);\n        this.addHook('removebuff', {\n            to: 'player',\n            abilityId: PROCS,\n        }, this._onRemove);\n        this.addHook('refreshbuff', {\n            to: 'player',\n            abilityId: PROCS,\n        }, this._onRefresh);\n        this.addHook('complete', this._onComplete);\n        this._initializeHistory();\n    }\n    _onCast(event) {\n        const abilityID = event.ability.guid;\n        const downtime = this.downtime.getDowntime(this._previousCast || 0, event.timestamp);\n        this._previousCast = event.timestamp;\n        this._playerWasInDowntime = downtime > 0;\n        this._targetWasInvuln = this.invuln.isInvulnerable(event.targetID, event.timestamp);\n        this._lastTargetID = event.targetID;\n        this._castState = abilityID;\n    }\n    _initializeHistory() {\n        if (!(STATUSES.VERFIRE_READY in this._history)) {\n            this._history[STATUSES.VERFIRE_READY.id] = {\n                overWritten: 0,\n                invuln: 0,\n                missed: 0,\n                wasted: 0,\n            };\n        }\n        if (!(STATUSES.VERSTONE_READY in this._history)) {\n            this._history[STATUSES.VERSTONE_READY.id] = {\n                overWritten: 0,\n                invuln: 0,\n                missed: 0,\n                wasted: 0,\n            };\n        }\n    }\n    _onGain(event) {\n        const statusID = event.ability.guid;\n        // Debug\n        // console.log(`Gain Status: ${STATUSES[statusID].name} Timestamp: ${event.timestamp}`)\n        //Initialize if not present\n        if (!(statusID in this._history)) {\n            this._history[statusID] = {\n                overWritten: 0,\n                invuln: 0,\n                missed: 0,\n                wasted: 0,\n            };\n        }\n        if (!(statusID in this._currentProcs)) {\n            this._currentProcs[statusID] = 0;\n        }\n        this._currentProcs[statusID] = event.timestamp;\n    }\n    _onRefresh(event) {\n        const statusID = event.ability.guid;\n        // Debug\n        // console.log(`Refresh Status: ${STATUSES[statusID].name} Timestamp: ${event.timestamp}`)\n        if (this._currentProcs[statusID] > 0) {\n            this._history[statusID].overWritten++;\n        }\n        this._currentProcs[statusID] = event.timestamp;\n    }\n    _onRemove(event) {\n        const statusID = event.ability.guid;\n        const timestamp = event.timestamp;\n        const gcdTimeDiff = event.timestamp - this.parser.fight.start_time;\n        //const lastTargetName = this.enemies.getEntity(this._lastTargetID)\n        // Debug\n        // console.log(`Remove Status: ${STATUSES[statusID].name} Timestamp: ${event.timestamp}`)\n        if (this._targetWasInvuln) {\n            // Debug\n            //console.log(`spell: ${this._castStateMap[statusID].name}, rawstamp: ${event.timestamp}, formatStamp: ${this.parser.formatTimestamp(event.timestamp)}`)\n            this._history[statusID].invuln++;\n            // const util = require('util')\n            // console.log(util.inspect(event, {showHidden: true, depth: null}))\n            //console.log(this.parser.formatTimestamp(timestamp))\n            let lastTargetName = 'Unavailable';\n            const lastTarget = this.enemies.getEntity(this._lastTargetID);\n            if (lastTarget) {\n                lastTargetName = lastTarget.name;\n            }\n            const invulnEvent = {\n                statusID,\n                gcdTimeDiff,\n                timestamp,\n                lastTargetName,\n            };\n            this._invulnCasts.push(invulnEvent);\n        }\n        else if (this._castState !== this._castStateMap[statusID].id && !this._playerWasInDowntime) {\n            this._history[statusID].missed++;\n        }\n        if (this._castState === this._castStateMap[statusID].id) {\n            //Reset this statusID!\n            this._currentProcs[statusID] = 0;\n        }\n    }\n    _onComplete() {\n        const missedFire = this._history[STATUSES.VERFIRE_READY.id].missed || 0;\n        const invulnFire = this._history[STATUSES.VERFIRE_READY.id].invuln || 0;\n        const overWrittenFire = this._history[STATUSES.VERFIRE_READY.id].overWritten || 0;\n        const missedStone = this._history[STATUSES.VERSTONE_READY.id].missed || 0;\n        const invulnStone = this._history[STATUSES.VERSTONE_READY.id].invuln || 0;\n        const overWrittenStone = this._history[STATUSES.VERSTONE_READY.id].overWritten || 0;\n        //Icons always default to the White Mana spell if black/jolt spells don't have more bad items.\n        //TODO I need to figure out a good way of excluding items that evaluated to 0 in the condensed groups.\n        //TODO Maybe I should just build a function to return the properly setup Content and Why.\n        //Fire/Stone are identical\n        this.suggestions.add(new TieredSuggestion({\n            icon: missedFire > missedStone ? ACTIONS.VERFIRE.icon : ACTIONS.VERSTONE.icon,\n            content: <Trans id=\"rdm.procs.suggestions.missed.content\">\n\t\t\t\t\tTry to use <ActionLink {...ACTIONS.VERFIRE}/> whenever you have <StatusLink {...STATUSES.VERFIRE_READY}/> or <ActionLink {...ACTIONS.VERSTONE}/> whenever you have <StatusLink {...STATUSES.VERSTONE_READY}/> to avoid losing out on mana gains\n\t\t\t</Trans>,\n            tiers: SEVERITY_MISSED_PROCS,\n            value: missedFire + missedStone,\n            why: <Trans id=\"rdm.procs.suggestions.missed.why\">\n\t\t\t\t\tYou missed <Plural value={missedFire} one=\"# Verfire proc\" other=\"# Verfire procs\"/>, and <Plural value={missedStone} one=\"# Verstone proc\" other=\"# Verstone procs\"/>.\n\t\t\t</Trans>,\n        }));\n        this.suggestions.add(new TieredSuggestion({\n            icon: overWrittenFire > overWrittenStone ? ACTIONS.VERFIRE.icon : ACTIONS.VERSTONE.icon,\n            content: <Trans id=\"rdm.procs.suggestions.overwritten.content\">\n\t\t\t\tDon't cast <ActionLink {...ACTIONS.VERTHUNDER}/> when you have <StatusLink {...STATUSES.VERFIRE_READY}/> or <ActionLink {...ACTIONS.VERAERO}/> when you have <StatusLink {...STATUSES.VERSTONE_READY}/>\n\t\t\t</Trans>,\n            tiers: SEVERITY_OVERWRITTEN_PROCS,\n            value: overWrittenFire + overWrittenStone,\n            why: <Trans id=\"rdm.procs.suggestions.overwritten.why\">\n\t\t\t\t<Plural value={overWrittenFire} one=\"# Verfire proc\" other=\"# Verfire procs\"/>, and <Plural value={overWrittenStone} one=\"# Verstone proc\" other=\"# Verstone procs\"/> were lost due to being overwritten.\n\t\t\t</Trans>,\n        }));\n        this.suggestions.add(new TieredSuggestion({\n            icon: invulnFire > invulnStone ? ACTIONS.VERFIRE.icon : ACTIONS.VERSTONE.icon,\n            content: <Trans id=\"rdm.procs.suggestions.invuln.content\">\n\t\t\t\t\tTry not to use <ActionLink {...ACTIONS.VERFIRE}/>, and <ActionLink {...ACTIONS.VERSTONE}/> while the boss is invulnerable\n\t\t\t</Trans>,\n            tiers: SEVERITY_INVULN_PROCS,\n            value: invulnFire + invulnStone,\n            why: <Trans id=\"rdm.procs.suggestions.invuln.why\">\n\t\t\t\t\tYou used <Plural value={invulnFire} one=\"# Verfire proc\" other=\"# Verfire procs\"/>, and <Plural value={invulnStone} one=\"# Verstone proc\" other=\"# Verstone procs\"/> on an invulnerable boss.\n\t\t\t</Trans>,\n        }));\n    }\n    output() {\n        const invulnEvents = this._invulnCasts;\n        if (invulnEvents.length === 0) {\n            return false;\n        }\n        //Currently we only care about Invuln points in time, this has been requested quite often in The Balance from RDMs looking over their logs\n        return <Fragment>\n\t\t\t<Trans id=\"rdm.procs.invulnlist.preface\">\n\t\t\t\tEach of the bullets below is the chronological order of procs wasted on an invulnerable boss\n\t\t\t</Trans>\n\t\t\t<ul>\n\t\t\t\t{invulnEvents.map(item => <li key={item.timestamp}>\n\t\t\t\t\t<strong>{this.parser.formatTimestamp(item.timestamp)}</strong>:&nbsp;\n\t\t\t\t\t{this._castStateMap[item.statusID].name}&nbsp;-&nbsp;<strong><Trans id=\"rdm.procs.invuln.target\">Target</Trans></strong>:&nbsp;{item.lastTargetName}\n\t\t\t\t</li>)}\n\t\t\t</ul>\n\t\t</Fragment>;\n    }\n}\nProcs.handle = 'procs';\nProcs.title = t('rdm.procs.title') `Proc Issues`;\nProcs.dependencies = [\n    'downtime',\n    'invuln',\n    'suggestions',\n    'enemies',\n];\n","import CoreCombos from 'parser/core/modules/Combos';\nimport ACTIONS from 'data/ACTIONS';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport React from 'react';\nimport { Plural, Trans } from '@lingui/react';\nexport default class Combos extends CoreCombos {\n    constructor() {\n        super(...arguments);\n        //These actions are considered a combo DERP\n        this._derpComboActions = [\n            ACTIONS.ENCHANTED_RIPOSTE.id,\n            ACTIONS.ENCHANTED_ZWERCHHAU.id,\n            ACTIONS.ENCHANTED_REDOUBLEMENT.id,\n        ];\n        this._severityDerpComboActions = {\n            1: SEVERITY.MINOR,\n            2: SEVERITY.MEDIUM,\n            3: SEVERITY.MAJOR,\n        };\n        //These actions mean you went in without enough mana\n        this._notEnoughManaActions = [\n            ACTIONS.RIPOSTE.id,\n            ACTIONS.ZWERCHHAU.id,\n            ACTIONS.REDOUBLEMENT.id,\n        ];\n        this._severityNotEnoughManaActions = {\n            1: SEVERITY.MINOR,\n            2: SEVERITY.MEDIUM,\n            3: SEVERITY.MAJOR,\n        };\n        //Generics, not handled by the rest\n        this._severityGenericActions = {\n            1: SEVERITY.MINOR,\n            2: SEVERITY.MEDIUM,\n            4: SEVERITY.MAJOR,\n        };\n    }\n    //Overrides\n    addJobSpecificSuggestions(comboBreakers, uncomboedGcds) {\n        //console.log('Output is Output!')\n        if (comboBreakers.length === 0 && uncomboedGcds.length === 0) {\n            //console.log('Output with no breakers!')\n            return false;\n        }\n        //const panels = []\n        let derpComboCount = 0;\n        let notEnoughManaCount = 0;\n        if (comboBreakers.length > 0) {\n            //console.log('Breaker')\n            comboBreakers.map(breaker => {\n                // const util = require('util')\n                // console.log(util.inspect(breaker, {showHidden: true, depth: null}))\n                if (this._derpComboActions.includes(breaker.ability.guid)) {\n                    //console.log(`${derpComboCount}: derpComboCount`)\n                    derpComboCount++;\n                }\n                if (this._notEnoughManaActions.includes(breaker.ability.guid)) {\n                    //console.log(`${notEnoughManaCount}: notEnoughManaCount`)\n                    notEnoughManaCount++;\n                }\n            });\n        }\n        //Process Derped Combos\n        if (derpComboCount > 0) {\n            this.suggestions.add(new TieredSuggestion({\n                icon: ACTIONS.ENCHANTED_REDOUBLEMENT.icon,\n                why: <Plural id=\"rdm.combos.suggestions.derpcombos.why\" value={derpComboCount} one=\"# enchanted combo was lost due to using the combo skills out of order\" other=\"# enchanted combos were lost due to using the combo skills out of order\"/>,\n                content: <Trans id=\"rdm.combos.suggestions.derpcombos.content\">\n\t\t\t\t\tBe sure not to use combo actions out of order.\n\t\t\t\t</Trans>,\n                tiers: this._severityDerpComboActions,\n                value: derpComboCount,\n            }));\n        }\n        //Process Not Enough Mana Combos\n        if (notEnoughManaCount > 0) {\n            this.suggestions.add(new TieredSuggestion({\n                icon: ACTIONS.SCORCH.icon,\n                why: <Plural id=\"rdm.combos.suggestions.notenoughmanacombos.why\" value={notEnoughManaCount} one=\"# enchanted combo was lost due to entering the combo before having enough mana\" other=\"# enchanted combos were lost due to entering the combo before having enough mana\"/>,\n                content: <Trans id=\"rdm.combos.suggestions.notenoughmanacombos.content\">\n\t\t\t\t\tBe sure not to enter your combo before having 80|80 mana\n\t\t\t\t</Trans>,\n                tiers: this._severityNotEnoughManaActions,\n                value: notEnoughManaCount,\n            }));\n        }\n        const theRest = comboBreakers.length + uncomboedGcds.length - derpComboCount - notEnoughManaCount;\n        //console.log(`TheRest: ${theRest}`)\n        //Process The Rest\n        if (theRest > 0) {\n            this.suggestions.add(new TieredSuggestion({\n                icon: ACTIONS.ENCHANTED_REDOUBLEMENT.icon,\n                why: <Plural id=\"rdm.combos.suggestions.therestcombos.why\" value={theRest} one=\"# enchanted combo was lost due to general combo breakage or combo timing out\" other=\"# enchanted combos were lost due to general combo breakage or combo timing out\"/>,\n                content: <Trans id=\"rdm.combos.suggestions.therestcombos.content\">\n\t\t\t\t\tDo not allow your combo to timeout or use GCD Skills or Manafication during your enchanted combos\n\t\t\t\t</Trans>,\n                tiers: this._severityGenericActions,\n                value: theRest,\n            }));\n        }\n        return true;\n    }\n}\n// Overrides\nCombos.suggestionIcon = ACTIONS.ENCHANTED_REDOUBLEMENT.icon;\n","import React from 'react';\n//import CoreCombos from 'parser/core/modules/Combos'\nimport { ActionLink, StatusLink } from 'components/ui/DbLink';\nimport { getDataBy } from 'data';\nimport STATUSES from 'data/STATUSES';\nimport ACTIONS from 'data/ACTIONS';\nimport Module from 'parser/core/Module';\nimport { SEVERITY, TieredSuggestion } from 'parser/core/modules/Suggestions';\n//import {matchClosestLower} from 'utilities'\nimport { Button, Table } from 'semantic-ui-react';\nimport Rotation from 'components/ui/Rotation';\nimport { Plural, Trans } from '@lingui/react';\nimport { formatDuration } from 'utilities';\nimport { MANA_GAIN, MANA_CAP, MANA_DIFFERENCE_THRESHOLD } from './Gauge';\n//const util = require('util')\nconst FINISHERS = [\n    ACTIONS.VERHOLY,\n    ACTIONS.VERFLARE,\n];\nconst SEVERITY_WASTED_FINISHER = {\n    1: SEVERITY.MINOR,\n    2: SEVERITY.MEDIUM,\n    3: SEVERITY.MAJOR,\n};\nconst IGNORE_FINISHER_PROCS_MANA_LOSS_THRESHOLD = 4;\nconst WHITE_MANA_ACTIONS = {\n    proc: ACTIONS.VERSTONE,\n    dualcast: ACTIONS.VERAERO,\n    finisher: ACTIONS.VERHOLY,\n};\nconst BLACK_MANA_ACTIONS = {\n    proc: ACTIONS.VERFIRE,\n    dualcast: ACTIONS.VERTHUNDER,\n    finisher: ACTIONS.VERFLARE,\n};\n// 4 seconds for 2 GCDs minus a 1 second window to activate before finisher\nconst DELAY_ACCELERATION_AVAILABLE_THRESHOLD = 4;\nexport default class MeleeCombos extends Module {\n    constructor(...args) {\n        super(...args);\n        this._meleeCombos = {};\n        //Finisher Handling\n        this._incorrectFinishers = {\n            verholy: 0,\n            verflare: 0,\n            delay: 0,\n        };\n        this.addHook('cast', {\n            by: 'player',\n            abilityId: ACTIONS.ACCELERATION.id,\n        }, this._onCast);\n        this.addHook('rdmcast', { by: 'player' }, this._onCast);\n        this.addHook('death', { to: 'player' }, this._onDeath);\n        this.addHook('complete', this._onComplete);\n    }\n    _startCombo(event) {\n        this._currentCombo = {\n            start: event.timestamp,\n            startMana: {\n                white: event.mana.white.beforeCast,\n                black: event.mana.black.beforeCast,\n            },\n            startProcs: {\n                verstone: this.combatants.selected.hasStatus(STATUSES.VERSTONE_READY.id),\n                verfire: this.combatants.selected.hasStatus(STATUSES.VERFIRE_READY.id),\n                acceleration: this.combatants.selected.hasStatus(STATUSES.ACCELERATION.id),\n            },\n            events: [event],\n            lastAction: event,\n        };\n    }\n    _breakComboIfExists() {\n        if (this._currentCombo) {\n            this._currentCombo.broken = true;\n            this._endCombo();\n        }\n    }\n    _endCombo() {\n        this._meleeCombos[this._currentCombo.start] = this._currentCombo;\n        delete this._currentCombo;\n    }\n    _handleFinisher() {\n        const combo = this._currentCombo;\n        combo.finisher.recommendedActions = [];\n        combo.finisher.recommendation = '';\n        const whiteState = {\n            amount: combo.startMana.white,\n            procReady: combo.startProcs.verstone,\n            actions: WHITE_MANA_ACTIONS,\n        };\n        const blackState = {\n            amount: combo.startMana.black,\n            procReady: combo.startProcs.verfire,\n            actions: BLACK_MANA_ACTIONS,\n        };\n        let recommendedFinisher = null;\n        if (combo.startMana.white < combo.startMana.black) {\n            recommendedFinisher = this._outOfBalanceFinisher(whiteState, blackState);\n        }\n        else if (combo.startMana.black < combo.startMana.white) {\n            recommendedFinisher = this._outOfBalanceFinisher(blackState, whiteState);\n        }\n        else {\n            recommendedFinisher = this._inBalanceFinisher(blackState, whiteState);\n        }\n        if (recommendedFinisher instanceof Array) {\n            if (recommendedFinisher === FINISHERS) {\n                // a recommendation of both finishers means ignore the finisher, either one is valid\n                combo.finisher.recommendedActions.push(getDataBy(ACTIONS, 'id', combo.finisher.used.guid) || {});\n            }\n            else {\n                // a recommendation of an array of actions is to delay the combo\n                Array.prototype.push.apply(combo.finisher.recommendedActions, recommendedFinisher);\n                this._incorrectFinishers.delay++;\n                combo.finisher.recommendation = <Trans id=\"rdm.meleecombos.recommendation.delay\">Delay your melee combo to guarantee a proc from your finisher, if you will lose {IGNORE_FINISHER_PROCS_MANA_LOSS_THRESHOLD} or less mana to overcapping.</Trans>;\n            }\n        }\n        else {\n            // A specific finisher was recommended\n            combo.finisher.recommendedActions.push(recommendedFinisher);\n            if (combo.finisher.used.guid !== recommendedFinisher.id) {\n                // wrong finisher was used, add an incorrect finisher tally\n                if (combo.finisher.used.guid === ACTIONS.VERHOLY.id) {\n                    this._incorrectFinishers.verholy++;\n                }\n                if (combo.finisher.used.guid === ACTIONS.VERFLARE.id) {\n                    this._incorrectFinishers.verflare++;\n                }\n                combo.finisher.recommendation = <Trans id=\"rdm.meleecombos.recommendation.incorrect\">See the suggestions section for finisher guidelines.</Trans>;\n            }\n        }\n    }\n    _outOfBalanceFinisher(lowerManaState, higherManaState) {\n        const isAccelerationUp = this.combatants.selected.hasStatus(STATUSES.ACCELERATION.id);\n        if (!lowerManaState.procReady) {\n            // no proc of the lower mana spell, use that finisher\n            return lowerManaState.actions.finisher;\n        }\n        const comboDelayResults = this._manaLossToDelayCombo(lowerManaState, higherManaState);\n        if (!higherManaState.procReady) {\n            // no proc of the higher mana spell, check accleration and potential out of balance to make recommendation\n            const finisherManaGain = MANA_GAIN[higherManaState.actions.finisher.id].white || MANA_GAIN[higherManaState.actions.finisher.id].black;\n            if (higherManaState.amount - lowerManaState.amount + finisherManaGain > MANA_DIFFERENCE_THRESHOLD) {\n                // We will go out of balance if we use the finisher of the higher mana, check to see if delaying combo would have been better\n                if (comboDelayResults !== null && comboDelayResults.manaLoss <= IGNORE_FINISHER_PROCS_MANA_LOSS_THRESHOLD) {\n                    // return null (delay combo) if below threshold\n                    return comboDelayResults.finisher;\n                }\n                // Going out of balance is worse than overwriting the lowerManaProc - recommend using the lowerMana finisher to stay in balance\n                return lowerManaState.actions.finisher;\n            }\n            // We won't go out of balance if we use the finisher of the higher mana, check to see if acceleration is up\n            if (isAccelerationUp) {\n                // Acceleration is up, use higherManaFinisher\n                return higherManaState.actions.finisher;\n            }\n            // Acceleration not on, check to see if delaying combo would have been better\n            if (comboDelayResults !== null && comboDelayResults.manaLoss <= IGNORE_FINISHER_PROCS_MANA_LOSS_THRESHOLD) {\n                // return null (delay combo) if below threshold\n                return comboDelayResults.finisher;\n            }\n            // If delaying finisher isn't worthwhile, but we won't go out of balance by using the higherManaFinisher, fishing for a 20% proc is better than overwriting the existing proc\n            return higherManaState.actions.finisher;\n        }\n        // Both procs are up, check to see if delaying combo would have been better\n        if (comboDelayResults !== null && comboDelayResults.manaLoss <= IGNORE_FINISHER_PROCS_MANA_LOSS_THRESHOLD) {\n            // return null (delay combo) if below threshold\n            return comboDelayResults.finisher;\n        }\n        // return both finishers (finisher doesn't matter) if above the threshold where the mana loss from delaying outweighs benefit of forced proc\n        return FINISHERS;\n    }\n    _inBalanceFinisher(firstManaState, secondManaState) {\n        const isAccelerationUp = this.combatants.selected.hasStatus(STATUSES.ACCELERATION.id);\n        if (!isAccelerationUp || (firstManaState.procReady && secondManaState.procReady)) {\n            // Acceleration is not up or both procs are up, check to see if delaying combo would have been better\n            const comboDelayResults = this._manaLossToDelayCombo(firstManaState, secondManaState);\n            // Safeguard against null return if no valid delays were found\n            if (comboDelayResults !== null && comboDelayResults.manaLoss <= IGNORE_FINISHER_PROCS_MANA_LOSS_THRESHOLD) {\n                // return null (delay combo) if below threshold\n                return comboDelayResults.finisher;\n            }\n        }\n        // Acceleration is up or delaying combo is not better, return finisher of proc that isn't available (fishing for 20% is better than overwriting a proc or delaying)\n        if (!firstManaState.procReady && !secondManaState.procReady) {\n            // Neither proc is up - return both finishers (finisher doesn't matter)\n            return FINISHERS;\n        }\n        if (!firstManaState.procReady) {\n            return firstManaState.actions.finisher;\n        }\n        if (!secondManaState.procReady) {\n            return secondManaState.actions.finisher;\n        }\n        // Both procs are up and it's not worthwhile to delay combo, return both finishers (finisher doesn't matter)\n        return FINISHERS;\n    }\n    _manaLossToDelayCombo(lowerManaState, higherManaState) {\n        const possibleDelays = [];\n        if (lowerManaState.procReady) {\n            /* Case: lowerManaProc is available, \"clear\" the proc by casting Lower Proc + Higher Dualcast\n                This case is valid whether or not the higherManaProc exists\n                Overwriting the higherManaProc with the 50% chance while dumping is no net loss of procs compared to not delaying */\n            // Net benefit: +1 proc gained (lowerMana) for effective potency of +34.8 (8 Mana)\n            let newLowerMana = lowerManaState.amount + (MANA_GAIN[lowerManaState.actions.proc.id].white || MANA_GAIN[lowerManaState.actions.proc.id].black);\n            let newHigherMana = higherManaState.amount + (MANA_GAIN[higherManaState.actions.dualcast.id].white || MANA_GAIN[higherManaState.actions.dualcast.id].black);\n            // Determine how much mana would be wasted to cap with this delay, then adjust post-delay mana totals to cap before further comparisons\n            const manaLoss = Math.max(newLowerMana - MANA_CAP, 0) + Math.max(newHigherMana - MANA_CAP, 0);\n            newLowerMana = Math.min(newLowerMana, MANA_CAP);\n            newHigherMana = Math.min(newHigherMana, MANA_CAP);\n            if (newLowerMana < newHigherMana) {\n                // The proc we just cleared is still the lower mana, valid clear option, push onto stack\n                possibleDelays.push({\n                    finisher: [lowerManaState.actions.proc, higherManaState.actions.dualcast, lowerManaState.actions.finisher],\n                    manaLoss: manaLoss,\n                });\n            }\n            else {\n                // Verify that using the finisher of the proc we just cleared won't put us out of balance at the end\n                const finisherManaGain = MANA_GAIN[lowerManaState.actions.finisher.id].white || MANA_GAIN[lowerManaState.actions.finisher.id].black;\n                if (!(newLowerMana + finisherManaGain - newHigherMana) > MANA_DIFFERENCE_THRESHOLD) {\n                    // The proc we just cleared will result in equal mana or the cleared proc being higher but without putting us out of balance, check to see if acceleration would be available\n                    const accelerationAvailable = (this.combatants.selected.hasStatus(STATUSES.ACCELERATION.id) || this.cooldowns.getCooldownRemaining(ACTIONS.ACCELERATION.id) <= DELAY_ACCELERATION_AVAILABLE_THRESHOLD);\n                    if (accelerationAvailable) {\n                        possibleDelays.push({\n                            finisher: [lowerManaState.actions.proc, higherManaState.actions.dualcast, ACTIONS.ACCELERATION, lowerManaState.actions.finisher],\n                            manaLoss: manaLoss,\n                        });\n                    }\n                }\n            }\n            if (!higherManaState.procReady) {\n                /* Case: lowerManaProc is available and higherManaProc is not, attempt to \"rebalance\" mana by casting lowerManaProc + lowerManaDualcast\n                    This is an additional and separate case to just clearing and \"wasting\" the higherManaProc in the case of both procs being up\n                    and can result in less mana loss than the lowerProc -> higherDualcast dump of the above case (e.g. when starting at 80|100) */\n                // Net benefit: +1 proc gained (higherMana) for effective potency of +34.8 (8 Mana)\n                let newLowerMana = lowerManaState.amount + (MANA_GAIN[lowerManaState.actions.proc.id].white || MANA_GAIN[lowerManaState.actions.proc.id].black) + (MANA_GAIN[lowerManaState.actions.dualcast.id].white || MANA_GAIN[lowerManaState.actions.dualcast.id].black);\n                let newHigherMana = higherManaState.amount;\n                // Determine how much mana would be wasted to cap with this delay, then adjust post-delay mana totals to cap before further comparisons\n                const manaLoss = Math.max(newLowerMana - MANA_CAP, 0) + Math.max(newHigherMana - MANA_CAP, 0);\n                newLowerMana = Math.min(newLowerMana, MANA_CAP);\n                newHigherMana = Math.min(newHigherMana, MANA_CAP);\n                if (newHigherMana < newLowerMana) {\n                    // Mana rebalancing resulted in the original higherMana becoming the lower total (guaranteed proc), valid option, push onto stack\n                    possibleDelays.push({\n                        finisher: [lowerManaState.actions.proc, lowerManaState.actions.dualcast, higherManaState.actions.finisher],\n                        manaLoss: manaLoss,\n                    });\n                }\n                else {\n                    // Verify that using the finisher of higherMana won't put us out of balance at the end\n                    const finisherManaGain = MANA_GAIN[higherManaState.actions.finisher.id].white || MANA_GAIN[higherManaState.actions.finisher.id].black;\n                    if (!((newHigherMana + finisherManaGain - newLowerMana) > MANA_DIFFERENCE_THRESHOLD)) {\n                        // This is a net gain whether or not acceleration would be available - we can now fish for an additional proc of higherMana, push onto stack\n                        possibleDelays.push({\n                            finisher: [lowerManaState.actions.proc, lowerManaState.actions.dualcast, ACTIONS.ACCELERATION, higherManaState.actions.finisher],\n                            manaLoss: manaLoss,\n                        });\n                    }\n                }\n            }\n        }\n        else {\n            // These cases should only be hit if lowerMana == higherMana (we were in balance at start of combo), to test benefits of delaying combo to imbalance mana\n            // If lowerManaProc isn't available and lowerMana < higherMana, recommendation will always be the lowerManaActions.finisher\n            if (higherManaState.procReady) { // eslint-disable-line no-lonely-if\n                let newLowerMana = lowerManaState.amount + (MANA_GAIN[lowerManaState.actions.dualcast.id].white || MANA_GAIN[lowerManaState.actions.dualcast.id].black);\n                let newHigherMana = higherManaState.amount + (MANA_GAIN[higherManaState.actions.proc.id].white || MANA_GAIN[higherManaState.actions.proc.id].black);\n                // Determine how much mana would be wasted to cap with this delay, then adjust post-delay mana totals to cap before further comparisons\n                const manaLoss = Math.max(newLowerMana - MANA_CAP, 0) + Math.max(newHigherMana - MANA_CAP, 0);\n                newLowerMana = Math.min(newLowerMana, MANA_CAP);\n                newHigherMana = Math.min(newHigherMana, MANA_CAP);\n                if (newHigherMana < newLowerMana) {\n                    // Mana rebalancing resulted in the original higherMana becoming the lower total (guaranteed proc), valid option, push onto stack\n                    possibleDelays.push({\n                        finisher: [higherManaState.actions.proc, lowerManaState.actions.dualcast, higherManaState.actions.finisher],\n                        manaLoss: manaLoss,\n                    });\n                }\n            }\n            else {\n                // Neither proc is up, check with using Jolt  + higherMana's dualcast spell to delay so that lowerMana will get guaranteed proc\n                let newLowerMana = lowerManaState.amount + MANA_GAIN[ACTIONS.JOLT_II.id].white;\n                let newHigherMana = higherManaState.amount + MANA_GAIN[ACTIONS.JOLT_II.id].black + (MANA_GAIN[higherManaState.actions.dualcast.id].white || MANA_GAIN[higherManaState.actions.dualcast.id].black);\n                const firstDelaySkill = ACTIONS.JOLT_II;\n                // Determine how much mana would be wasted to cap with this delay, then adjust post-delay mana totals to cap before further comparisons\n                const manaLoss = Math.max(newLowerMana - MANA_CAP, 0) + Math.max(newHigherMana - MANA_CAP, 0);\n                newLowerMana = Math.min(newLowerMana, MANA_CAP);\n                newHigherMana = Math.min(newHigherMana, MANA_CAP);\n                if (newLowerMana < newHigherMana) {\n                    // Mana rebalancing resulted in the original higherMana becoming the lower total (guaranteed proc), valid option, push onto stack\n                    possibleDelays.push({\n                        finisher: [firstDelaySkill, lowerManaState.actions.dualcast, higherManaState.actions.finisher],\n                        manaLoss: manaLoss,\n                    });\n                }\n                else {\n                    // Check if using Jolt  + lowerMana's dualcast spell to delay so that higherMana will get guaranteed proc\n                    let newLowerMana = lowerManaState.amount + MANA_GAIN[ACTIONS.JOLT_II.id].white + (MANA_GAIN[lowerManaState.actions.dualcast.id].white || MANA_GAIN[lowerManaState.actions.dualcast.id].black);\n                    let newHigherMana = higherManaState.amount + MANA_GAIN[ACTIONS.JOLT_II.id].black;\n                    const firstDelaySkill = ACTIONS.JOLT_II;\n                    // Determine how much mana would be wasted to cap with this delay, then adjust post-delay mana totals to cap before further comparisons\n                    const manaLoss = Math.max(newLowerMana - MANA_CAP, 0) + Math.max(newHigherMana - MANA_CAP, 0);\n                    newLowerMana = Math.min(newLowerMana, MANA_CAP);\n                    newHigherMana = Math.min(newHigherMana, MANA_CAP);\n                    if (newHigherMana < newLowerMana) {\n                        // Mana rebalancing resulted in the original higherMana becoming the lower total (guaranteed proc), valid option, push onto stack\n                        possibleDelays.push({\n                            finisher: [firstDelaySkill, lowerManaState.actions.dualcast, higherManaState.actions.finisher],\n                            manaLoss: manaLoss,\n                        });\n                    }\n                }\n                // End cases for delaying combo to clear procs\n            }\n        }\n        if (possibleDelays.length > 0) {\n            // At least one valid case for delaying combo was found, return the most efficient (lowest manaLoss) for consideration\n            possibleDelays.sort((a, b) => {\n                if (a.manaLoss > b.manaLoss) {\n                    return 1;\n                }\n                if (a.manaLoss < b.manaLoss) {\n                    return -1;\n                }\n                return 0;\n            });\n            return possibleDelays[0];\n        }\n        // No valid case for delaying combo was found\n        return null;\n    }\n    _onCast(event) {\n        const action = getDataBy(ACTIONS, 'id', event.ability.guid);\n        if (!action) {\n            return;\n        }\n        if (action.combo) {\n            if (action.combo.start) {\n                this._breakComboIfExists();\n                this._startCombo(event);\n            }\n            else {\n                if (!this._currentCombo) {\n                    return;\n                }\n                //console.log(util.inspect(action, {showHidden: true, depth: null}))\n                if (action.combo.from) {\n                    const fromOptions = Array.isArray(action.combo.from) ? action.combo.from : [action.combo.from];\n                    if (!fromOptions.includes(this._currentCombo.lastAction.ability.guid)) {\n                        this._currentCombo.broken = true;\n                        this._endCombo();\n                    }\n                    else {\n                        this._currentCombo.events.push(event);\n                        this._currentCombo.lastAction = event;\n                        if (action.combo.end) {\n                            this._currentCombo.finisher = {\n                                used: event.ability,\n                            };\n                            this._handleFinisher();\n                            this._endCombo();\n                        }\n                    }\n                }\n            }\n        }\n        if (action.id === ACTIONS.ACCELERATION.id) {\n            // Add Acceleration events to the current melee combo (if any) to show usage and for determining recommended finisher\n            if (this._currentCombo) {\n                this._currentCombo.events.push(event);\n            }\n        }\n        if (action.breaksCombo) {\n            this._breakComboIfExists();\n        }\n    }\n    _onDeath() {\n        // Break any current combo on death\n        this._breakComboIfExists();\n    }\n    _onComplete() {\n        // Finish any open combos\n        this._breakComboIfExists();\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.VERHOLY.icon,\n            content: <Trans id=\"rdm.gauge.suggestions.wastedverholy.content\">\n\t\t\t\tYou should use <ActionLink {...ACTIONS.VERHOLY}/> over <ActionLink {...ACTIONS.VERFLARE}/> in the following situations in order of importance\n\t\t\t\t<ol>\n\t\t\t\t\t<li>When your white mana is lower</li>\n\t\t\t\t\t<li>Your mana is even and you have <StatusLink {...STATUSES.VERFIRE_READY}/> (Use <ActionLink {...ACTIONS.ACCELERATION}/> if available!)</li>\n\t\t\t\t\t<li>White mana is higher by 9 or less and <ActionLink {...ACTIONS.ACCELERATION}/> is available with <StatusLink {...STATUSES.VERFIRE_READY}/></li>\n\t\t\t\t</ol>\n\t\t\t</Trans>,\n            why: <Plural id=\"rdm.gauge.suggestions.wastedverholy.why\" value={this._incorrectFinishers.verflare} one=\"# Verstone cast was lost due to using Verflare incorrectly\" other=\"# Verstone casts were lost due to using Verflare incorrectly\"/>,\n            tiers: SEVERITY_WASTED_FINISHER,\n            value: this._incorrectFinishers.verflare,\n        }));\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.VERFLARE.icon,\n            content: <Trans id=\"rdm.gauge.suggestions.wastedverflare.content\">\n\t\t\t\tYou should use <ActionLink {...ACTIONS.VERFLARE}/> over <ActionLink {...ACTIONS.VERHOLY}/> in the following situations in order of importance\n\t\t\t\t<ol>\n\t\t\t\t\t<li>When your black mana is lower</li>\n\t\t\t\t\t<li>Your mana is even and you have <StatusLink {...STATUSES.VERSTONE_READY}/> (Use <ActionLink {...ACTIONS.ACCELERATION}/> if available!)</li>\n\t\t\t\t\t<li>Black mana is higher by 9 or less and <ActionLink {...ACTIONS.ACCELERATION}/> is available with <StatusLink {...STATUSES.VERSTONE_READY}/></li>\n\t\t\t\t</ol>\n\t\t\t</Trans>,\n            why: <Plural id=\"rdm.gauge.suggestions.wastedverflare.why\" value={this._incorrectFinishers.verholy} one=\"# Verfire cast was lost due to using Verholy incorrectly\" other=\"# Verfire casts were lost due to using Verholy incorrectly\"/>,\n            tiers: SEVERITY_WASTED_FINISHER,\n            value: this._incorrectFinishers.verholy,\n        }));\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.VERSTONE.icon,\n            content: <Trans id=\"rdm.gauge.suggestions.wastedprocs.content\">\n\t\t\t\tDo not enter your combo with your finisher's proc up when <ActionLink {...ACTIONS.ACCELERATION}/> is down, consider dumping a proc before entering the melee combo as long as you waste less than 8 mana to overcapping\n\t\t\t</Trans>,\n            why: <Plural id=\"rdm.gauge.suggestions.wastedprocs.why\" value={this._incorrectFinishers.delay} one=\"# Proc cast was lost due to entering the melee combo with the finisher proc up.\" other=\"# Procs casts were lost due to entering the melee combo with the finisher proc up.\"/>,\n            tiers: SEVERITY_WASTED_FINISHER,\n            value: this._incorrectFinishers.delay,\n        }));\n    }\n    output() {\n        return (<Table compact unstackable celled>\n\t\t\t\t<Table.Header>\n\t\t\t\t\t<Table.Row>\n\t\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t\t<strong><Trans id=\"rdm.meleecombos.table.header.time\">Time</Trans></strong>\n\t\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t\t<strong><Trans id=\"rdm.meleecombos.table.header.starting-mana\">Starting Mana</Trans></strong>\n\t\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t\t<strong><Trans id=\"rdm.meleecombos.table.header.starting-procs\">Starting Procs</Trans></strong>\n\t\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t\t<strong><Trans id=\"rdm.meleecombos.table.header.rotation\">Rotation</Trans></strong>\n\t\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t\t<Table.HeaderCell>\n\t\t\t\t\t\t\t<strong><Trans id=\"rdm.meleecombos.table.header.recommended\">Recommended</Trans></strong>\n\t\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t</Table.Row>\n\t\t\t\t</Table.Header>\n\t\t\t\t<Table.Body>\n\t\t\t\t\t{Object.keys(this._meleeCombos).map(timestamp => {\n            //console.log(util.inspect(timestamp, {showHidden: true, depth: null}))\n            const combo = this._meleeCombos[timestamp];\n            const white = combo.startMana.white;\n            const black = combo.startMana.black;\n            const rotation = combo.events;\n            const start = timestamp - this.parser.fight.start_time;\n            const end = rotation[rotation.length - 1].timestamp - this.parser.fight.start_time;\n            // Prevent null reference errors with broken combos - start with empty values and load with finisher data if exists\n            const recommendedActions = (combo.finisher) ? combo.finisher.recommendedActions : [];\n            const recommendation = (combo.finisher) ? combo.finisher.recommendation : '';\n            //console.log(util.inspect(rotation, {showHidden: true, depth: null}))\n            return (<Table.Row key={timestamp}>\n\t\t\t\t\t\t\t\t<Table.Cell textAlign=\"center\">\n\t\t\t\t\t\t\t\t\t<span style={{ marginRight: 5 }}>{formatDuration(start / 1000)}</span>\n\t\t\t\t\t\t\t\t\t{<Button circular compact size=\"mini\" icon=\"time\" onClick={() => this.timeline.show(start, end)}/>}\n\t\t\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t\t\t<Table.Cell>\n\t\t\t\t\t\t\t\t\t<span style={{ whiteSpace: 'nowrap' }}>{white} White | {black} Black</span>\n\t\t\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t\t\t<Table.Cell textAlign=\"center\">\n\t\t\t\t\t\t\t\t\t<span>{Object.keys(combo.startProcs).map((key) => {\n                if (!combo.startProcs[key]) {\n                    return;\n                }\n                switch (key) {\n                    case 'verstone':\n                        return (<StatusLink key=\"verstone\" showName={false} {...STATUSES.VERSTONE_READY}/>);\n                    case 'verfire':\n                        return (<StatusLink key=\"verfire\" showName={false} {...STATUSES.VERFIRE_READY}/>);\n                    case 'acceleration':\n                        return (<StatusLink key=\"acceleration\" showName={false} {...STATUSES.ACCELERATION}/>);\n                }\n            })}</span>\n\t\t\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t\t\t<Table.Cell>\n\t\t\t\t\t\t\t\t\t<span style={{ whiteSpace: 'nowrap' }}><Rotation events={rotation}/></span>\n\t\t\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t\t\t<Table.Cell>\n\t\t\t\t\t\t\t\t\t{recommendedActions.map((action) => {\n                return (<ActionLink key={action.id} showName={false} {...action}/>);\n            })}\n\t\t\t\t\t\t\t\t\t<br />{recommendation}\n\t\t\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t\t</Table.Row>);\n        })}\n\t\t\t\t</Table.Body>\n\t\t\t</Table>);\n    }\n}\nMeleeCombos.handle = 'meleecombos';\nMeleeCombos.dependencies = [\n    'combatants',\n    'suggestions',\n    'cooldowns',\n    'timeline',\n];\nMeleeCombos.title = 'Melee Combos';\n","import { t } from '@lingui/macro';\nimport { Trans } from '@lingui/react';\nimport React, { Fragment } from 'react';\nimport { Accordion, Message } from 'semantic-ui-react';\nimport ACTIONS from 'data/ACTIONS';\nimport Rotation from 'components/ui/Rotation';\nimport Module from 'parser/core/Module';\nimport { Rule, Requirement } from 'parser/core/modules/Checklist';\nimport { ActionLink } from 'components/ui/DbLink';\nimport { getDataBy } from 'data';\nconst CACS_PER_MANAFICATION = 3;\nconst DISPS_PER_MANAFICATION = 3;\nconst ENGAGEMENTS_PER_MANAFICATION = 4;\n//This is due to the fact that manafication happens after your first cac/disp\nconst GRACE_FOR_PULL = 2;\nexport default class MovementSkills extends Module {\n    constructor(...args) {\n        super(...args);\n        this._history = [];\n        this._lastManafic = {\n            timestamp: 0,\n            cac: 0,\n            disp: 0,\n            engagement: 0,\n            events: [],\n        };\n        this.addHook('cast', {\n            by: 'player',\n            abilityId: [\n                ACTIONS.MANAFICATION.id,\n                ACTIONS.CORPS_A_CORPS.id,\n                ACTIONS.DISPLACEMENT.id,\n                ACTIONS.ENGAGEMENT.id,\n            ],\n        }, this._onCast);\n        this.addHook('complete', this._onComplete);\n        //So we don't get negative numbers on the final panel display\n        this._lastManafic.timestamp = this.parser.fight.start_time;\n    }\n    _onCast(event) {\n        const abilityID = event.ability.guid;\n        if (this._lastManafic === null) {\n            this._lastManafic = {\n                timestamp: event.timestamp,\n                cac: 0,\n                disp: 0,\n                engagement: 0,\n                events: [],\n            };\n        }\n        switch (abilityID) {\n            case ACTIONS.MANAFICATION.id:\n                //push the previous manafication instance\n                this._history.push(this._lastManafic);\n                //setup the new instance, since we're unlikely to end the fight on manafication push\n                this._lastManafic = {\n                    timestamp: event.timestamp,\n                    cac: 0,\n                    disp: 0,\n                    engagement: 0,\n                    events: [],\n                };\n                return;\n            case ACTIONS.DISPLACEMENT.id:\n                this._lastManafic.disp++;\n                break;\n            case ACTIONS.ENGAGEMENT.id:\n                this._lastManafic.engagement++;\n                break;\n            case ACTIONS.CORPS_A_CORPS.id:\n                this._lastManafic.cac++;\n                break;\n        }\n        this._lastManafic.events.push(event);\n    }\n    _onComplete() {\n        const requirements = [];\n        //Default Target to hit\n        const target = 95;\n        const description = <Trans id=\"rdm.movementskills.description\">Your movement skills are primarily used for damage, make sure you get 3 <ActionLink {...getDataBy(ACTIONS, 'id', ACTIONS.CORPS_A_CORPS.id)}/> and either 3 <ActionLink {...getDataBy(ACTIONS, 'id', ACTIONS.DISPLACEMENT.id)}/> or 4 <ActionLink {...getDataBy(ACTIONS, 'id', ACTIONS.ENGAGEMENT.id)}/> per <ActionLink {...getDataBy(ACTIONS, 'id', ACTIONS.MANAFICATION.id)}/> </Trans>;\n        this._history.push(this._lastManafic);\n        //Parse out the final numbers\n        const summary = this._history.reduce((acc, manafic) => ({\n            manafics: acc.manafics + 1,\n            cacs: acc.cacs + manafic.cac,\n            disp: acc.disp + manafic.disp,\n            engagement: acc.engagement + manafic.engagement,\n        }), {\n            cacs: 0,\n            disp: 0,\n            engagement: 0,\n            manafics: 0,\n        });\n        //Credit for what you did since there was no final Manafication as boss died in nearly every instance\n        //Also need to credit for there being no manafic on the opener, so you aren't dinged\n        //Over the opening cac/disp\n        //TODO: Consider coming up with Logic to detect if we came off CD right at the end or not, if we did -1 else -2\n        summary.manafics = summary.manafics - 2;\n        requirements.push(this._checkCac(summary.cacs, summary.manafics, ACTIONS.CORPS_A_CORPS.id));\n        requirements.push(this._checkDisp(summary.disp, summary.engagement, ACTIONS.DISPLACEMENT.id, summary.manafics));\n        //new Rule and adds the array of Requirements that just got generated\n        this.checklist.add(new Rule({\n            name: <Trans id=\"rdm.movementSkills.use-movement-cds\">Use your Movement Skills</Trans>,\n            description: description,\n            requirements: requirements,\n            target: target,\n        }));\n    }\n    _checkCac(cacs, manafics, id) {\n        let threshold = manafics * CACS_PER_MANAFICATION;\n        let finalValue = 0;\n        threshold -= GRACE_FOR_PULL;\n        if (cacs > threshold) {\n            finalValue = 100;\n        }\n        else {\n            finalValue = cacs / threshold * 100;\n        }\n        return new Requirement({\n            name: <ActionLink {...getDataBy(ACTIONS, 'id', id)}/>,\n            percent: finalValue,\n        });\n    }\n    _checkDisp(disps, engagements, dispID, manafics) {\n        let finalValue = 0;\n        if (!disps) {\n            disps = 0;\n        }\n        if ((disps / DISPS_PER_MANAFICATION) === manafics || (engagements / ENGAGEMENTS_PER_MANAFICATION) === manafics) {\n            //100%, no fail skip the rest\n            return new Requirement({\n                name: <ActionLink {...getDataBy(ACTIONS, 'id', dispID)}/>,\n                percent: 100,\n            });\n        }\n        //Figure out how many Disps DONT fit into Displacement per manafication\n        //This means that we need to deal with combinations of disp and engagement\n        const leftoverDisps = disps % DISPS_PER_MANAFICATION;\n        //Now we need to figure out the Engagement threshold\n        //We want the manafication count to be reduced by number of manafications we fully Disped for, then multiply\n        //By how many engagement we need per minus the number of disps we had left over\n        const engagementThreshold = ((manafics - ((disps - leftoverDisps) / DISPS_PER_MANAFICATION)) * ENGAGEMENTS_PER_MANAFICATION) - leftoverDisps;\n        //This will yield us the correct amount of total casts that needed to happen weighting properly disp v engagement\n        const totalThreshold = engagementThreshold + disps;\n        //After discussing we're going to assume engagements were messed up if anything\n        //Min it so we don't get over 100% due to graces for those who manage perfect play\n        finalValue = Math.max(Math.min((((disps + engagements) / totalThreshold) * 100), 100), 0);\n        return new Requirement({\n            name: <ActionLink {...getDataBy(ACTIONS, 'id', dispID)}/>,\n            percent: finalValue,\n        });\n    }\n    output() {\n        const panels = this._history.map(manafic => {\n            return {\n                key: manafic.timestamp,\n                title: {\n                    key: 'title-' + manafic.timestamp,\n                    content: <Fragment>\n\t\t\t\t\t\t{this.parser.formatTimestamp(manafic.timestamp)}\n\t\t\t\t\t\t<span> - </span>\n\t\t\t\t\t\t{manafic.events.length} <Trans id=\"rdm.movementskills.panels.content\">Movement Skills used</Trans>\n\t\t\t\t\t</Fragment>,\n                },\n                content: {\n                    key: 'content-' + manafic.timestamp,\n                    content: <Rotation events={manafic.events}/>,\n                },\n            };\n        });\n        return <Fragment>\n\t\t\t<Message>\n\t\t\t\t<Trans id=\"rdm.movementskills.accordion.message\">The list below contains every Movement Skill used in your opener and after each <ActionLink {...getDataBy(ACTIONS, 'id', ACTIONS.MANAFICATION.id)}/></Trans>\n\t\t\t</Message>\n\t\t\t<Accordion exclusive={false} panels={panels} styled fluid/>\n\t\t</Fragment>;\n    }\n}\nMovementSkills.handle = 'movementSkills';\nMovementSkills.title = t('rdm.movementskills.title') `Movement Skills`;\nMovementSkills.dependencies = [\n    'checklist',\n];\n","import Gauge from './Gauge';\nimport Dualcast from './Dualcast';\nimport GeneralCDDowntime from './GeneralCDDowntime';\nimport Procs from './Procs';\nimport Combos from './Combos';\nimport MeleeCombos from './MeleeCombos';\nimport MovementSkills from './MovementSkills';\nexport { DualStatistic } from 'parser/jobs/rdm/statistics/DualStatistic';\nexport default [\n    Gauge,\n    Dualcast,\n    GeneralCDDowntime,\n    Procs,\n    Combos,\n    MeleeCombos,\n    MovementSkills,\n];\n"],"sourceRoot":""}
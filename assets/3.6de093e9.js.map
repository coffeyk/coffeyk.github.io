{"version":3,"sources":["webpack:///./src/components/ui/RotationTable.tsx","webpack:///./src/parser/core/Combatant.js","webpack:///./src/parser/core/modules/Combatants.js","webpack:///./src/parser/core/modules/Cooldowns.js","webpack:///./src/components/ui/TimeLineChart.js","webpack:///./src/parser/core/modules/BuffWindow.tsx","webpack:///./src/parser/core/modules/GlobalCooldown.js","webpack:///./node_modules/lodash/findLastIndex.js","webpack:///./src/parser/core/modules/Gauge/AbstractGauge.ts","webpack:///./src/parser/core/modules/Gauge/TimerGauge.ts","webpack:///./src/parser/core/modules/Gauge/Gauge.tsx","webpack:///./src/parser/core/modules/Gauge/CounterGauge.ts","webpack:///./src/parser/core/modules/Gauge/index.ts","webpack:///./node_modules/lodash/findLast.js"],"names":["RotationTable","React","Component","render","targets","notes","data","onGoto","headerTitle","this","props","compact","unstackable","celled","Header","Row","HeaderCell","collapsing","id","map","target","i","key","textAlign","header","note","Body","entry","start","targetAccessorResolver","accessor","targetsData","actual","expected","notesAccessorResolver","notesMap","TargetCell","Cell","positive","undefined","negative","end","rotation","style","marginRight","formatDuration","circular","size","icon","onClick","targetEntry","events","noteEntry","Combatant","Entity","constructor","parser","info","super","name","type","guid","Combatants","Entities","arguments","_players","getEntities","getEntity","actorId","player","report","friendlies","find","handle","Cooldowns","Module","_cooldownGroups","_currentAction","_cooldowns","_groups","actions","_buildGroups","cooldownOrder","addHook","by","_onBeginCast","_onCast","_onComplete","groups","order","length","action","getAction","_buildGroup","content","group","merge","forEach","nestedGroups","opts","ItemGroup","showNested","timeline","addGroup","event","ability","cooldown","startCooldown","cooldownGroup","startCooldownGroup","finishingCast","Object","keys","actionId","_addToTimeline","parseInt","cd","current","history","push","onGcd","use","shared","addItem","Item","timestamp","fight","start_time","src","alt","getCooldown","originActionId","filter","sharedCooldown","currentFightDuration","currentTimestamp","resetCooldown","invulnTime","reduceCooldown","reduction","setInvulnTime","previousEndTimestamp","previousCooldown","isFirst","downtime","getDowntime","getCooldownRemaining","getTimeOnCooldown","considerInvulnTime","extension","reduce","time","status","getAdjustedTimeOnCooldown","duration","maximumDuration","dependencies","DEFAULT_OPTIONS","aspectRatio","scales","xAxes","displayFormats","minute","second","millisecond","tooltipFormat","TimeLineChart","PureComponent","options","width","height","BuffWindowState","e","a","getActionCountByIds","actionsById","includes","BuffWindowModule","buffWindows","lastBuffWindow","init","onCast","onApplyBuff","onRemoveBuff","onComplete","autoAttack","activeBuffWindow","considerAction","buffStatus","startNewBuffWindow","startTime","getBaselineExpectedGCDs","buffWindow","expectedGCDs","expectedPerWindow","changeExpectedGCDsClassLogic","reduceExpectedGCDsEndOfFight","windowDurationMillis","fightTimeRemaining","end_time","gcdEstimate","globalCooldown","getEstimate","Math","ceil","getBaselineExpectedTrackedAction","changeExpectedTrackedActionClassLogic","getBuffWindowExpectedGCDs","getBuffWindowRequiredGCDsUsed","requiredGCDs","allowedGCDsById","getBuffWindowExpectedTrackedActions","getBuffWindowNotes","missedGCDs","sum","max","gcds","suggestions","add","TieredSuggestion","buffAction","suggestionContent","tiers","severityTiers","value","why","invalidGCDs","trackedActions","missedActions","trackedAction","trackedBadActions","badActions","output","rotationTargets","notesData","showName","rotationTableNotesColumnHeader","rotationData","windowStart","windowEnd","missedgcd","badgcd","show","rotationTableHeader","title","__decorate","dependency","__metadata","Data","prototype","Suggestions","Timeline","GlobalCooldown","MIN_GCD","MAX_GCD","BASE_GCD","CASTER_TAX","DEBUG_LOG_SAVED_GCDS","_castingEvent","_estimatedBaseGcd","_estimateGcdCount","_lastGcd","isInstant","gcdGroupId","normalise","byPlayer","hasBeginCast","relevantEvent","saveGcd","_debugLogSavedGcds","gcd","formatTimestamp","instant","taxed","casterTaxed","console","log","normalizedLength","speedMod","Group","_getGcdLength","estimate","statistics","SimpleStatistic","ATTACK","gcdInfo","speedmod","get","castTime","isCasterTaxed","gcdLength","round","correctedCooldown","gcdRecast","normaliseWith","normalizedGcd","bound","lengths","math","mean","mode","min","getUptime","carry","cooldownRatio","baseFindIndex","baseIteratee","toInteger","nativeMax","nativeMin","module","exports","array","predicate","fromIndex","index","AbstractGauge","_parser","Error","setParser","generateDataset","expectExist","TimerGauge","minimum","onExpiration","expirationCallback","maximum","chartOptions","chart","_addTimestampHook","_removeTimestampHook","lastKnownState","paused","remaining","delta","reset","set","refresh","expired","extend","pause","resume","hook","removeTimestampHook","addTimestampHook","endTime","relativeTimestamp","t","prev","y","chartY","timeDelta","label","color","dataSet","lineTension","chartColor","Color","backgroundColor","fade","toString","borderColor","setAddTimestampHook","setRemoveTimestampHook","Gauge","gauges","to","onDeath","gauge","bind","datasets","isDefined","CounterGauge","overCap","_value","initialValue","getValueAt","counter","modify","amount","diff","pushHistory","setMinimum","setBounds","setMaximum","NaN","pop","steppedLine","findLast","createFind"],"mappings":"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","file":"assets/3.6de093e9.js","sourcesContent":["import { Trans } from '@lingui/react';\nimport Rotation from 'components/ui/Rotation';\nimport React from 'react';\nimport { Button, Table } from 'semantic-ui-react';\nimport { formatDuration } from 'utilities';\nexport class RotationTable extends React.Component {\n    render() {\n        const { targets, notes, data, onGoto, headerTitle, } = this.props;\n        return <Table compact unstackable celled>\n\t\t\t<Table.Header>\n\t\t\t\t<Table.Row>\n\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t<strong><Trans id=\"core.ui.rotation-table.header.time\">Time</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(targets || []).map((target, i) => <Table.HeaderCell key={`target_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{target.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t\t<Table.HeaderCell>\n\t\t\t\t\t\t<strong>{(headerTitle) ? headerTitle : <Trans id=\"core.ui.rotation-table.header.rotation\">Rotation</Trans>}</strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(notes || []).map((note, i) => <Table.HeaderCell key={`note_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{note.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Header>\n\t\t\t<Table.Body>\n\t\t\t\t{data.map((entry) => <RotationTable.Row key={entry.start} onGoto={onGoto} targets={targets || []} notes={notes || []} {...entry}/>)}\n\t\t\t</Table.Body>\n\t\t</Table>;\n    }\n}\nRotationTable.targetAccessorResolver = (entry, target) => {\n    if (typeof target.accessor === 'string' && entry.targetsData != null) {\n        return entry.targetsData[target.accessor];\n    }\n    else if (typeof target.accessor === 'function') {\n        return target.accessor(entry);\n    }\n    else {\n        return {\n            actual: 0,\n            expected: 0,\n        };\n    }\n};\nRotationTable.notesAccessorResolver = (entry, note) => {\n    if (typeof note.accessor === 'string' && entry.notesMap != null) {\n        return entry.notesMap[note.accessor];\n    }\n    else if (typeof note.accessor === 'function') {\n        return note.accessor(entry);\n    }\n    else {\n        return null;\n    }\n};\nRotationTable.TargetCell = ({ actual, expected }) => <Table.Cell textAlign=\"center\" positive={expected === undefined ? false : actual >= expected} negative={expected === undefined ? false : actual < expected}>\n\t\t\t{actual}/{expected === undefined ? '-' : expected}\n\t\t</Table.Cell>;\nRotationTable.Row = ({ onGoto, targets, notes, notesMap, start, end, targetsData, rotation }) => <Table.Row>\n\t\t\t<Table.Cell textAlign=\"center\">\n\t\t\t\t<span style={{ marginRight: 5 }}>{formatDuration(start / 1000)}</span>\n\t\t\t\t{typeof onGoto === 'function' && <Button circular compact size=\"mini\" icon=\"time\" onClick={() => onGoto(start, end)}/>}\n\t\t\t</Table.Cell>\n\t\t\t{targets\n    .map(target => RotationTable.targetAccessorResolver({ start, end, targetsData, rotation }, target))\n    .map((targetEntry, i) => <RotationTable.TargetCell key={`target_${i}`} {...targetEntry}/>)}\n\t\t\t<Table.Cell>\n\t\t\t\t<Rotation events={rotation}/>\n\t\t\t</Table.Cell>\n\t\t\t{notes\n    .map(note => RotationTable.notesAccessorResolver({ start, end, targetsData, notesMap, rotation }, note))\n    .map((noteEntry, i) => <Table.Cell key={`notes_${i}`} textAlign=\"center\">\n\t\t\t\t\t\t\t{noteEntry}\n\t\t\t\t\t\t</Table.Cell>)}\n\t\t</Table.Row>;\n","import Entity from './Entity';\n// This is basically a copy of Enemy - XIV doesn't really have as much on Combatants as WoW.\n// TODO: Should I just merge all this crap into the Entity handlers and call it a day?\nexport default class Combatant extends Entity {\n    constructor(parser, info) {\n        super(parser);\n        this.info = null;\n        this.info = info;\n    }\n    get name() { return this.info.name; }\n    get type() { return this.info.type; }\n    get guid() { return this.info.guid; }\n    get id() { return this.info.id; }\n}\n","import Entities from './Entities';\nimport Combatant from '../Combatant';\nexport default class Combatants extends Entities {\n    constructor() {\n        super(...arguments);\n        this._players = {};\n    }\n    getEntities() {\n        return this._players;\n    }\n    getEntity(actorId) {\n        let player = this._players[actorId];\n        if (!player) {\n            const info = this.parser.report.friendlies.find(player => player.id === actorId);\n            if (!info) {\n                return null;\n            }\n            this._players[actorId] = player = new Combatant(this.parser, info);\n        }\n        return player;\n    }\n    get selected() {\n        return this.getEntity(this.parser.player.id);\n    }\n}\nCombatants.handle = 'combatants';\n","import _ from 'lodash';\nimport Module from 'parser/core/Module';\nimport { ItemGroup, Item } from './Timeline';\nimport React from 'react';\n// Track the cooldowns on actions and shit\nexport default class Cooldowns extends Module {\n    constructor(...args) {\n        super(...args);\n        this._cooldownGroups = {};\n        this._currentAction = null;\n        this._cooldowns = {};\n        this._groups = {};\n        this._cooldownGroups = _.groupBy(this.data.actions, 'cooldownGroup');\n        // Pre-build groups for actions explicitly set by subclasses\n        this._buildGroups(this.constructor.cooldownOrder);\n        this.addHook('begincast', { by: 'player' }, this._onBeginCast);\n        this.addHook('cast', { by: 'player' }, this._onCast);\n        this.addHook('complete', this._onComplete);\n    }\n    _buildGroups(groups) {\n        // If there's no groups, noop\n        if (!groups) {\n            return;\n        }\n        const ids = groups.map((data, i) => {\n            const order = -(groups.length - i);\n            // If it's just an action id, build a group for it and stop\n            if (typeof data === 'number') {\n                const action = this.data.getAction(data);\n                this._buildGroup({\n                    id: data,\n                    content: action && action.name,\n                    order,\n                });\n                return data;\n            }\n            // Build the base group\n            const group = this._buildGroup({\n                id: data.name,\n                content: data.name,\n                order,\n            });\n            if (data.merge) {\n                // If it's a merge group, we only need to register our group for each of the IDs\n                data.actions.forEach(id => {\n                    this._groups[id] = group;\n                });\n            }\n            else {\n                // Otherwise, build nested groups for each action\n                group.nestedGroups = this._buildGroups(data.actions);\n            }\n            return data.name;\n        });\n        return ids;\n    }\n    _buildGroup(opts) {\n        const group = new ItemGroup({ showNested: false, ...opts });\n        this.timeline.addGroup(group);\n        this._groups[opts.id] = group;\n        return group;\n    }\n    // cooldown starts at the beginning of the casttime\n    // (though 99% of CD based abilities have no cast time)\n    // TODO: Should I be tracking pet CDs too? I mean, contagion/radiant are a thing.\n    _onBeginCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.cooldown == null) {\n            return;\n        }\n        this._currentAction = action;\n        this.startCooldown(action.id);\n        if (!_.isNil(action.cooldownGroup)) {\n            this.startCooldownGroup(action.id, action.cooldownGroup);\n        }\n    }\n    _onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.cooldown == null) {\n            return;\n        }\n        const finishingCast = this._currentAction && this._currentAction.id === action.id;\n        this._currentAction = null;\n        if (finishingCast) {\n            return;\n        }\n        this.startCooldown(action.id);\n        if (!_.isNil(action.cooldownGroup)) {\n            this.startCooldownGroup(action.id, action.cooldownGroup);\n        }\n    }\n    _onComplete() {\n        Object.keys(this._cooldowns).forEach(actionId => {\n            this._addToTimeline(parseInt(actionId, 10));\n        });\n    }\n    _addToTimeline(actionId) {\n        const cd = this._cooldowns[actionId];\n        if (!cd) {\n            return false;\n        }\n        // Clean out any 'current' cooldowns into the history\n        if (cd.current) {\n            cd.history.push(cd.current);\n            cd.current = null;\n        }\n        const action = this.data.getAction(actionId);\n        // If the action is on the GCD, GlobalCooldown will be managing its own group\n        if (!action || action.onGcd) {\n            return false;\n        }\n        // Ensure we've got a group for this item\n        if (!this._groups[actionId]) {\n            this._buildGroup({\n                id: actionId,\n                content: action.name,\n                order: actionId,\n            });\n        }\n        // Add CD info to the timeline\n        cd.history\n            .forEach(use => {\n            if (!use.shared) {\n                this._groups[actionId].addItem(new Item({\n                    type: 'background',\n                    start: use.timestamp - this.parser.fight.start_time,\n                    length: use.length,\n                    content: <img src={action.icon} alt={action.name}/>,\n                }));\n            }\n        });\n        return true;\n    }\n    getCooldown(actionId) {\n        return this._cooldowns[actionId] || {\n            current: null,\n            history: [],\n        };\n    }\n    startCooldownGroup(originActionId, cooldownGroup) {\n        const sharedCooldownActions = _.get(this._cooldownGroups, cooldownGroup, []);\n        sharedCooldownActions\n            .map(action => action.id)\n            .filter(id => id !== originActionId)\n            .forEach(id => this.startCooldown(id, true));\n    }\n    startCooldown(actionId, sharedCooldown = false) {\n        // TODO: handle shared CDs\n        const action = this.data.getAction(actionId);\n        if (!action) {\n            return;\n        }\n        // Get the current cooldown status, falling back to a new cooldown\n        const cd = this.getCooldown(actionId);\n        // If there's a current object, move it into the history\n        // TODO: handle errors on CD overlap\n        if (cd.current) {\n            const currentFightDuration = this.parser.currentTimestamp - this.parser.fight.start_time;\n            if (cd.current.timestamp < this.parser.fight.start_time && cd.current.length > currentFightDuration) {\n                // Pre-pull usage, reset the cooldown to prevent overlap on timeline since we don't know exactly when cooldown was used pre-pull\n                this.resetCooldown(actionId);\n            }\n            else {\n                cd.history.push(cd.current);\n            }\n        }\n        cd.current = {\n            timestamp: this.parser.currentTimestamp,\n            length: action.cooldown * 1000,\n            shared: sharedCooldown,\n            invulnTime: 0,\n        };\n        // Save the info back out (to ensure propagation if we've got a new info)\n        this._cooldowns[actionId] = cd;\n    }\n    reduceCooldown(actionId, reduction) {\n        const cd = this.getCooldown(actionId);\n        const currentTimestamp = this.parser.currentTimestamp;\n        // Check if current isn't current\n        if (cd.current && cd.current.timestamp + cd.current.length < currentTimestamp) {\n            cd.history.push(cd.current);\n            cd.current = null;\n        }\n        // TODO: Do I need to warn if they're reducing cooldown on something _with_ no cooldown?\n        if (cd.current === null) {\n            return;\n        }\n        // Reduce the CD\n        cd.current.length -= reduction * 1000;\n        // If the reduction would have made it come off CD earlier than now, reset it - the extra time reduction should be lost.\n        if (cd.current.timestamp + cd.current.length < currentTimestamp) {\n            this.resetCooldown(actionId);\n        }\n    }\n    setInvulnTime(actionId) {\n        const cd = this.getCooldown(actionId);\n        let previousEndTimestamp = this.parser.fight.start_time;\n        let previousCooldown = {};\n        let isFirst = true;\n        for (const cooldown of cd.history) {\n            if (isFirst) {\n                previousEndTimestamp = (cooldown.timestamp + cooldown.length);\n                isFirst = false;\n                previousCooldown = cooldown;\n            }\n            //We invuln time is the time the boss was invuln from when the CD came off CD and when it was next executed\n            previousCooldown.invulnTime = this.downtime.getDowntime(previousEndTimestamp, cooldown.timestamp);\n            previousEndTimestamp = (cooldown.timestamp + cooldown.length);\n            previousCooldown = cooldown;\n        }\n    }\n    resetCooldown(actionId) {\n        const cd = this.getCooldown(actionId);\n        // If there's nothing running, we can just stop\n        // TODO: need to warn?\n        if (cd.current === null) {\n            return;\n        }\n        // Fix up the length\n        cd.current.length = this.parser.currentTimestamp - cd.current.timestamp;\n        // Move the CD into the history\n        cd.history.push(cd.current);\n        cd.current = null;\n    }\n    getCooldownRemaining(actionId) {\n        const current = this.getCooldown(actionId).current;\n        if (!current) {\n            return 0;\n        }\n        return current.length - (this.parser.currentTimestamp - current.timestamp);\n    }\n    // TODO: Should this be here?\n    getTimeOnCooldown(actionId, considerInvulnTime = false, extension = 0) {\n        const cd = this.getCooldown(actionId);\n        const currentTimestamp = this.parser.currentTimestamp;\n        if (considerInvulnTime) {\n            this.setInvulnTime(actionId);\n        }\n        else {\n            cd.history.map(cooldown => {\n                cooldown.invulnTime = 0;\n            });\n        }\n        return cd.history.reduce((time, status) => time + this.getAdjustedTimeOnCooldown(status, currentTimestamp, extension), cd.current ? this.getAdjustedTimeOnCooldown(cd.current, currentTimestamp, extension) : 0);\n    }\n    getAdjustedTimeOnCooldown(cooldown, currentTimestamp, extension) {\n        // Doesn't count time on CD outside the bounds of the current fight, it'll throw calcs off\n        // Add to the length of the cooldown any invuln time for the boss\n        // Additionally account for any extension the caller allowed to the CD Length\n        const duration = currentTimestamp - cooldown.timestamp;\n        const maximumDuration = cooldown.length + cooldown.invulnTime + extension;\n        return _.clamp(duration, 0, maximumDuration);\n    }\n    get used() {\n        return Object.keys(this._cooldowns);\n    }\n}\nCooldowns.handle = 'cooldowns';\nCooldowns.dependencies = [\n    'data',\n    'downtime',\n    'timeline',\n];\n// Array used to sort cooldowns in the timeline. Elements should be either IDs for\n// top-level groups, or objects of the format {name: string, actions: array} for\n// nested groups. Actions not specified here will be sorted by their ID below.\n// Check the NIN and SMN modules for examples.\nCooldowns.cooldownOrder = [];\n","import _ from 'lodash';\nimport PropTypes from 'prop-types';\nimport React, { PureComponent } from 'react';\nimport { Line } from 'react-chartjs-2';\nconst DEFAULT_OPTIONS = {\n    aspectRatio: 3,\n    scales: {\n        xAxes: [{\n                type: 'time',\n                time: {\n                    displayFormats: {\n                        minute: 'm:ss',\n                        second: 'm:ss',\n                        millisecond: 'm:ss.SS',\n                    },\n                    // This tooltip format displays similar to a \"relative\" timestamp,\n                    // since react assumes UNIX epoch timestamps for the data.\n                    tooltipFormat: 'mm:ss.SSS',\n                },\n            }],\n    },\n};\nexport default class TimeLineChart extends PureComponent {\n    render() {\n        const options = _.merge({}, DEFAULT_OPTIONS, this.props.options || {});\n        return <Line data={this.props.data} options={options} \n        // Using this trash 'cus aspectRatio doesn't work with the react wrapper\n        width={options.aspectRatio} height={1}/>;\n    }\n}\nTimeLineChart.propTypes = {\n    data: PropTypes.object.isRequired,\n    options: PropTypes.object,\n};\n","import { __decorate, __metadata } from \"tslib\";\nimport { t } from '@lingui/macro';\nimport { Plural, Trans } from '@lingui/react';\nimport { ActionLink } from 'components/ui/DbLink';\nimport { RotationTable } from 'components/ui/RotationTable';\nimport _ from 'lodash';\nimport Module, { dependency } from 'parser/core/Module';\nimport GlobalCooldown from 'parser/core/modules/GlobalCooldown';\nimport Suggestions, { TieredSuggestion } from 'parser/core/modules/Suggestions';\nimport Timeline from 'parser/core/modules/Timeline';\nimport React from 'react';\nimport { Data } from './Data';\nexport class BuffWindowState {\n    constructor(data, start) {\n        this.rotation = [];\n        this.data = data;\n        this.start = start;\n    }\n    get gcds() {\n        // TODO: Investigate removing the reliance on data here.\n        return this.rotation\n            .map(e => this.data.getAction(e.ability.guid))\n            .filter(a => a && a.onGcd)\n            .length;\n    }\n    getActionCountByIds(actionsById) {\n        return this.rotation\n            .filter(e => actionsById.includes(e.ability.guid))\n            .length;\n    }\n}\nexport class BuffWindowModule extends Module {\n    constructor() {\n        super(...arguments);\n        this.buffWindows = [];\n    }\n    get activeBuffWindow() {\n        const lastBuffWindow = _.last(this.buffWindows);\n        if (lastBuffWindow && lastBuffWindow.end == null) {\n            return lastBuffWindow;\n        }\n        return undefined;\n    }\n    init() {\n        this.addHook('cast', { by: 'player' }, this.onCast);\n        this.addHook('applybuff', { by: 'player' }, this.onApplyBuff);\n        this.addHook('removebuff', { by: 'player' }, this.onRemoveBuff);\n        this.addHook('complete', this.onComplete);\n    }\n    onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.autoAttack) {\n            // Disregard auto attacks for tracking rotations / events during buff windows\n            return;\n        }\n        if (this.activeBuffWindow && this.considerAction(action)) {\n            this.activeBuffWindow.rotation.push(event);\n        }\n    }\n    /**\n     * This method MAY be overridden to return true or false, indicating whether or not this action should be considered within the buff window\n     * If false is returned, the action will not be tracked AT ALL within the buff window, and will NOT appear within the Rotation column\n     * @param action\n     */\n    considerAction(action) {\n        return true;\n    }\n    onApplyBuff(event) {\n        if (!this.buffStatus || event.ability.guid !== this.buffStatus.id) {\n            return;\n        }\n        this.startNewBuffWindow(event.timestamp);\n    }\n    startNewBuffWindow(startTime) {\n        this.buffWindows.push(new BuffWindowState(this.data, startTime));\n    }\n    onRemoveBuff(event) {\n        if (!this.buffStatus || event.ability.guid !== this.buffStatus.id) {\n            return;\n        }\n        if (this.activeBuffWindow) {\n            this.activeBuffWindow.end = event.timestamp;\n        }\n    }\n    /**\n     * For consumers that have the same number of expected GCDs per window, this will use the expectedPerWindow property\n     *   on expectedGCDs as the baseline\n     * This method MAY be overridden if the logic of expected GCDs per window is variable\n     * @param buffWindow\n     */\n    getBaselineExpectedGCDs(buffWindow) {\n        if (this.expectedGCDs) {\n            return this.expectedGCDs.expectedPerWindow;\n        }\n        return 0;\n    }\n    /**\n     * This method MAY be overridden to provide class-specific rushing logic per BuffWindow - default is no effect\n     * Return a positive number to INCREASE expected GCDs for this window, or a negative number to DECREASE\n     * @param buffWindow\n     */\n    changeExpectedGCDsClassLogic(buffWindow) {\n        return 0;\n    }\n    /**\n     * Handles rushing logic to reduce expected GCDs in a window for end of fight rushing\n     * This method MAY be overridden if class rules for end of fight rushing vary\n     * @param buffWindow\n     */\n    reduceExpectedGCDsEndOfFight(buffWindow) {\n        if (this.buffStatus.duration) {\n            // Check to see if this window is rushing due to end of fight - reduce expected GCDs accordingly\n            const windowDurationMillis = this.buffStatus.duration * 1000;\n            const fightTimeRemaining = this.parser.fight.end_time - buffWindow.start;\n            if (windowDurationMillis >= fightTimeRemaining) {\n                const gcdEstimate = this.globalCooldown.getEstimate();\n                return Math.ceil((windowDurationMillis - fightTimeRemaining) / gcdEstimate);\n            }\n        }\n        // Default: no rushing reduction\n        return 0;\n    }\n    /**\n     * For consumers that have tracked actions that expect the same number of usages per window, this will use the\n     *   expectedPerWindow property on that action as the baseline\n     * This method MAY be overridden if the logic of expected tracked actions per window is variable\n     * @param buffWindow\n     * @param action\n     */\n    getBaselineExpectedTrackedAction(buffWindow, action) {\n        return action.expectedPerWindow || 0;\n    }\n    /**\n     * This method MAY be overridden to provide class-specific logic to change expected uses of a tracked action per BuffWindow - default no effect\n     * Return a positive number to INCREASE expected tracked action usages for this window, or a negative number to DECREASE\n     * @param buffWindow\n     * @param action\n     */\n    changeExpectedTrackedActionClassLogic(buffWindow, action) {\n        return 0;\n    }\n    getBuffWindowExpectedGCDs(buffWindow) {\n        return this.getBaselineExpectedGCDs(buffWindow) + this.changeExpectedGCDsClassLogic(buffWindow) - this.reduceExpectedGCDsEndOfFight(buffWindow);\n    }\n    /**\n     * This method MAY be overridden to provide class-specific logic to determine if the required GCD(s) were used during a given BuffWindow\n     * Classes whose required GCD list vary per window should override this function.\n     * Function MUST return a number of CORRECT GCDs used within the window\n     * @param buffWindow\n     */\n    getBuffWindowRequiredGCDsUsed(buffWindow) {\n        if (!this.requiredGCDs) {\n            return 0;\n        }\n        const allowedGCDsById = this.requiredGCDs.actions.map(a => a.id);\n        return buffWindow.getActionCountByIds(allowedGCDsById);\n    }\n    getBuffWindowExpectedTrackedActions(buffWindow, action) {\n        return this.getBaselineExpectedTrackedAction(buffWindow, action) + this.changeExpectedTrackedActionClassLogic(buffWindow, action);\n    }\n    /**\n     * This method will be called if and only if the rotationTableNotesColumnHeader property is set, to add a notes field for each buff window\n     * Implementing classes MUST define their logic to determine what note to display for each buff window within this method\n     * @param buffWindow\n     */\n    getBuffWindowNotes(buffWindow) {\n        return undefined;\n    }\n    onComplete() {\n        if (this.expectedGCDs) {\n            const missedGCDs = this.buffWindows\n                .reduce((sum, buffWindow) => {\n                const expectedGCDs = this.getBuffWindowExpectedGCDs(buffWindow);\n                return sum + Math.max(0, expectedGCDs - buffWindow.gcds);\n            }, 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.buffAction.icon,\n                content: this.expectedGCDs.suggestionContent,\n                tiers: this.expectedGCDs.severityTiers,\n                value: missedGCDs,\n                why: <Trans id=\"core.buffwindow.suggestions.missedgcd.why\">\n\t\t\t\t\t{missedGCDs} <Plural value={missedGCDs} one=\"GCD was\" other=\"GCDs were\"/> missed during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n        if (this.requiredGCDs) {\n            const invalidGCDs = this.buffWindows\n                .reduce((sum, buffWindow) => sum + Math.max(0, buffWindow.gcds - this.getBuffWindowRequiredGCDsUsed(buffWindow)), 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.requiredGCDs.icon,\n                content: this.requiredGCDs.suggestionContent,\n                tiers: this.requiredGCDs.severityTiers,\n                value: invalidGCDs,\n                why: <Trans id=\"core.buffwindow.suggestions.badgcd.why\">\n\t\t\t\t\t{invalidGCDs} incorrect <Plural value={invalidGCDs} one=\"GCD was\" other=\"GCDs were\"/> used during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n        if (this.trackedActions) {\n            const missedActions = this.trackedActions.actions\n                .reduce((sum, trackedAction) => sum + this.buffWindows\n                .reduce((sum, buffWindow) => sum + Math.max(0, trackedAction.expectedPerWindow - buffWindow.getActionCountByIds([trackedAction.action.id])), 0), 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.trackedActions.icon,\n                content: this.trackedActions.suggestionContent,\n                tiers: this.trackedActions.severityTiers,\n                value: missedActions,\n                why: <Trans id=\"core.buffwindow.suggestions.trackedaction.why\">\n\t\t\t\t\t<Plural value={missedActions} one=\"# use of a recommended cooldown was\" other=\"# uses of recommended cooldowns were\"/> missed during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n        if (this.trackedBadActions) {\n            const badActions = this.trackedBadActions.actions\n                .reduce((sum, trackedAction) => sum + this.buffWindows\n                .reduce((sum, buffWindow) => sum + Math.max(0, buffWindow.getActionCountByIds([trackedAction.action.id]) - trackedAction.expectedPerWindow), 0), 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.trackedBadActions.icon,\n                content: this.trackedBadActions.suggestionContent,\n                tiers: this.trackedBadActions.severityTiers,\n                value: badActions,\n                why: <Trans id=\"core.buffwindow.suggestions.trackedbadaction.why\">\n\t\t\t\t\t<Plural value={badActions} one=\"# use of\" other=\"# uses of\"/> cooldowns that should be avoided during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n    }\n    output() {\n        const rotationTargets = [];\n        const notesData = [];\n        if (this.expectedGCDs) {\n            rotationTargets.push({\n                header: <Trans id=\"core.buffwindow.table.header.gcds\">GCDs</Trans>,\n                accessor: 'missedgcd',\n            });\n        }\n        if (this.requiredGCDs) {\n            rotationTargets.push({\n                header: <img src={this.requiredGCDs.icon} alt=\"\" style={{ height: '20px' }}/>,\n                accessor: 'badgcd',\n            });\n        }\n        if (this.trackedActions) {\n            this.trackedActions.actions.forEach((trackedAction) => {\n                rotationTargets.push({\n                    header: <ActionLink showName={false} {...trackedAction.action}/>,\n                    accessor: trackedAction.action.name,\n                });\n            });\n        }\n        if (this.rotationTableNotesColumnHeader) {\n            notesData.push({\n                header: this.rotationTableNotesColumnHeader,\n                accessor: 'notes',\n            });\n        }\n        const rotationData = this.buffWindows\n            .map(buffWindow => {\n            const windowStart = buffWindow.start - this.parser.fight.start_time;\n            const windowEnd = (buffWindow.end != null ? buffWindow.end : buffWindow.start) - this.parser.fight.start_time;\n            const targetsData = {};\n            const notesMap = {};\n            if (this.expectedGCDs) {\n                targetsData.missedgcd = {\n                    actual: buffWindow.gcds,\n                    expected: this.getBuffWindowExpectedGCDs(buffWindow),\n                };\n            }\n            if (this.requiredGCDs) {\n                targetsData.badgcd = {\n                    actual: this.getBuffWindowRequiredGCDsUsed(buffWindow),\n                    expected: this.getBuffWindowExpectedGCDs(buffWindow),\n                };\n            }\n            if (this.trackedActions) {\n                this.trackedActions.actions.forEach((trackedAction) => {\n                    targetsData[trackedAction.action.name] = {\n                        actual: buffWindow.getActionCountByIds([trackedAction.action.id]),\n                        expected: this.getBuffWindowExpectedTrackedActions(buffWindow, trackedAction),\n                    };\n                });\n            }\n            if (this.rotationTableNotesColumnHeader) {\n                notesMap.notes = this.getBuffWindowNotes(buffWindow);\n            }\n            return {\n                start: windowStart,\n                end: windowEnd,\n                targetsData,\n                rotation: buffWindow.rotation,\n                notesMap,\n            };\n        });\n        return <RotationTable targets={rotationTargets} data={rotationData} notes={notesData} onGoto={this.timeline.show} headerTitle={this.rotationTableHeader}/>;\n    }\n}\nBuffWindowModule.handle = 'buffwindow';\nBuffWindowModule.title = t('core.buffwindow.title') `Buff Window`;\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Data)\n], BuffWindowModule.prototype, \"data\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Suggestions)\n], BuffWindowModule.prototype, \"suggestions\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Timeline)\n], BuffWindowModule.prototype, \"timeline\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", GlobalCooldown)\n], BuffWindowModule.prototype, \"globalCooldown\", void 0);\n","import { t } from '@lingui/macro';\nimport { Trans } from '@lingui/react';\nimport math from 'mathjsCustom';\nimport React from 'react';\nimport Module from 'parser/core/Module';\nimport { Group, Item } from './Timeline';\nimport { SimpleStatistic } from './Statistics';\nconst MIN_GCD = 1500;\nconst MAX_GCD = 2500;\nconst BASE_GCD = 2500;\nconst CASTER_TAX = 100;\nconst DEBUG_LOG_SAVED_GCDS = false && process.env.NODE_ENV !== 'production';\n// NOTE: Caster tax refers to spells taking 0.1s longer than their tooltip claims if their cast time is at least as long as their recast time.\n// See https://www.reddit.com/r/ffxiv/comments/8s05rn/the_recast_time_on_your_tooltip_can_be_up_to_85/, specifically:\n//    There is also another issue that influences how long recast times actually take that isn’t as heavily influenced by fps but is still affected,\n//    which is animation delay that happen between casts, this means that if you have a spell with a cast time that is equal to or\n//    greater than the recast time you will end up taking longer between casts than the (re)cast time. The delay is around 100 ms at 100+ fps\nexport default class GlobalCooldown extends Module {\n    constructor(...args) {\n        super(...args);\n        this._castingEvent = null;\n        this._estimatedBaseGcd = null;\n        this._estimateGcdCount = -1;\n        this._lastGcd = {\n            isInstant: false,\n            event: null,\n        };\n        this.gcds = [];\n        this.gcdGroupId = 'gcd';\n        this.addHook('complete', this._onComplete);\n    }\n    // Using normalise so the estimate can be used throughout the parse\n    normalise(events) {\n        for (let i = 0; i < events.length; i++) {\n            const event = events[i];\n            // Only care about player GCDs\n            if (!this.parser.byPlayer(event) || !event.ability) {\n                continue;\n            }\n            const action = this.data.getAction(event.ability.guid);\n            if (!action || !action.onGcd) {\n                continue;\n            }\n            // eslint-disable-next-line default-case\n            switch (event.type) {\n                // wowa uses beginchannel for this...? need info for flamethrower/that ast skill/passage of arms\n                case 'begincast':\n                    // Can I check for cancels?\n                    this._castingEvent = event;\n                    break;\n                case 'cast':\n                    const hasBeginCast = this._castingEvent !== null && this._castingEvent.ability.guid === action.id;\n                    const relevantEvent = hasBeginCast ? this._castingEvent : event;\n                    this.saveGcd({ ...this._lastGcd }, relevantEvent.timestamp); // Save last gcd with current timestamp\n                    this._lastGcd.isInstant = !hasBeginCast;\n                    this._lastGcd.event = relevantEvent;\n                    this._castingEvent = null;\n                    break;\n            }\n        }\n        if (events.length) {\n            this.saveGcd({ ...this._lastGcd }, events[events.length - 1].timestamp);\n        }\n        this._debugLogSavedGcds();\n        return events;\n    }\n    _debugLogSavedGcds() {\n        if (!DEBUG_LOG_SAVED_GCDS) {\n            return;\n        }\n        // NOTE: Please sanity-check results when changing normalise or saveGcd. Good test cases include:\n        // - Attributing 1.5s and 2.2s to correct RDM melee gcds\n        // - Sub-0.5s speedmod for BLM fast-casts and correct Instant/CasterTaxed flagging\n        // - Correct timestamp for last event before long gaps (ie: Kefka normal)\n        this.gcds.forEach((gcd) => {\n            const timestamp = this.parser.formatTimestamp(gcd.timestamp);\n            const action = this.data.getAction(gcd.actionId);\n            const instant = gcd.isInstant ? ' Instant' : '';\n            const taxed = gcd.casterTaxed ? ' CasterTaxed' : '';\n            console.log(`${timestamp} ${action.name}[${gcd.length}|${gcd.normalizedLength}] Speedmod[${gcd.speedMod}]${instant}${taxed}`);\n        });\n    }\n    _onComplete() {\n        const startTime = this.parser.fight.start_time;\n        // Timeline output\n        // TODO: Look into adding items to groups? Maybe?\n        this.timeline.addGroup(new Group({\n            id: this.gcdGroupId,\n            content: 'GCD',\n            order: -99,\n        }));\n        this.gcds.forEach(gcd => {\n            const action = this.data.getAction(gcd.actionId);\n            if (!action) {\n                return;\n            }\n            this.timeline.addItem(new Item({\n                type: 'background',\n                start: gcd.timestamp - startTime,\n                length: this._getGcdLength(gcd),\n                title: action.name,\n                group: this.gcdGroupId,\n                content: <img src={action.icon} alt={action.name} title={action.name}/>,\n            }));\n        });\n        // Statistic box\n        const estimate = this.getEstimate(false);\n        this.statistics.add(new SimpleStatistic({\n            title: <Trans id=\"core.gcd.estimated-gcd\">Estimated GCD</Trans>,\n            icon: this.data.actions.ATTACK.icon,\n            value: this.parser.formatDuration(estimate),\n            info: (<Trans id=\"core.gcd.no-statistics\">\n\t\t\t\t\tUnfortunately, player statistics are not available from FF Logs. As such, the calculated GCD length is an <em>estimate</em>, and may well be incorrect. If it is reporting a GCD length <em>longer</em> than reality, you likely need to focus on keeping your GCD rolling.\n\t\t\t\t</Trans>),\n        }));\n    }\n    //saveGcd(event, isInstant) {\n    saveGcd(gcdInfo, timestamp) {\n        if (!gcdInfo.event) {\n            return;\n        }\n        const action = this.data.getAction(gcdInfo.event.ability.guid);\n        if (!action || !action.id) {\n            return;\n        }\n        let speedMod = this.speedmod.get(gcdInfo.event.timestamp);\n        let castTime = action.castTime;\n        // HACK NOTE TODO: Need to properly account for abilities that alter only the cast or recast of attacks.\n        // Thinking of moving this into a module like speedmod, that can be called with a timestamp to grab modified base castTime/cooldown values\n        const HACK_ASTRAL_UMBRAL_SPEED_SCALAR = 0.5;\n        if (speedMod <= HACK_ASTRAL_UMBRAL_SPEED_SCALAR) {\n            speedMod /= HACK_ASTRAL_UMBRAL_SPEED_SCALAR;\n            castTime *= HACK_ASTRAL_UMBRAL_SPEED_SCALAR;\n        }\n        let isCasterTaxed = false;\n        // GCD is only to two decimal places, so round it there. Storing in Ms.\n        // eslint-disable-next-line no-magic-numbers\n        let gcdLength = Math.round((timestamp - gcdInfo.event.timestamp) / 10) * 10;\n        if (!gcdInfo.isInstant && castTime >= action.cooldown) {\n            gcdLength -= CASTER_TAX;\n            isCasterTaxed = true;\n        }\n        const correctedCooldown = action.gcdRecast != null\n            ? action.gcdRecast\n            : action.cooldown;\n        const normaliseWith = gcdInfo.isInstant || castTime < correctedCooldown\n            ? correctedCooldown\n            : castTime;\n        const normalizedGcd = Math.round(gcdLength\n            * ((BASE_GCD / 1000) / normaliseWith)\n            * (1 / speedMod));\n        this.gcds.push({\n            timestamp: gcdInfo.event.timestamp,\n            length: gcdLength,\n            normalizedLength: normalizedGcd,\n            speedMod,\n            castTime,\n            cooldown: correctedCooldown,\n            casterTaxed: isCasterTaxed,\n            actionId: action.id,\n            isInstant: gcdInfo.isInstant,\n        });\n    }\n    getEstimate(bound = true) {\n        const gcdLength = this.gcds.length;\n        // If we don't have cache, need to recaculate it\n        if (this._estimatedBaseGcd === null || gcdLength !== this._estimateGcdCount) {\n            // Calculate the lengths of the GCD\n            const lengths = this.gcds.map(gcd => gcd.normalizedLength);\n            // Mode seems to get best results. Using mean in case there's multiple modes.\n            this._estimatedBaseGcd = lengths.length ? math.mean(math.mode(lengths)) : MAX_GCD;\n            this._estimateGcdCount = gcdLength;\n        }\n        // Bound the result if requested\n        if (bound) {\n            this._estimatedBaseGcd = Math.max(MIN_GCD, Math.min(MAX_GCD, this._estimatedBaseGcd));\n        }\n        return this._estimatedBaseGcd;\n    }\n    getUptime() {\n        return this.gcds.reduce((carry, gcd) => {\n            const duration = this._getGcdLength(gcd);\n            const downtime = this.downtime.getDowntime(gcd.timestamp, gcd.timestamp + duration);\n            return carry + duration - downtime;\n        }, 0);\n    }\n    _getGcdLength(gcd) {\n        let cooldown = (gcd.isInstant || gcd.castTime <= gcd.cooldown)\n            ? gcd.cooldown\n            : Math.max(gcd.castTime, gcd.cooldown);\n        cooldown *= 1000;\n        // Some actions are lower than or equal to min gcd, only adjust with ratios when they are not\n        if (cooldown > MIN_GCD) {\n            const cooldownRatio = this.getEstimate() / MAX_GCD;\n            cooldown = Math.max(MIN_GCD, cooldown * cooldownRatio * gcd.speedMod);\n        }\n        const duration = Math.round(cooldown + (gcd.casterTaxed ? CASTER_TAX : 0));\n        return duration;\n    }\n}\nGlobalCooldown.handle = 'gcd';\nGlobalCooldown.dependencies = [\n    // We need this to normalise before us\n    'precastAction',\n    'castTime',\n    'data',\n    'downtime',\n    'speedmod',\n    'statistics',\n    'timeline',\n];\nGlobalCooldown.title = t('core.gcd.title') `Global Cooldown`;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * This method is like `_.findIndex` except that it iterates over elements\n * of `collection` from right to left.\n *\n * @static\n * @memberOf _\n * @since 2.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=array.length-1] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': true },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': false }\n * ];\n *\n * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n * // => 2\n *\n * // The `_.matches` iteratee shorthand.\n * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n * // => 0\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findLastIndex(users, ['active', false]);\n * // => 2\n *\n * // The `_.property` iteratee shorthand.\n * _.findLastIndex(users, 'active');\n * // => 0\n */\nfunction findLastIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = length - 1;\n  if (fromIndex !== undefined) {\n    index = toInteger(fromIndex);\n    index = fromIndex < 0\n      ? nativeMax(length + index, 0)\n      : nativeMin(index, length - 1);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index, true);\n}\n\nmodule.exports = findLastIndex;\n","export class AbstractGauge {\n    constructor(opts) {\n        this._parser = opts.parser;\n    }\n    /** The main parser instance. */\n    get parser() {\n        if (!this._parser) {\n            throw new Error('No parser found. Ensure this gauge is being passed to the core gauge module, or initialised with a reference to the parser.');\n        }\n        return this._parser;\n    }\n    /** Set the function used to retrieve the current timestamp. */\n    setParser(parser) {\n        this._parser = parser;\n    }\n    /** Generate a dataset suitable for use in ChartJS */\n    generateDataset() { return undefined; }\n}\n","import Color from 'color';\nimport { AbstractGauge } from './AbstractGauge';\nfunction expectExist(value) {\n    if (!value) {\n        throw new Error('Missing something required. Check the stack trace.');\n    }\n    return value;\n}\nexport class TimerGauge extends AbstractGauge {\n    constructor(opts) {\n        super(opts);\n        // Just in case I ever have to change it lmao\n        this.minimum = 0;\n        this.history = [];\n        this.onExpiration = () => {\n            if (this.expirationCallback) {\n                this.expirationCallback();\n            }\n        };\n        this.maximum = opts.maximum;\n        this.expirationCallback = opts.onExpiration;\n        this.chartOptions = opts.chart;\n    }\n    get addTimestampHook() { return expectExist(this._addTimestampHook); }\n    get removeTimestampHook() { return expectExist(this._removeTimestampHook); }\n    /** The most recent state  */\n    get lastKnownState() {\n        const { length } = this.history;\n        if (length === 0) {\n            return;\n        }\n        return this.history[length - 1];\n    }\n    /** Time currently remaining on the timer. */\n    get remaining() {\n        // If there's no known state, we have to assume there's no time left\n        if (!this.lastKnownState) {\n            return this.minimum;\n        }\n        // If we're paused, the time remaining always === specified state remaining\n        if (this.lastKnownState.paused) {\n            return this.lastKnownState.remaining;\n        }\n        const delta = this.parser.currentTimestamp - this.lastKnownState.timestamp;\n        return Math.max(this.minimum, this.lastKnownState.remaining - delta);\n    }\n    /** Whether the gauge has expired. */\n    get expired() {\n        return this.remaining <= this.minimum;\n    }\n    /** Whether the gauge is currently paused. */\n    get paused() {\n        // If there's no state, we're neither paused nor running - but safer to assume running.\n        if (!this.lastKnownState) {\n            return false;\n        }\n        return this.lastKnownState.paused;\n    }\n    /** @inheritdoc */\n    reset() {\n        this.set(this.minimum);\n    }\n    /**\n     * Start the timer from its maximum value\n     */\n    start() {\n        this.set(this.maximum);\n    }\n    /**\n     * Refresh the gauge to its maximum value.\n     * If the gauge has expired, this will have no effect.\n     */\n    refresh() {\n        if (this.expired) {\n            return;\n        }\n        this.start();\n    }\n    /**\n     * Add time to the gauge. Time over the maxium will be lost.\n     * If the gauge has edxpired, this will have no effect.\n     */\n    extend(duration) {\n        if (this.expired) {\n            return;\n        }\n        this.set(this.remaining + duration);\n    }\n    /** Pause the timer at its current state. */\n    pause() {\n        this.set(this.remaining, true);\n    }\n    /** Resume the timer from its paused state. */\n    resume() {\n        this.set(this.remaining, false);\n    }\n    /** Set the time remaining on the timer to the given duration. Value will be bounded by provided maximum. */\n    set(duration, paused = false) {\n        const timestamp = this.parser.currentTimestamp;\n        const remaining = Math.max(this.minimum, Math.min(duration, this.maximum));\n        // Push a new state onto the history\n        this.history.push({\n            timestamp,\n            remaining,\n            paused,\n        });\n        // Remove any existing hook\n        if (this.hook) {\n            this.removeTimestampHook(this.hook);\n        }\n        // If we've not yet expired, and we're not paused, set up a hook to wait for that\n        if (!paused && remaining > 0) {\n            this.hook = this.addTimestampHook(timestamp + remaining, this.onExpiration);\n        }\n    }\n    /** @inheritdoc */\n    generateDataset() {\n        // Skip charting if they've not enabled it\n        if (!this.chartOptions) {\n            return;\n        }\n        // Translate state history into a dataset that makes sense for the chart\n        const startTime = this.parser.fight.start_time;\n        const endTime = this.parser.fight.end_time;\n        const data = [];\n        this.history.forEach(entry => {\n            const relativeTimestamp = entry.timestamp - startTime;\n            // Adjust preceeding data for the start of this state's window\n            const { length } = data;\n            if (length > 0 && relativeTimestamp < data[length - 1].t) {\n                // If we're updating prior to the previous entry's expiration, update the previous entry\n                // with its state at this point in time - we'll end up with two points showing the update on\n                // this timestamp.\n                const prev = data[length - 1];\n                prev.y = (prev.y || this.minimum / 1000) + ((prev.t - relativeTimestamp) / 1000);\n                prev.t = relativeTimestamp;\n            }\n            else {\n                // This window is starting fresh, not extending - insert a blank entry so the chart doesn't\n                // render a line from the previous.\n                data.push({ t: relativeTimestamp });\n            }\n            // Insert the data point for the start of this window.\n            // Skip for pauses, as the updated previous point will represent the start point of the pause\n            const chartY = (this.minimum + entry.remaining) / 1000;\n            if (!entry.paused) {\n                data.push({\n                    t: relativeTimestamp,\n                    y: chartY,\n                });\n            }\n            // If the state isn't paused, insert a data point for the time it will expire.\n            // This data point will be updated in the event of an extension.\n            if (!entry.paused && entry.remaining > 0) {\n                const time = Math.min(relativeTimestamp + entry.remaining, endTime - startTime);\n                const timeDelta = time - relativeTimestamp;\n                data.push({\n                    t: time,\n                    y: (this.minimum + entry.remaining - timeDelta) / 1000,\n                });\n            }\n        });\n        const { label, color } = this.chartOptions;\n        const dataSet = {\n            label,\n            data,\n            lineTension: 0,\n        };\n        if (color) {\n            /* tslint:disable:no-magic-numbers */\n            const chartColor = Color(color);\n            dataSet.backgroundColor = chartColor.fade(0.8).toString();\n            dataSet.borderColor = chartColor.fade(0.5).toString();\n            /* tslint:enable:no-magic-numbers */\n        }\n        return dataSet;\n    }\n    // Junk I wish I didn't need\n    setAddTimestampHook(value) {\n        this._addTimestampHook = value;\n    }\n    setRemoveTimestampHook(value) {\n        this._removeTimestampHook = value;\n    }\n}\n","import { t } from '@lingui/macro';\nimport TimeLineChart from 'components/ui/TimeLineChart';\nimport Module from 'parser/core/Module';\nimport React from 'react';\nimport { isDefined } from 'utilities';\nimport { TimerGauge } from './TimerGauge';\nexport class Gauge extends Module {\n    constructor() {\n        super(...arguments);\n        this.gauges = [];\n    }\n    init() {\n        this.addHook('death', { to: 'player' }, this.onDeath);\n    }\n    /** Add & initialise a gauge implementation to be tracked as part of the core gauge handling. */\n    add(gauge) {\n        gauge.setParser(this.parser);\n        // TODO: Work out how to remove this. Probably also the parser, too.\n        if (gauge instanceof TimerGauge) {\n            gauge.setAddTimestampHook(this.addTimestampHook.bind(this));\n            gauge.setRemoveTimestampHook(this.removeTimestampHook.bind(this));\n        }\n        this.gauges.push(gauge);\n        return gauge;\n    }\n    onDeath(event) {\n        this.gauges.forEach(gauge => gauge.reset());\n    }\n    output() {\n        // Generate a dataset from each registered gauge\n        const datasets = this.gauges\n            .map(gauge => gauge.generateDataset())\n            .filter(isDefined);\n        if (datasets.length < 1) {\n            return false;\n        }\n        const data = { datasets };\n        return <TimeLineChart data={data}/>;\n    }\n}\nGauge.handle = 'gauge';\nGauge.title = t('core.gauge.title') `Gauge`;\n","import Color from 'color';\nimport _ from 'lodash';\nimport { AbstractGauge } from './AbstractGauge';\nexport class CounterGauge extends AbstractGauge {\n    constructor(opts = {}) {\n        super(opts);\n        this.overCap = 0;\n        this.history = [];\n        this.minimum = opts.minimum || 0;\n        this._value = opts.initialValue || this.minimum;\n        this.maximum = opts.maximum || 100;\n        this.chartOptions = opts.chart;\n    }\n    get value() {\n        return this._value;\n    }\n    getValueAt(timestamp) {\n        const counter = _.findLast(this.history, gauge => gauge.timestamp <= timestamp);\n        return counter ? counter.value : this.minimum;\n    }\n    /** @inheritdoc */\n    reset() {\n        // NOTE: This assumes counters always reset to their minimum value.\n        // Should that not be the case, probbaly needs a `resetTo` value.\n        this.set(this.minimum);\n    }\n    /** Modify the current value by the provided amount. Equivalent to `set(currentValue + amount)` */\n    modify(amount) {\n        this.set(this._value + amount);\n    }\n    /** Set the current value of the gauge. Value will automatically be bounded to valid values. Value over the maximum will be tracked as overcap. */\n    set(value) {\n        this._value = Math.min(Math.max(value, this.minimum), this.maximum);\n        // TODO: underflow means tracking was out of sync - look into backtracking to adjust history?\n        const diff = value - this._value;\n        if (diff > 0) {\n            this.overCap += diff;\n        }\n        this.pushHistory();\n    }\n    /** Set a new minimum value for the gauge. Equivalent to `setBounds(newMin, currentMax)`. */\n    setMinimum(minimum) {\n        this.setBounds(minimum, this.maximum);\n    }\n    /** Set a new maximum value for the gauge. Equivalent to `setBounds(currentMin, newMax)`. */\n    setMaximum(maximum) {\n        this.setBounds(this.minimum, maximum);\n    }\n    /** Set new bounds for the gauge. If required, the current value will be updated to remain within bounds. */\n    setBounds(minimum, maximum) {\n        this.minimum = minimum;\n        this.maximum = maximum;\n        // Ensure the value remains within bounds by re-setting it\n        this.set(this._value);\n    }\n    pushHistory() {\n        const timestamp = this.parser.currentTimestamp;\n        // Ensure we're not generating multiple entries at the samt timestamp\n        const prevTimestamp = this.history.length\n            ? this.history[this.history.length - 1].timestamp\n            : NaN;\n        if (timestamp === prevTimestamp) {\n            this.history.pop();\n        }\n        this.history.push({\n            timestamp,\n            value: this._value,\n            minimum: this.minimum,\n            maximum: this.maximum,\n        });\n    }\n    /** @inheritdoc */\n    generateDataset() {\n        // If there's no chart options, provide nothing\n        if (!this.chartOptions) {\n            return;\n        }\n        // Map the data into something the chart will understand\n        const data = this.history.map(entry => ({\n            t: entry.timestamp - this.parser.fight.start_time,\n            y: entry.value,\n        }));\n        // Build the final data set\n        const { label, color } = this.chartOptions;\n        const dataSet = {\n            label,\n            data,\n            steppedLine: true,\n        };\n        if (color) {\n            /* tslint:disable:no-magic-numbers */\n            const chartColor = Color(color);\n            dataSet.backgroundColor = chartColor.fade(0.8).toString();\n            dataSet.borderColor = chartColor.fade(0.5).toString();\n            /* tslint:enable:no-magic-numbers */\n        }\n        return dataSet;\n    }\n}\n","export { Gauge } from './Gauge';\nexport { CounterGauge } from './CounterGauge';\nexport { TimerGauge } from './TimerGauge';\n","var createFind = require('./_createFind'),\n    findLastIndex = require('./findLastIndex');\n\n/**\n * This method is like `_.find` except that it iterates over elements of\n * `collection` from right to left.\n *\n * @static\n * @memberOf _\n * @since 2.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=collection.length-1] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * _.findLast([1, 2, 3, 4], function(n) {\n *   return n % 2 == 1;\n * });\n * // => 3\n */\nvar findLast = createFind(findLastIndex);\n\nmodule.exports = findLast;\n"],"sourceRoot":""}
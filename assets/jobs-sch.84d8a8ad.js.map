{"version":3,"sources":["webpack:///./src/components/ui/RotationTable.tsx","webpack:///./src/components/ui/TimeLineChart.js","webpack:///./src/parser/core/modules/Weaving.js","webpack:///./src/parser/core/modules/GlobalCooldown.js","webpack:///./src/parser/core/modules/BuffWindow.tsx","webpack:///./src/parser/core/modules/DoTs.js","webpack:///./src/parser/jobs/sch/modules/DISPLAY_ORDER.js","webpack:///./src/parser/jobs/sch/modules/Aetherflow.js","webpack:///./src/parser/jobs/sch/modules/DoTs.js","webpack:///./src/parser/jobs/sch/modules/Weaving.js","webpack:///./src/parser/jobs/sch/modules/ChainStrat.tsx","webpack:///./src/parser/jobs/sch/modules/FaerieGauge.js","webpack:///./src/parser/jobs/sch/modules/Swiftcast.js","webpack:///./src/parser/jobs/sch/modules/Interrupts.js","webpack:///./src/parser/jobs/sch/modules/index.js"],"names":["RotationTable","React","Component","render","targets","notes","data","onGoto","headerTitle","this","props","compact","unstackable","celled","Header","Row","HeaderCell","collapsing","id","map","target","i","key","textAlign","header","note","Body","entry","start","targetAccessorResolver","accessor","targetsData","actual","expected","notesAccessorResolver","notesMap","TargetCell","Cell","positive","undefined","negative","end","rotation","style","marginRight","formatDuration","circular","size","icon","onClick","targetEntry","events","noteEntry","DEFAULT_OPTIONS","aspectRatio","scales","xAxes","type","time","displayFormats","minute","second","millisecond","tooltipFormat","TimeLineChart","PureComponent","options","width","height","DEFAULT_MAX_WEAVES","MAX_WEAVE_TIERS","0","1","2.5","WEAVING_SEVERITY","SEVERITY","MEDIUM","5","MAJOR","Weaving","Module","constructor","super","_weaves","_ongoingCastEvent","_leadingGcdEvent","_trailingGcdEvent","_badWeaves","addHook","by","_onBeginCast","_onCast","_onComplete","event","action","getAction","ability","guid","autoAttack","isOgcd","push","timestamp","_saveIfBad","badWeaves","suggestions","add","TieredSuggestion","content","href","parser","scrollTo","handle","message","title","why","length","tiers","value","leadingGcdEvent","fight","start_time","gcdTimeDiff","invuln","getUntargetableUptime","weave","trailingGcdEvent","weaves","isBadWeave","onGcd","maxWeaves","weaveCount","filter","isUntargetable","castTime","forEvent","closest","matchClosestLower","speedmod","get","gcdLength","gcd","getEstimate","output","panels","item","formatTimestamp","exclusive","styled","fluid","dependencies","MIN_GCD","MAX_GCD","BASE_GCD","CASTER_TAX","DEBUG_LOG_SAVED_GCDS","GlobalCooldown","_castingEvent","_estimatedBaseGcd","_estimateGcdCount","_lastGcd","isInstant","gcds","gcdGroupId","normalise","byPlayer","hasBeginCast","relevantEvent","saveGcd","_debugLogSavedGcds","forEach","actionId","instant","taxed","casterTaxed","console","log","name","normalizedLength","speedMod","startTime","timeline","addGroup","Group","order","addItem","Item","_getGcdLength","group","src","alt","estimate","statistics","SimpleStatistic","actions","ATTACK","info","gcdInfo","isCasterTaxed","Math","round","cooldown","correctedCooldown","gcdRecast","normaliseWith","normalizedGcd","bound","lengths","math","mean","mode","max","min","getUptime","reduce","carry","duration","downtime","getDowntime","cooldownRatio","BuffWindowState","e","a","getActionCountByIds","actionsById","includes","BuffWindowModule","arguments","buffWindows","lastBuffWindow","init","onCast","onApplyBuff","onRemoveBuff","onComplete","activeBuffWindow","considerAction","buffStatus","startNewBuffWindow","getBaselineExpectedGCDs","buffWindow","expectedGCDs","expectedPerWindow","changeExpectedGCDsClassLogic","reduceExpectedGCDsEndOfFight","windowDurationMillis","fightTimeRemaining","end_time","gcdEstimate","globalCooldown","ceil","getBaselineExpectedTrackedAction","changeExpectedTrackedActionClassLogic","getBuffWindowExpectedGCDs","getBuffWindowRequiredGCDsUsed","requiredGCDs","allowedGCDsById","getBuffWindowExpectedTrackedActions","getBuffWindowNotes","missedGCDs","sum","buffAction","suggestionContent","severityTiers","invalidGCDs","trackedActions","missedActions","trackedAction","trackedBadActions","badActions","rotationTargets","notesData","showName","rotationTableNotesColumnHeader","rotationData","windowStart","windowEnd","missedgcd","badgcd","show","rotationTableHeader","__decorate","dependency","__metadata","Data","prototype","Suggestions","Timeline","DEFAULT_DURATION_MILLIS","DoTs","_lastApplication","_clip","_statusDuration","statusesToTrack","statusId","status","getStatus","hasOwnProperty","warn","abilityId","_onDotApply","excludeApplication","addChecklistRules","addClippingSuggestions","clip","applicationKey","targetID","targetInstance","lastApplication","getInvulnerableUptime","getUptimePercent","enemies","getStatusUptime","fightDuration","getClippingAmount","fightDurationMillis","AETHERFLOW_CD_ACTIONS","ACTIONS","LUSTRATE","EXCOGITATION","INDOMITABILITY","SACRED_SOIL","SCH_ENERGY_DRAIN","RECITATION_ACTIONS","ADLOQUIUM","SUCCOR","EXTRA_AETHERFLOWS","AETHERFLOW_COOLDOWN","FIRST_FLOW_TIMESTAMP","Aetherflow","_totalAetherflowCasts","_extraAetherflows","_recitationActive","_uses","addEventHook","STATUSES","RECITATION","_onGainRecitation","_removeRecitation","to","_durationWithAetherflowOnCooldown","_possibleAetherflowCasts","floor","_updateAetherflowUses","ts","debit","DISSIPATION","checklist","Rule","AETHERFLOW","description","requirements","Requirement","percent","cooldowns","getTimeOnCooldown","aetherflows","getCooldown","history","h","dissipations","uses","totalDrift","totalWasted","Table","concat","sort","b","prev","curr","index","all","drift","nextUptime","nextCredit","nextNextCredit","currentTimestamp","wasted","Array","isArray","t","join","Grid","Column","getDataBy","colSpan","col","displayOrder","DISPLAY_ORDER","SEVERITIES","CLIPPING","6","MINOR","9","12","UPTIME","84","TARGET","WARN","94","SUCCESS","CoreDoTs","TieredRule","BIOLYSIS","clipPerMinute","10","CoreWeaving","badWeavesCount","SCH_RUIN_II","NormalisedMessage","ChainStrat","CooldownDowntime","trackedCds","CHAIN_STRATAGEM","allowedAverageDowntime","firstUseOffset","checklistDescription","SUMMON_ACTIONS","SUMMON_EOS","SUMMON_SELENE","GAUGE_GENERATORS","GAUGE_MAX","GAUGE_START","GAUGE_GAIN_AMOUNT","GRAPH_COLOR","Color","JOBS","SCHOLAR","colour","BG_COLOR_FADE","BORDER_COLOR_FADE","GAUGE_WASTE_SEVERITY","50","FaerieGauge","_gauge","_waste","_history","_fairyOut","_noFairyAtStart","FEY_UNION","_onGaugeSpend","SCH_FEY_BLESSING","_onDeath","_onGaugeGenerate","_onSummon","pet","report","friendlyPets","find","sourceID","petOwner","sourceIsFriendly","player","_updateHistory","combatants","selected","hasStatus","y","Suggestion","SUMMON_SERAPH","severity","FEY_BLESSING","datasets","label","steppedLine","backgroundColor","fade","borderColor","MISSED_SWIFTCASTS_SEVERITIES","Swiftcast","SWIFTCAST","missedSwifts","RESURRECTION","BROIL_III","TIMELINE_UPPER_MOD","INTERRUPT_SEVERITY","2","Interrupts","_currentCast","_droppedCasts","_missedTimeMS","_pushDropCasts","currentEvent","INTERJECT","cast","Button"],"mappings":"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","file":"assets/jobs-sch.84d8a8ad.js","sourcesContent":["import { Trans } from '@lingui/react';\nimport Rotation from 'components/ui/Rotation';\nimport React from 'react';\nimport { Button, Table } from 'semantic-ui-react';\nimport { formatDuration } from 'utilities';\nexport class RotationTable extends React.Component {\n    render() {\n        const { targets, notes, data, onGoto, headerTitle, } = this.props;\n        return <Table compact unstackable celled>\n\t\t\t<Table.Header>\n\t\t\t\t<Table.Row>\n\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t<strong><Trans id=\"core.ui.rotation-table.header.time\">Time</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(targets || []).map((target, i) => <Table.HeaderCell key={`target_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{target.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t\t<Table.HeaderCell>\n\t\t\t\t\t\t<strong>{(headerTitle) ? headerTitle : <Trans id=\"core.ui.rotation-table.header.rotation\">Rotation</Trans>}</strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(notes || []).map((note, i) => <Table.HeaderCell key={`note_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{note.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Header>\n\t\t\t<Table.Body>\n\t\t\t\t{data.map((entry) => <RotationTable.Row key={entry.start} onGoto={onGoto} targets={targets || []} notes={notes || []} {...entry}/>)}\n\t\t\t</Table.Body>\n\t\t</Table>;\n    }\n}\nRotationTable.targetAccessorResolver = (entry, target) => {\n    if (typeof target.accessor === 'string' && entry.targetsData != null) {\n        return entry.targetsData[target.accessor];\n    }\n    else if (typeof target.accessor === 'function') {\n        return target.accessor(entry);\n    }\n    else {\n        return {\n            actual: 0,\n            expected: 0,\n        };\n    }\n};\nRotationTable.notesAccessorResolver = (entry, note) => {\n    if (typeof note.accessor === 'string' && entry.notesMap != null) {\n        return entry.notesMap[note.accessor];\n    }\n    else if (typeof note.accessor === 'function') {\n        return note.accessor(entry);\n    }\n    else {\n        return null;\n    }\n};\nRotationTable.TargetCell = ({ actual, expected }) => <Table.Cell textAlign=\"center\" positive={expected === undefined ? false : actual >= expected} negative={expected === undefined ? false : actual < expected}>\n\t\t\t{actual}/{expected === undefined ? '-' : expected}\n\t\t</Table.Cell>;\nRotationTable.Row = ({ onGoto, targets, notes, notesMap, start, end, targetsData, rotation }) => <Table.Row>\n\t\t\t<Table.Cell textAlign=\"center\">\n\t\t\t\t<span style={{ marginRight: 5 }}>{formatDuration(start / 1000)}</span>\n\t\t\t\t{typeof onGoto === 'function' && <Button circular compact size=\"mini\" icon=\"time\" onClick={() => onGoto(start, end)}/>}\n\t\t\t</Table.Cell>\n\t\t\t{targets\n    .map(target => RotationTable.targetAccessorResolver({ start, end, targetsData, rotation }, target))\n    .map((targetEntry, i) => <RotationTable.TargetCell key={`target_${i}`} {...targetEntry}/>)}\n\t\t\t<Table.Cell>\n\t\t\t\t<Rotation events={rotation}/>\n\t\t\t</Table.Cell>\n\t\t\t{notes\n    .map(note => RotationTable.notesAccessorResolver({ start, end, targetsData, notesMap, rotation }, note))\n    .map((noteEntry, i) => <Table.Cell key={`notes_${i}`} textAlign=\"center\">\n\t\t\t\t\t\t\t{noteEntry}\n\t\t\t\t\t\t</Table.Cell>)}\n\t\t</Table.Row>;\n","import _ from 'lodash';\nimport PropTypes from 'prop-types';\nimport React, { PureComponent } from 'react';\nimport { Line } from 'react-chartjs-2';\nconst DEFAULT_OPTIONS = {\n    aspectRatio: 3,\n    scales: {\n        xAxes: [{\n                type: 'time',\n                time: {\n                    displayFormats: {\n                        minute: 'm:ss',\n                        second: 'm:ss',\n                        millisecond: 'm:ss.SS',\n                    },\n                    // This tooltip format displays similar to a \"relative\" timestamp,\n                    // since react assumes UNIX epoch timestamps for the data.\n                    tooltipFormat: 'mm:ss.SSS',\n                },\n            }],\n    },\n};\nexport default class TimeLineChart extends PureComponent {\n    render() {\n        const options = _.merge({}, DEFAULT_OPTIONS, this.props.options || {});\n        return <Line data={this.props.data} options={options} \n        // Using this trash 'cus aspectRatio doesn't work with the react wrapper\n        width={options.aspectRatio} height={1}/>;\n    }\n}\nTimeLineChart.propTypes = {\n    data: PropTypes.object.isRequired,\n    options: PropTypes.object,\n};\n","import { t } from '@lingui/macro';\nimport { Trans, Plural } from '@lingui/react';\nimport React from 'react';\nimport { Accordion } from 'semantic-ui-react';\nimport Rotation from 'components/ui/Rotation';\nimport NormalisedMessage from 'components/ui/NormalisedMessage';\nimport Module from 'parser/core/Module';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport { matchClosestLower } from 'utilities';\n// BRD weaves, ninjustsu, etc. should be handled by subclasses w/ isBadWeave overrides\nconst DEFAULT_MAX_WEAVES = 2; // Default castTime is 0\nconst MAX_WEAVE_TIERS = {\n    0: 2,\n    1: 1,\n    2.5: 0,\n};\nconst WEAVING_SEVERITY = {\n    1: SEVERITY.MEDIUM,\n    5: SEVERITY.MAJOR,\n};\nexport default class Weaving extends Module {\n    constructor(...args) {\n        super(...args);\n        this._weaves = [];\n        this._ongoingCastEvent = null;\n        this._leadingGcdEvent = null;\n        this._trailingGcdEvent = null;\n        this._badWeaves = [];\n        this.addHook('begincast', { by: 'player' }, this._onBeginCast);\n        this.addHook('cast', { by: 'player' }, this._onCast);\n        this.addHook('complete', this._onComplete);\n    }\n    _onBeginCast(event) {\n        this._ongoingCastEvent = event;\n    }\n    _onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        // If the action is an auto, just ignore it\n        if (!action || action.autoAttack) {\n            return;\n        }\n        // If it's not a GCD, just bump the weave count\n        if (this.isOgcd(action)) {\n            this._weaves.push(event);\n            return;\n        }\n        if (this._ongoingCastEvent && this._ongoingCastEvent.ability.guid === action.id) {\n            // This event is the end of a GCD cast\n            this._trailingGcdEvent = {\n                ...event,\n                // Override the timestamp of the GCD with when its cast began\n                timestamp: this._ongoingCastEvent.timestamp,\n            };\n        }\n        else {\n            // This event was an instant GCD (or log missed the cast starting)\n            this._trailingGcdEvent = event;\n        }\n        // Always reset the ongoing cast\n        this._ongoingCastEvent = null;\n        // Throw the current state onto the history\n        this._saveIfBad();\n        // Reset\n        this._leadingGcdEvent = this._trailingGcdEvent;\n        this._weaves = [];\n    }\n    _onComplete() {\n        // If there's been at least one gcd, run a cleanup on any remnant data\n        if (this._leadingGcdEvent) {\n            this._saveIfBad();\n        }\n        // Few triples is medium, any more is major\n        const badWeaves = this._badWeaves;\n        this.suggestions.add(new TieredSuggestion({\n            // WVR Focused synth lmao\n            icon: 'https://xivapi.com/i/001000/001785.png',\n            content: <Trans id=\"core.weaving.content\">\n\t\t\t\tAvoid weaving more actions than you have time for in a single GCD window. Doing so will delay your next GCD, reducing possible uptime. Check the <a href=\"javascript:void(0);\" onClick={() => this.parser.scrollTo(this.constructor.handle)}><NormalisedMessage message={this.constructor.title}/></a> module below for more detailed analysis.\n\t\t\t</Trans>,\n            why: <Plural id=\"core.weaving.why\" value={badWeaves.length} _1=\"# instance of incorrect weaving\" other=\"# instances of incorrect weaving\"/>,\n            tiers: WEAVING_SEVERITY,\n            value: badWeaves.length,\n        }));\n    }\n    _saveIfBad() {\n        const leadingGcdEvent = this._leadingGcdEvent || { timestamp: this.parser.fight.start_time };\n        const gcdTimeDiff = this._trailingGcdEvent.timestamp -\n            leadingGcdEvent.timestamp -\n            this.invuln.getUntargetableUptime('all', leadingGcdEvent.timestamp, this._trailingGcdEvent.timestamp);\n        const weave = {\n            leadingGcdEvent,\n            trailingGcdEvent: this._trailingGcdEvent,\n            gcdTimeDiff,\n            weaves: this._weaves,\n        };\n        if (weave.weaves.length === 0) {\n            return;\n        }\n        if (this.isBadWeave(weave)) {\n            this._badWeaves.push(weave);\n        }\n    }\n    isOgcd(action) {\n        return !action.onGcd\n            && !action.autoAttack;\n    }\n    // Basic weave check. For job-specific weave concerns, subclass Weaving and override this method. Make sure it's included under the same module key to override the base implementation.\n    isBadWeave(weave, maxWeaves) {\n        // Calc. the no. of weaves - we're ignoring any made while the boss is untargetable\n        const weaveCount = weave.weaves.filter(event => !this.invuln.isUntargetable('all', event.timestamp)).length;\n        // Just using maxWeaves to allow potential subclasses to utilise standard functionality with custom max\n        if (!maxWeaves) {\n            // If there's no leading ability, it's the first GCD. Allow the 'default' cast time's amount\n            if (!weave.leadingGcdEvent.ability) {\n                maxWeaves = DEFAULT_MAX_WEAVES;\n            }\n            else {\n                const castTime = this.castTime.forEvent(weave.leadingGcdEvent);\n                const closest = matchClosestLower(MAX_WEAVE_TIERS, castTime);\n                maxWeaves = closest !== undefined ? closest : DEFAULT_MAX_WEAVES;\n            }\n        }\n        // It's possible that they did a bunch of weaves during downtime or similar - that's fine.\n        const speedmod = this.speedmod.get(this.parser.timestamp);\n        const gcdLength = this.gcd.getEstimate() * speedmod;\n        return weave.gcdTimeDiff > gcdLength && weaveCount > maxWeaves;\n    }\n    output() {\n        const badWeaves = this._badWeaves;\n        if (badWeaves.length === 0) {\n            return false;\n        }\n        const panels = badWeaves.map(item => ({\n            key: item.leadingGcdEvent.timestamp,\n            title: {\n                content: <>\n\t\t\t\t\t<strong>{this.parser.formatTimestamp(item.leadingGcdEvent.timestamp)}</strong>\n\t\t\t\t\t&nbsp;-&nbsp;\n\t\t\t\t\t<Plural id=\"core.weaving.panel-count\" value={item.weaves.length} _1=\"# weave\" other=\"# weaves\"/>\n\t\t\t\t\t&nbsp;(\n\t\t\t\t\t{this.parser.formatDuration(item.gcdTimeDiff)}\n\t\t\t\t\t&nbsp;\n\t\t\t\t\t<Trans id=\"core.weaving.between-gcds\">between GCDs</Trans>\n\t\t\t\t\t)\n\t\t\t\t</>,\n            },\n            content: {\n                content: <Rotation events={[\n                    ...(item.leadingGcdEvent.ability ? [item.leadingGcdEvent] : []),\n                    ...item.weaves,\n                ]}/>,\n            },\n        }));\n        return <Accordion exclusive={false} panels={panels} styled fluid/>;\n    }\n}\nWeaving.handle = 'weaving';\nWeaving.dependencies = [\n    'castTime',\n    'data',\n    'gcd',\n    'invuln',\n    'speedmod',\n    'suggestions',\n];\nWeaving.title = t('core.weaving.title') `Weaving Issues`;\n","import { t } from '@lingui/macro';\nimport { Trans } from '@lingui/react';\nimport math from 'mathjsCustom';\nimport React from 'react';\nimport Module from 'parser/core/Module';\nimport { Group, Item } from './Timeline';\nimport { SimpleStatistic } from './Statistics';\nconst MIN_GCD = 1500;\nconst MAX_GCD = 2500;\nconst BASE_GCD = 2500;\nconst CASTER_TAX = 100;\nconst DEBUG_LOG_SAVED_GCDS = false && process.env.NODE_ENV !== 'production';\n// NOTE: Caster tax refers to spells taking 0.1s longer than their tooltip claims if their cast time is at least as long as their recast time.\n// See https://www.reddit.com/r/ffxiv/comments/8s05rn/the_recast_time_on_your_tooltip_can_be_up_to_85/, specifically:\n//    There is also another issue that influences how long recast times actually take that isnâ€™t as heavily influenced by fps but is still affected,\n//    which is animation delay that happen between casts, this means that if you have a spell with a cast time that is equal to or\n//    greater than the recast time you will end up taking longer between casts than the (re)cast time. The delay is around 100 ms at 100+ fps\nexport default class GlobalCooldown extends Module {\n    constructor(...args) {\n        super(...args);\n        this._castingEvent = null;\n        this._estimatedBaseGcd = null;\n        this._estimateGcdCount = -1;\n        this._lastGcd = {\n            isInstant: false,\n            event: null,\n        };\n        this.gcds = [];\n        this.gcdGroupId = 'gcd';\n        this.addHook('complete', this._onComplete);\n    }\n    // Using normalise so the estimate can be used throughout the parse\n    normalise(events) {\n        for (let i = 0; i < events.length; i++) {\n            const event = events[i];\n            // Only care about player GCDs\n            if (!this.parser.byPlayer(event) || !event.ability) {\n                continue;\n            }\n            const action = this.data.getAction(event.ability.guid);\n            if (!action || !action.onGcd) {\n                continue;\n            }\n            // eslint-disable-next-line default-case\n            switch (event.type) {\n                // wowa uses beginchannel for this...? need info for flamethrower/that ast skill/passage of arms\n                case 'begincast':\n                    // Can I check for cancels?\n                    this._castingEvent = event;\n                    break;\n                case 'cast':\n                    const hasBeginCast = this._castingEvent !== null && this._castingEvent.ability.guid === action.id;\n                    const relevantEvent = hasBeginCast ? this._castingEvent : event;\n                    this.saveGcd({ ...this._lastGcd }, relevantEvent.timestamp); // Save last gcd with current timestamp\n                    this._lastGcd.isInstant = !hasBeginCast;\n                    this._lastGcd.event = relevantEvent;\n                    this._castingEvent = null;\n                    break;\n            }\n        }\n        if (events.length) {\n            this.saveGcd({ ...this._lastGcd }, events[events.length - 1].timestamp);\n        }\n        this._debugLogSavedGcds();\n        return events;\n    }\n    _debugLogSavedGcds() {\n        if (!DEBUG_LOG_SAVED_GCDS) {\n            return;\n        }\n        // NOTE: Please sanity-check results when changing normalise or saveGcd. Good test cases include:\n        // - Attributing 1.5s and 2.2s to correct RDM melee gcds\n        // - Sub-0.5s speedmod for BLM fast-casts and correct Instant/CasterTaxed flagging\n        // - Correct timestamp for last event before long gaps (ie: Kefka normal)\n        this.gcds.forEach((gcd) => {\n            const timestamp = this.parser.formatTimestamp(gcd.timestamp);\n            const action = this.data.getAction(gcd.actionId);\n            const instant = gcd.isInstant ? ' Instant' : '';\n            const taxed = gcd.casterTaxed ? ' CasterTaxed' : '';\n            console.log(`${timestamp} ${action.name}[${gcd.length}|${gcd.normalizedLength}] Speedmod[${gcd.speedMod}]${instant}${taxed}`);\n        });\n    }\n    _onComplete() {\n        const startTime = this.parser.fight.start_time;\n        // Timeline output\n        // TODO: Look into adding items to groups? Maybe?\n        this.timeline.addGroup(new Group({\n            id: this.gcdGroupId,\n            content: 'GCD',\n            order: -99,\n        }));\n        this.gcds.forEach(gcd => {\n            const action = this.data.getAction(gcd.actionId);\n            if (!action) {\n                return;\n            }\n            this.timeline.addItem(new Item({\n                type: 'background',\n                start: gcd.timestamp - startTime,\n                length: this._getGcdLength(gcd),\n                title: action.name,\n                group: this.gcdGroupId,\n                content: <img src={action.icon} alt={action.name} title={action.name}/>,\n            }));\n        });\n        // Statistic box\n        const estimate = this.getEstimate(false);\n        this.statistics.add(new SimpleStatistic({\n            title: <Trans id=\"core.gcd.estimated-gcd\">Estimated GCD</Trans>,\n            icon: this.data.actions.ATTACK.icon,\n            value: this.parser.formatDuration(estimate),\n            info: (<Trans id=\"core.gcd.no-statistics\">\n\t\t\t\t\tUnfortunately, player statistics are not available from FF Logs. As such, the calculated GCD length is an <em>estimate</em>, and may well be incorrect. If it is reporting a GCD length <em>longer</em> than reality, you likely need to focus on keeping your GCD rolling.\n\t\t\t\t</Trans>),\n        }));\n    }\n    //saveGcd(event, isInstant) {\n    saveGcd(gcdInfo, timestamp) {\n        if (!gcdInfo.event) {\n            return;\n        }\n        const action = this.data.getAction(gcdInfo.event.ability.guid);\n        if (!action || !action.id) {\n            return;\n        }\n        let speedMod = this.speedmod.get(gcdInfo.event.timestamp);\n        let castTime = action.castTime;\n        // HACK NOTE TODO: Need to properly account for abilities that alter only the cast or recast of attacks.\n        // Thinking of moving this into a module like speedmod, that can be called with a timestamp to grab modified base castTime/cooldown values\n        const HACK_ASTRAL_UMBRAL_SPEED_SCALAR = 0.5;\n        if (speedMod <= HACK_ASTRAL_UMBRAL_SPEED_SCALAR) {\n            speedMod /= HACK_ASTRAL_UMBRAL_SPEED_SCALAR;\n            castTime *= HACK_ASTRAL_UMBRAL_SPEED_SCALAR;\n        }\n        let isCasterTaxed = false;\n        // GCD is only to two decimal places, so round it there. Storing in Ms.\n        // eslint-disable-next-line no-magic-numbers\n        let gcdLength = Math.round((timestamp - gcdInfo.event.timestamp) / 10) * 10;\n        if (!gcdInfo.isInstant && castTime >= action.cooldown) {\n            gcdLength -= CASTER_TAX;\n            isCasterTaxed = true;\n        }\n        const correctedCooldown = action.gcdRecast != null\n            ? action.gcdRecast\n            : action.cooldown;\n        const normaliseWith = gcdInfo.isInstant || castTime < correctedCooldown\n            ? correctedCooldown\n            : castTime;\n        const normalizedGcd = Math.round(gcdLength\n            * ((BASE_GCD / 1000) / normaliseWith)\n            * (1 / speedMod));\n        this.gcds.push({\n            timestamp: gcdInfo.event.timestamp,\n            length: gcdLength,\n            normalizedLength: normalizedGcd,\n            speedMod,\n            castTime,\n            cooldown: correctedCooldown,\n            casterTaxed: isCasterTaxed,\n            actionId: action.id,\n            isInstant: gcdInfo.isInstant,\n        });\n    }\n    getEstimate(bound = true) {\n        const gcdLength = this.gcds.length;\n        // If we don't have cache, need to recaculate it\n        if (this._estimatedBaseGcd === null || gcdLength !== this._estimateGcdCount) {\n            // Calculate the lengths of the GCD\n            const lengths = this.gcds.map(gcd => gcd.normalizedLength);\n            // Mode seems to get best results. Using mean in case there's multiple modes.\n            this._estimatedBaseGcd = lengths.length ? math.mean(math.mode(lengths)) : MAX_GCD;\n            this._estimateGcdCount = gcdLength;\n        }\n        // Bound the result if requested\n        if (bound) {\n            this._estimatedBaseGcd = Math.max(MIN_GCD, Math.min(MAX_GCD, this._estimatedBaseGcd));\n        }\n        return this._estimatedBaseGcd;\n    }\n    getUptime() {\n        return this.gcds.reduce((carry, gcd) => {\n            const duration = this._getGcdLength(gcd);\n            const downtime = this.downtime.getDowntime(gcd.timestamp, gcd.timestamp + duration);\n            return carry + duration - downtime;\n        }, 0);\n    }\n    _getGcdLength(gcd) {\n        let cooldown = (gcd.isInstant || gcd.castTime <= gcd.cooldown)\n            ? gcd.cooldown\n            : Math.max(gcd.castTime, gcd.cooldown);\n        cooldown *= 1000;\n        // Some actions are lower than or equal to min gcd, only adjust with ratios when they are not\n        if (cooldown > MIN_GCD) {\n            const cooldownRatio = this.getEstimate() / MAX_GCD;\n            cooldown = Math.max(MIN_GCD, cooldown * cooldownRatio * gcd.speedMod);\n        }\n        const duration = Math.round(cooldown + (gcd.casterTaxed ? CASTER_TAX : 0));\n        return duration;\n    }\n}\nGlobalCooldown.handle = 'gcd';\nGlobalCooldown.dependencies = [\n    // We need this to normalise before us\n    'precastAction',\n    'castTime',\n    'data',\n    'downtime',\n    'speedmod',\n    'statistics',\n    'timeline',\n];\nGlobalCooldown.title = t('core.gcd.title') `Global Cooldown`;\n","import { __decorate, __metadata } from \"tslib\";\nimport { t } from '@lingui/macro';\nimport { Plural, Trans } from '@lingui/react';\nimport { ActionLink } from 'components/ui/DbLink';\nimport { RotationTable } from 'components/ui/RotationTable';\nimport _ from 'lodash';\nimport Module, { dependency } from 'parser/core/Module';\nimport GlobalCooldown from 'parser/core/modules/GlobalCooldown';\nimport Suggestions, { TieredSuggestion } from 'parser/core/modules/Suggestions';\nimport Timeline from 'parser/core/modules/Timeline';\nimport React from 'react';\nimport { Data } from './Data';\nexport class BuffWindowState {\n    constructor(data, start) {\n        this.rotation = [];\n        this.data = data;\n        this.start = start;\n    }\n    get gcds() {\n        // TODO: Investigate removing the reliance on data here.\n        return this.rotation\n            .map(e => this.data.getAction(e.ability.guid))\n            .filter(a => a && a.onGcd)\n            .length;\n    }\n    getActionCountByIds(actionsById) {\n        return this.rotation\n            .filter(e => actionsById.includes(e.ability.guid))\n            .length;\n    }\n}\nexport class BuffWindowModule extends Module {\n    constructor() {\n        super(...arguments);\n        this.buffWindows = [];\n    }\n    get activeBuffWindow() {\n        const lastBuffWindow = _.last(this.buffWindows);\n        if (lastBuffWindow && lastBuffWindow.end == null) {\n            return lastBuffWindow;\n        }\n        return undefined;\n    }\n    init() {\n        this.addHook('cast', { by: 'player' }, this.onCast);\n        this.addHook('applybuff', { by: 'player' }, this.onApplyBuff);\n        this.addHook('removebuff', { by: 'player' }, this.onRemoveBuff);\n        this.addHook('complete', this.onComplete);\n    }\n    onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.autoAttack) {\n            // Disregard auto attacks for tracking rotations / events during buff windows\n            return;\n        }\n        if (this.activeBuffWindow && this.considerAction(action)) {\n            this.activeBuffWindow.rotation.push(event);\n        }\n    }\n    /**\n     * This method MAY be overridden to return true or false, indicating whether or not this action should be considered within the buff window\n     * If false is returned, the action will not be tracked AT ALL within the buff window, and will NOT appear within the Rotation column\n     * @param action\n     */\n    considerAction(action) {\n        return true;\n    }\n    onApplyBuff(event) {\n        if (!this.buffStatus || event.ability.guid !== this.buffStatus.id) {\n            return;\n        }\n        this.startNewBuffWindow(event.timestamp);\n    }\n    startNewBuffWindow(startTime) {\n        this.buffWindows.push(new BuffWindowState(this.data, startTime));\n    }\n    onRemoveBuff(event) {\n        if (!this.buffStatus || event.ability.guid !== this.buffStatus.id) {\n            return;\n        }\n        if (this.activeBuffWindow) {\n            this.activeBuffWindow.end = event.timestamp;\n        }\n    }\n    /**\n     * For consumers that have the same number of expected GCDs per window, this will use the expectedPerWindow property\n     *   on expectedGCDs as the baseline\n     * This method MAY be overridden if the logic of expected GCDs per window is variable\n     * @param buffWindow\n     */\n    getBaselineExpectedGCDs(buffWindow) {\n        if (this.expectedGCDs) {\n            return this.expectedGCDs.expectedPerWindow;\n        }\n        return 0;\n    }\n    /**\n     * This method MAY be overridden to provide class-specific rushing logic per BuffWindow - default is no effect\n     * Return a positive number to INCREASE expected GCDs for this window, or a negative number to DECREASE\n     * @param buffWindow\n     */\n    changeExpectedGCDsClassLogic(buffWindow) {\n        return 0;\n    }\n    /**\n     * Handles rushing logic to reduce expected GCDs in a window for end of fight rushing\n     * This method MAY be overridden if class rules for end of fight rushing vary\n     * @param buffWindow\n     */\n    reduceExpectedGCDsEndOfFight(buffWindow) {\n        if (this.buffStatus.duration) {\n            // Check to see if this window is rushing due to end of fight - reduce expected GCDs accordingly\n            const windowDurationMillis = this.buffStatus.duration * 1000;\n            const fightTimeRemaining = this.parser.fight.end_time - buffWindow.start;\n            if (windowDurationMillis >= fightTimeRemaining) {\n                const gcdEstimate = this.globalCooldown.getEstimate();\n                return Math.ceil((windowDurationMillis - fightTimeRemaining) / gcdEstimate);\n            }\n        }\n        // Default: no rushing reduction\n        return 0;\n    }\n    /**\n     * For consumers that have tracked actions that expect the same number of usages per window, this will use the\n     *   expectedPerWindow property on that action as the baseline\n     * This method MAY be overridden if the logic of expected tracked actions per window is variable\n     * @param buffWindow\n     * @param action\n     */\n    getBaselineExpectedTrackedAction(buffWindow, action) {\n        return action.expectedPerWindow || 0;\n    }\n    /**\n     * This method MAY be overridden to provide class-specific logic to change expected uses of a tracked action per BuffWindow - default no effect\n     * Return a positive number to INCREASE expected tracked action usages for this window, or a negative number to DECREASE\n     * @param buffWindow\n     * @param action\n     */\n    changeExpectedTrackedActionClassLogic(buffWindow, action) {\n        return 0;\n    }\n    getBuffWindowExpectedGCDs(buffWindow) {\n        return this.getBaselineExpectedGCDs(buffWindow) + this.changeExpectedGCDsClassLogic(buffWindow) - this.reduceExpectedGCDsEndOfFight(buffWindow);\n    }\n    /**\n     * This method MAY be overridden to provide class-specific logic to determine if the required GCD(s) were used during a given BuffWindow\n     * Classes whose required GCD list vary per window should override this function.\n     * Function MUST return a number of CORRECT GCDs used within the window\n     * @param buffWindow\n     */\n    getBuffWindowRequiredGCDsUsed(buffWindow) {\n        if (!this.requiredGCDs) {\n            return 0;\n        }\n        const allowedGCDsById = this.requiredGCDs.actions.map(a => a.id);\n        return buffWindow.getActionCountByIds(allowedGCDsById);\n    }\n    getBuffWindowExpectedTrackedActions(buffWindow, action) {\n        return this.getBaselineExpectedTrackedAction(buffWindow, action) + this.changeExpectedTrackedActionClassLogic(buffWindow, action);\n    }\n    /**\n     * This method will be called if and only if the rotationTableNotesColumnHeader property is set, to add a notes field for each buff window\n     * Implementing classes MUST define their logic to determine what note to display for each buff window within this method\n     * @param buffWindow\n     */\n    getBuffWindowNotes(buffWindow) {\n        return undefined;\n    }\n    onComplete() {\n        if (this.expectedGCDs) {\n            const missedGCDs = this.buffWindows\n                .reduce((sum, buffWindow) => {\n                const expectedGCDs = this.getBuffWindowExpectedGCDs(buffWindow);\n                return sum + Math.max(0, expectedGCDs - buffWindow.gcds);\n            }, 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.buffAction.icon,\n                content: this.expectedGCDs.suggestionContent,\n                tiers: this.expectedGCDs.severityTiers,\n                value: missedGCDs,\n                why: <Trans id=\"core.buffwindow.suggestions.missedgcd.why\">\n\t\t\t\t\t{missedGCDs} <Plural value={missedGCDs} one=\"GCD was\" other=\"GCDs were\"/> missed during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n        if (this.requiredGCDs) {\n            const invalidGCDs = this.buffWindows\n                .reduce((sum, buffWindow) => sum + Math.max(0, buffWindow.gcds - this.getBuffWindowRequiredGCDsUsed(buffWindow)), 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.requiredGCDs.icon,\n                content: this.requiredGCDs.suggestionContent,\n                tiers: this.requiredGCDs.severityTiers,\n                value: invalidGCDs,\n                why: <Trans id=\"core.buffwindow.suggestions.badgcd.why\">\n\t\t\t\t\t{invalidGCDs} incorrect <Plural value={invalidGCDs} one=\"GCD was\" other=\"GCDs were\"/> used during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n        if (this.trackedActions) {\n            const missedActions = this.trackedActions.actions\n                .reduce((sum, trackedAction) => sum + this.buffWindows\n                .reduce((sum, buffWindow) => sum + Math.max(0, trackedAction.expectedPerWindow - buffWindow.getActionCountByIds([trackedAction.action.id])), 0), 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.trackedActions.icon,\n                content: this.trackedActions.suggestionContent,\n                tiers: this.trackedActions.severityTiers,\n                value: missedActions,\n                why: <Trans id=\"core.buffwindow.suggestions.trackedaction.why\">\n\t\t\t\t\t<Plural value={missedActions} one=\"# use of a recommended cooldown was\" other=\"# uses of recommended cooldowns were\"/> missed during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n        if (this.trackedBadActions) {\n            const badActions = this.trackedBadActions.actions\n                .reduce((sum, trackedAction) => sum + this.buffWindows\n                .reduce((sum, buffWindow) => sum + Math.max(0, buffWindow.getActionCountByIds([trackedAction.action.id]) - trackedAction.expectedPerWindow), 0), 0);\n            this.suggestions.add(new TieredSuggestion({\n                icon: this.trackedBadActions.icon,\n                content: this.trackedBadActions.suggestionContent,\n                tiers: this.trackedBadActions.severityTiers,\n                value: badActions,\n                why: <Trans id=\"core.buffwindow.suggestions.trackedbadaction.why\">\n\t\t\t\t\t<Plural value={badActions} one=\"# use of\" other=\"# uses of\"/> cooldowns that should be avoided during {this.buffAction.name} windows.\n\t\t\t\t</Trans>,\n            }));\n        }\n    }\n    output() {\n        const rotationTargets = [];\n        const notesData = [];\n        if (this.expectedGCDs) {\n            rotationTargets.push({\n                header: <Trans id=\"core.buffwindow.table.header.gcds\">GCDs</Trans>,\n                accessor: 'missedgcd',\n            });\n        }\n        if (this.requiredGCDs) {\n            rotationTargets.push({\n                header: <img src={this.requiredGCDs.icon} alt=\"\" style={{ height: '20px' }}/>,\n                accessor: 'badgcd',\n            });\n        }\n        if (this.trackedActions) {\n            this.trackedActions.actions.forEach((trackedAction) => {\n                rotationTargets.push({\n                    header: <ActionLink showName={false} {...trackedAction.action}/>,\n                    accessor: trackedAction.action.name,\n                });\n            });\n        }\n        if (this.rotationTableNotesColumnHeader) {\n            notesData.push({\n                header: this.rotationTableNotesColumnHeader,\n                accessor: 'notes',\n            });\n        }\n        const rotationData = this.buffWindows\n            .map(buffWindow => {\n            const windowStart = buffWindow.start - this.parser.fight.start_time;\n            const windowEnd = (buffWindow.end != null ? buffWindow.end : buffWindow.start) - this.parser.fight.start_time;\n            const targetsData = {};\n            const notesMap = {};\n            if (this.expectedGCDs) {\n                targetsData.missedgcd = {\n                    actual: buffWindow.gcds,\n                    expected: this.getBuffWindowExpectedGCDs(buffWindow),\n                };\n            }\n            if (this.requiredGCDs) {\n                targetsData.badgcd = {\n                    actual: this.getBuffWindowRequiredGCDsUsed(buffWindow),\n                    expected: this.getBuffWindowExpectedGCDs(buffWindow),\n                };\n            }\n            if (this.trackedActions) {\n                this.trackedActions.actions.forEach((trackedAction) => {\n                    targetsData[trackedAction.action.name] = {\n                        actual: buffWindow.getActionCountByIds([trackedAction.action.id]),\n                        expected: this.getBuffWindowExpectedTrackedActions(buffWindow, trackedAction),\n                    };\n                });\n            }\n            if (this.rotationTableNotesColumnHeader) {\n                notesMap.notes = this.getBuffWindowNotes(buffWindow);\n            }\n            return {\n                start: windowStart,\n                end: windowEnd,\n                targetsData,\n                rotation: buffWindow.rotation,\n                notesMap,\n            };\n        });\n        return <RotationTable targets={rotationTargets} data={rotationData} notes={notesData} onGoto={this.timeline.show} headerTitle={this.rotationTableHeader}/>;\n    }\n}\nBuffWindowModule.handle = 'buffwindow';\nBuffWindowModule.title = t('core.buffwindow.title') `Buff Window`;\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Data)\n], BuffWindowModule.prototype, \"data\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Suggestions)\n], BuffWindowModule.prototype, \"suggestions\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Timeline)\n], BuffWindowModule.prototype, \"timeline\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", GlobalCooldown)\n], BuffWindowModule.prototype, \"globalCooldown\", void 0);\n","import Module from 'parser/core/Module';\n// Absurdly large fallback number, so missing duration properties will result in both a console warning and stupid suggestions\nconst DEFAULT_DURATION_MILLIS = 120000;\nexport default class DoTs extends Module {\n    constructor(...args) {\n        super(...args);\n        this._lastApplication = {};\n        this._clip = {};\n        this._statusDuration = {};\n        // NOTE: All statuses submodules track should include a duration property, otherwise the results this produces will be very fucky\n        this.constructor.statusesToTrack.forEach(statusId => {\n            const status = this.data.getStatus(statusId);\n            if (!status) {\n                return;\n            }\n            if (!status.hasOwnProperty('duration')) {\n                console.warn(`statusId ${statusId} is missing a duration property`);\n                this._statusDuration[statusId] = DEFAULT_DURATION_MILLIS;\n            }\n            else {\n                this._statusDuration[statusId] = status.duration * 1000;\n            }\n        });\n        this.addHook(['applydebuff', 'refreshdebuff'], { by: 'player', abilityId: this.constructor.statusesToTrack }, this._onDotApply);\n        this.addHook('complete', this._onComplete);\n    }\n    // *** FUNCTIONS TO OVERRIDE *** //\n    excludeApplication() {\n        // To be overridden by submodules that want to exclude certain applications from clipping calculations (e.g. SMN when rushing)\n        return false;\n    }\n    addChecklistRules() {\n        // To be overridden by submodules to display the checklist rules for their job. This should be handled on a job-by-job\n        // basis rather than generically, since the description text isn't one-size-fits-all, and some jobs may be tracking\n        // more than just DoTs with this module (e.g. DRG's Disembowel).\n    }\n    // Allow Typescript overrides using the parameter\n    // eslint-disable-next-line no-unused-vars\n    addClippingSuggestions(clip) {\n        // To be overridden by submodules to display any clipping suggestions. This should also be handled on a job-by-job\n        // basis, since different jobs have different thresholds for what constitutes bad clipping with varying explanations\n        // for why.\n    }\n    // ***************************** //\n    _onDotApply(event) {\n        const statusId = event.ability.guid;\n        // Make sure we're tracking for this target\n        const applicationKey = `${event.targetID}|${event.targetInstance}`;\n        const lastApplication = this._lastApplication[applicationKey] = this._lastApplication[applicationKey] || {};\n        // If it's not been applied yet or should be excluded per job-specific logic (if any), set it and skip out\n        if (!lastApplication[statusId] || this.excludeApplication()) {\n            lastApplication[statusId] = event.timestamp;\n            return;\n        }\n        // Base clip calc\n        let clip = this._statusDuration[statusId] - (event.timestamp - lastApplication[statusId]);\n        // Remove any untargetable time from the clip - often want to hardcast after an invuln phase, but refresh w/ 3D shortly after.\n        clip -= this.invuln.getUntargetableUptime('all', event.timestamp - this._statusDuration[statusId], event.timestamp);\n        // Also remove invuln time in the future that casting later would just push dots into\n        // TODO: This relies on a full set of invuln data ahead of time. Can this be trusted?\n        clip -= this.invuln.getInvulnerableUptime('all', event.timestamp, event.timestamp + this._statusDuration[statusId] + clip);\n        // Capping clip at 0 - less than that is downtime, which is handled by the checklist requirement\n        this._clip[statusId] = (this._clip[statusId] || 0) + Math.max(0, clip);\n        lastApplication[statusId] = event.timestamp;\n    }\n    _onComplete() {\n        this.addChecklistRules();\n        this.addClippingSuggestions(this._clip);\n    }\n    // These two functions are helpers for submodules and should be used but not overridden\n    getUptimePercent(statusId) {\n        const statusUptime = this.enemies.getStatusUptime(statusId);\n        const fightDuration = this.parser.fightDuration - this.invuln.getInvulnerableUptime();\n        return (statusUptime / fightDuration) * 100;\n    }\n    getClippingAmount(statusId) {\n        // This normalises clipping as seconds clipped per minute, since some level of clipping is expected and we need tiers that work for both long and short fights\n        const fightDurationMillis = (this.parser.fightDuration - this.invuln.getInvulnerableUptime());\n        // eslint-disable-next-line no-magic-numbers\n        const clipSecsPerMin = Math.round((this._clip[statusId] * 60) / fightDurationMillis);\n        return clipSecsPerMin;\n    }\n}\nDoTs.handle = 'dots';\nDoTs.dependencies = [\n    'data',\n    'enemies',\n    'invuln',\n];\n// To be overriden by submodules with an array of status IDs to track\nDoTs.statusesToTrack = [];\n","export default {\n    AETHERFLOW: 51,\n    DOTS: 52,\n    WEAVING: 54,\n    SWIFTCAST: 99,\n};\n","import React, { Fragment } from 'react';\nimport { Table, Grid } from 'semantic-ui-react';\nimport { Trans } from '@lingui/react';\nimport { ActionLink } from 'components/ui/DbLink';\nimport { getDataBy } from 'data';\nimport ACTIONS from 'data/ACTIONS';\nimport STATUSES from 'data/STATUSES';\nimport Module from 'parser/core/Module';\nimport { Rule, Requirement } from 'parser/core/modules/Checklist';\nimport DISPLAY_ORDER from './DISPLAY_ORDER';\n// Actions that reduce Aetherflow's cooldown.\nconst AETHERFLOW_CD_ACTIONS = [\n    ACTIONS.LUSTRATE.id,\n    ACTIONS.EXCOGITATION.id,\n    ACTIONS.INDOMITABILITY.id,\n    ACTIONS.SACRED_SOIL.id,\n    ACTIONS.SCH_ENERGY_DRAIN.id,\n];\nconst RECITATION_ACTIONS = [\n    ACTIONS.EXCOGITATION.id,\n    ACTIONS.INDOMITABILITY.id,\n    ACTIONS.ADLOQUIUM.id,\n    ACTIONS.SUCCOR.id,\n];\n// Since we can't use Aetherflow pre-pull, is this relevant anymore?\nconst EXTRA_AETHERFLOWS = 3;\nconst AETHERFLOW_COOLDOWN = 60000;\n// Flow needs to be burnt before first use - estimate at 10s for now\nconst FIRST_FLOW_TIMESTAMP = 10000;\nexport default class Aetherflow extends Module {\n    constructor(...args) {\n        super(...args);\n        this._totalAetherflowCasts = 0;\n        this._extraAetherflows = EXTRA_AETHERFLOWS; // pre-pull\n        this._recitationActive = false;\n        this._uses = [];\n        this.addEventHook('cast', { by: 'player' }, this._onCast);\n        this.addEventHook('applybuff', { by: 'player', abilityId: STATUSES.RECITATION.id }, this._onGainRecitation);\n        this.addEventHook('removebuff', { by: 'player', abilityId: STATUSES.RECITATION.id }, this._removeRecitation);\n        this.addEventHook('death', { to: 'player' }, this._removeRecitation);\n        this.addEventHook('complete', this._onComplete);\n    }\n    _onGainRecitation() {\n        this._recitationActive = true;\n    }\n    _removeRecitation() {\n        this._recitationActive = false;\n    }\n    _durationWithAetherflowOnCooldown() {\n        return this.parser.fightDuration - FIRST_FLOW_TIMESTAMP;\n    }\n    _possibleAetherflowCasts() {\n        return this._extraAetherflows + Math.floor(this._durationWithAetherflowOnCooldown() / AETHERFLOW_COOLDOWN) * EXTRA_AETHERFLOWS;\n    }\n    _updateAetherflowUses(ts, id) {\n        this._totalAetherflowCasts++;\n        this._uses.push({ timestamp: ts, debit: 1, id: [id] });\n    }\n    _onCast(event) {\n        const abilityId = event.ability.guid;\n        if (AETHERFLOW_CD_ACTIONS.includes(abilityId)) {\n            // should be the standard case\n            if (!this._recitationActive) {\n                this._updateAetherflowUses(event.timestamp, abilityId);\n            }\n            else if (!RECITATION_ACTIONS.includes(abilityId)) {\n                this._updateAetherflowUses(event.timestamp, abilityId);\n            }\n        }\n        if (abilityId === ACTIONS.DISSIPATION.id) {\n            this._extraAetherflows += EXTRA_AETHERFLOWS;\n        }\n    }\n    _onComplete() {\n        // Checklist rule for aetherflow cooldown\n        this.checklist.add(new Rule({\n            name: <Fragment><Trans id=\"sch.aetherflow.checklist.name\">Use <ActionLink {...ACTIONS.AETHERFLOW}/> on cooldown.</Trans></Fragment>,\n            description: <ul>\n\t\t\t\t<li><Trans id=\"sch.aetherflow.checklist.description-1\">Using aetherflow on cooldown lets you regain mana faster.</Trans></li>\n\t\t\t</ul>,\n            requirements: [\n                new Requirement({\n                    name: <Fragment><Trans id=\"sch.aetherflow.checklist.requirement.uptime.name\"><ActionLink {...ACTIONS.AETHERFLOW}/> cooldown uptime</Trans></Fragment>,\n                    percent: (this.cooldowns.getTimeOnCooldown(ACTIONS.AETHERFLOW.id) / this._durationWithAetherflowOnCooldown()) * 100,\n                }),\n                new Requirement({\n                    name: <Fragment><Trans id=\"sch.aetherflow.checklist.requirement.uses.name\">Total <ActionLink {...ACTIONS.AETHERFLOW}/> casts: {this._totalAetherflowCasts} out of {this._possibleAetherflowCasts()} possible</Trans></Fragment>,\n                    percent: this._totalAetherflowCasts / this._possibleAetherflowCasts() * 100,\n                }),\n            ],\n        }));\n    }\n    output() {\n        const aetherflows = this.cooldowns.getCooldown(ACTIONS.AETHERFLOW.id).history\n            .map(h => ({ timestamp: [h.timestamp], id: [ACTIONS.AETHERFLOW.id] }));\n        const dissipations = this.cooldowns.getCooldown(ACTIONS.DISSIPATION.id).history\n            .map(h => ({ timestamp: [h.timestamp], id: [ACTIONS.DISSIPATION.id] }));\n        const uses = this._uses;\n        let totalDrift = 0;\n        let totalWasted = 0;\n        return <Table collapsing unstackable>\n\t\t\t<Table.Header>\n\t\t\t\t<Table.Row>\n\t\t\t\t\t<Table.HeaderCell><Trans id=\"sch.aetherflow.cast-time\">Cast Times</Trans></Table.HeaderCell>\n\t\t\t\t\t<Table.HeaderCell><Trans id=\"sch.aetherflow.cooldown\">CD</Trans></Table.HeaderCell>\n\t\t\t\t\t<Table.HeaderCell><Trans id=\"sch.aetherflow.drift\">Drift</Trans></Table.HeaderCell>\n\t\t\t\t\t<Table.HeaderCell><Trans id=\"sch.aetherflow.abilities-used\">Abilities Used</Trans></Table.HeaderCell>\n\t\t\t\t\t<Table.HeaderCell><Trans id=\"sch.aetherflow.stacks-wasted\">Stacks Wasted</Trans></Table.HeaderCell>\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Header>\n\t\t\t<Table.Body>\n\t\t\t\t{[].concat(aetherflows, dissipations, uses)\n            .sort((a, b) => a.timestamp - b.timestamp)\n            .reduce((prev, curr) => {\n            if (prev.length === 0) {\n                return [curr];\n            }\n            // group debits together\n            const { id, debit, timestamp } = prev[prev.length - 1];\n            if (curr.debit) {\n                prev[prev.length - 1] = {\n                    debit: (debit || 0) + curr.debit,\n                    id: [].concat(id, curr.id),\n                    timestamp: [].concat(timestamp, curr.timestamp),\n                };\n                return prev;\n            }\n            // not a debit, so it has to be a credit - insert a new item\n            return [...prev, curr];\n        }, [])\n            .map(({ timestamp, debit = 0, id }, index, all) => {\n            let downtime = 0;\n            let drift = 0;\n            if (id.includes(ACTIONS.AETHERFLOW.id)) {\n                let nextUptime;\n                // next credit is an aetherflow, calculate downtime now\n                const nextCredit = all[index + 1];\n                // if not, next next credit (due to dissipation)\n                const nextNextCredit = all[index + 2];\n                // if not, just consider it the end of fight.\n                if (nextCredit && nextCredit.id[0] === ACTIONS.AETHERFLOW.id) {\n                    nextUptime = nextCredit.timestamp[0];\n                }\n                else if (nextNextCredit && nextNextCredit.id[0] === ACTIONS.AETHERFLOW.id) {\n                    nextUptime = nextNextCredit.timestamp[0];\n                    drift += EXTRA_AETHERFLOWS * 1000;\n                }\n                else {\n                    nextUptime = this.parser.currentTimestamp;\n                }\n                downtime = nextUptime - timestamp[0];\n            }\n            drift += downtime;\n            drift -= AETHERFLOW_COOLDOWN;\n            if (drift > 0) {\n                totalDrift += drift;\n            }\n            let wasted = 0;\n            if (downtime > AETHERFLOW_COOLDOWN) {\n                wasted = EXTRA_AETHERFLOWS - debit || 0;\n                totalWasted += wasted;\n            }\n            if (!Array.isArray(timestamp)) {\n                // I mean, they should be doing more than one AF cast per stack\n                // but who am I to judge?\n                timestamp = [timestamp];\n            }\n            return <Table.Row key={timestamp}>\n\t\t\t\t\t\t\t<Table.Cell>{timestamp.map(t => this.parser.formatTimestamp(t)).join(', ')}</Table.Cell>\n\t\t\t\t\t\t\t<Table.Cell>{downtime > 0 && this.parser.formatDuration(downtime)}</Table.Cell>\n\t\t\t\t\t\t\t<Table.Cell>{drift > 0 && this.parser.formatDuration(drift)}</Table.Cell>\n\t\t\t\t\t\t\t<Table.Cell>\n\t\t\t\t\t\t\t\t<Grid>\n\t\t\t\t\t\t\t\t\t{id.map((id, i) => <Grid.Column key={i} width={4}>\n\t\t\t\t\t\t\t\t\t\t<ActionLink {...getDataBy(ACTIONS, 'id', id)}/>\n\t\t\t\t\t\t\t\t\t</Grid.Column>)}\n\t\t\t\t\t\t\t\t</Grid>\n\t\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t\t<Table.Cell>{wasted || '-'}</Table.Cell>\n\t\t\t\t\t\t</Table.Row>;\n        })}\n\t\t\t\t<Table.Row>\n\t\t\t\t\t<Table.Cell colSpan=\"2\" textAlign=\"right\" col>Total Drift</Table.Cell>\n\t\t\t\t\t<Table.Cell>{this.parser.formatDuration(totalDrift)}</Table.Cell>\n\t\t\t\t\t<Table.Cell textAlign=\"right\">Total Stacks Wasted</Table.Cell>\n\t\t\t\t\t<Table.Cell>{totalWasted || '-'}</Table.Cell>\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Body>\n\t\t</Table>;\n    }\n}\nAetherflow.displayOrder = DISPLAY_ORDER.AETHERFLOW;\nAetherflow.handle = 'aetherflow';\nAetherflow.dependencies = [\n    'checklist',\n    'cooldowns',\n];\n","import React from 'react';\nimport { Trans } from '@lingui/react';\nimport { ActionLink, StatusLink } from 'components/ui/DbLink';\nimport ACTIONS from 'data/ACTIONS';\nimport STATUSES from 'data/STATUSES';\nimport CoreDoTs from 'parser/core/modules/DoTs';\nimport { TieredRule, TARGET, Requirement } from 'parser/core/modules/Checklist';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport DISPLAY_ORDER from './DISPLAY_ORDER';\n// In seconds\nconst SEVERITIES = {\n    CLIPPING: {\n        6: SEVERITY.MINOR,\n        9: SEVERITY.MEDIUM,\n        12: SEVERITY.MAJOR,\n    },\n    UPTIME: {\n        84: TARGET.WARN,\n        94: TARGET.SUCCESS,\n    },\n};\nexport default class DoTs extends CoreDoTs {\n    addChecklistRules() {\n        this.checklist.add(new TieredRule({\n            name: <Trans id=\"sch.dots.checklist.name\">Keep your DoT up</Trans>,\n            description: <Trans id=\"sch.dots.checklist.description\">\n\t\t\t\tAs a Scholar, Biolysis is a notable porition of your damage. Aim to keep it up as much as possible, so long as you can get at least 15 seconds of uptime per application.\n\t\t\t</Trans>,\n            tiers: SEVERITIES.UPTIME,\n            requirements: [\n                new Requirement({\n                    name: <Trans id=\"sch.dots.checklist.requirement.bio-ii.name\"><ActionLink {...ACTIONS.BIOLYSIS}/> uptime</Trans>,\n                    percent: () => this.getUptimePercent(STATUSES.BIOLYSIS.id),\n                }),\n            ],\n        }));\n    }\n    addClippingSuggestions(clip) {\n        const clipPerMinute = this.getClippingAmount(STATUSES.BIOLYSIS.id);\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.BIOLYSIS.icon,\n            content: <Trans id=\"sch.dots.suggestions.clipping.content\">\n\t\t\t\tAvoid refreshing Biolysis significantly before its expiration, except when at the end of the fight. Unnecessary refreshes use up your mana more than necessary, and may cause you to go out of mana.\n\t\t\t</Trans>,\n            tiers: SEVERITIES.CLIPPING,\n            value: clipPerMinute,\n            why: <Trans id=\"sch.dots.suggestions.clipping.why\">\n\t\t\t\tAn average of {this.parser.formatDuration(clipPerMinute * 1000)} of <StatusLink {...STATUSES.BIOLYSIS}/> clipped every minute, for a total of {this.parser.formatDuration(clip[STATUSES.BIOLYSIS.id])} lost to early refreshes.\n\t\t\t</Trans>,\n        }));\n    }\n}\nDoTs.handle = 'biolysis';\nDoTs.displayOrder = DISPLAY_ORDER.DOTS;\nDoTs.dependencies = [\n    ...DoTs.dependencies,\n    'checklist',\n    'suggestions',\n];\nDoTs.statusesToTrack = [\n    STATUSES.BIOLYSIS.id,\n];\n","import { Trans, Plural } from '@lingui/react';\nimport NormalisedMessage from 'components/ui/NormalisedMessage';\nimport React from 'react';\nimport { ActionLink } from 'components/ui/DbLink';\nimport ACTIONS from 'data/ACTIONS';\nimport CoreWeaving from 'parser/core/modules/Weaving';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport DISPLAY_ORDER from './DISPLAY_ORDER';\nconst WEAVING_SEVERITY = {\n    1: SEVERITY.MINOR,\n    5: SEVERITY.MEDIUM,\n    10: SEVERITY.MAJOR,\n};\nexport default class Weaving extends CoreWeaving {\n    // override to give SCH-relevant weave suggestions\n    // Pretty much copy-pasted from the CoreWeaving Module otherwise\n    _onComplete() {\n        // If there's been at least one gcd, run a cleanup on any remnant data\n        if (this._leadingGcdEvent) {\n            this._saveIfBad();\n        }\n        // Few triples is medium, any more is major\n        const badWeavesCount = this._badWeaves.length;\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.SCH_RUIN_II.icon,\n            content: <Trans id=\"sch.weaving.content\">\n\t\t\t\tTry to use <ActionLink {...ACTIONS.SCH_RUIN_II}/> and <ActionLink {...ACTIONS.BIOLYSIS}/> to weave your actions, and avoid weaving more actions than you have time for in a single GCD window.\n\t\t\t\tDoing so will delay your next GCD, reducing possible uptime. Check the <a href=\"javascript:void(0);\" onClick={() => this.parser.scrollTo(this.constructor.handle)}><NormalisedMessage message={this.constructor.title}/></a> module below for more detailed analysis.\n\t\t\t</Trans>,\n            why: <Plural id=\"sch.weaving.why\" value={badWeavesCount} one=\"# instance of incorrect weaving\" other=\"# instances of incorrect weaving\"/>,\n            tiers: WEAVING_SEVERITY,\n            value: badWeavesCount,\n        }));\n    }\n}\nWeaving.displayOrder = DISPLAY_ORDER.WEAVING;\n","import { Trans } from '@lingui/react';\nimport { ActionLink } from 'components/ui/DbLink';\nimport ACTIONS from 'data/ACTIONS';\nimport { CooldownDowntime } from 'parser/core/modules/CooldownDowntime';\nimport React from 'react';\nexport default class ChainStrat extends CooldownDowntime {\n    constructor() {\n        super(...arguments);\n        this.trackedCds = [\n            {\n                cooldowns: [ACTIONS.CHAIN_STRATAGEM],\n                allowedAverageDowntime: 7500,\n                firstUseOffset: 10000,\n            },\n        ];\n        this.checklistDescription = <Trans id=\"sch.chainstrat.cooldown.description\">Try to use <ActionLink {...ACTIONS.CHAIN_STRATAGEM}/> on cooldown throughout the fight, particularly when your team has other buffs up for maximum effect.</Trans>;\n    }\n}\n","import React, { Fragment } from 'react';\nimport { Trans } from '@lingui/react';\nimport { t } from '@lingui/macro';\nimport Color from 'color';\nimport { getDataBy } from 'data';\nimport JOBS from 'data/JOBS';\nimport ACTIONS from 'data/ACTIONS';\nimport STATUSES from 'data/STATUSES';\nimport Module from 'parser/core/Module';\nimport { Suggestion, TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport { ActionLink } from 'components/ui/DbLink';\nimport TimeLineChart from 'components/ui/TimeLineChart';\nconst SUMMON_ACTIONS = [\n    ACTIONS.SUMMON_EOS.id,\n    ACTIONS.SUMMON_SELENE.id,\n];\n// Actions that generate fairy gauge\nconst GAUGE_GENERATORS = [\n    ACTIONS.SCH_ENERGY_DRAIN.id,\n    ACTIONS.LUSTRATE.id,\n    ACTIONS.INDOMITABILITY.id,\n    ACTIONS.SACRED_SOIL.id,\n    ACTIONS.EXCOGITATION.id,\n];\n// Gauge limits\nconst GAUGE_MAX = 100;\nconst GAUGE_START = 0;\nconst GAUGE_GAIN_AMOUNT = 10;\n// Graph color\nconst GRAPH_COLOR = Color(JOBS.SCHOLAR.colour);\nconst BG_COLOR_FADE = 0.8;\nconst BORDER_COLOR_FADE = 0.5;\n// Severity markers for overcap\n// Start at 30 because you can overcap when seraph is out and you can't drain the gauge\nconst GAUGE_WASTE_SEVERITY = {\n    50: SEVERITY.MINOR,\n};\nexport default class FaerieGauge extends Module {\n    constructor(...args) {\n        super(...args);\n        // Defaults\n        this._gauge = GAUGE_START;\n        this._waste = 0;\n        this._history = [];\n        this._fairyOut = false;\n        this._noFairyAtStart = false;\n        // consumers\n        this.addEventHook('heal', { by: 'pet', abilityId: STATUSES.FEY_UNION.id }, this._onGaugeSpend);\n        this.addEventHook('cast', { by: 'player', abilityId: ACTIONS.SCH_FEY_BLESSING.id }, this._onGaugeSpend);\n        this.addEventHook('death', { to: 'player' }, this._onDeath); // I mean.. it does consume all your gauge..\n        // generators\n        this.addEventHook('cast', { by: 'player', abilityId: GAUGE_GENERATORS }, this._onGaugeGenerate);\n        this.addEventHook('complete', this._onComplete);\n        // summoning a fairy\n        this.addEventHook('cast', { by: 'player', abilityId: SUMMON_ACTIONS }, this._onSummon);\n    }\n    // Search through the events to figure out if there was a fairy out before logs started\n    normalise(events) {\n        for (const event of events) {\n            if (!event.ability) {\n                continue;\n            }\n            const action = getDataBy(ACTIONS, 'id', event.ability.guid);\n            if (!action) {\n                continue;\n            }\n            // if the first action we find is a summon action, bail out and give a warning later\n            if (action.id && SUMMON_ACTIONS.includes(action.id)) {\n                this._noFairyAtStart = true;\n                break;\n            }\n            const pet = this.parser.report.friendlyPets.find(pet => pet.id === event.sourceID)\n                || { petOwner: -1 };\n            // Ignore events that aren't related to your fairy\n            if (event.type !== 'cast' ||\n                !event.sourceIsFriendly ||\n                pet.petOwner !== this.parser.player.id ||\n                !action.pet) {\n                continue;\n            }\n            // Fairy found\n            this._fairyOut = true;\n            break;\n        }\n        return events;\n    }\n    _onSummon() {\n        this._fairyOut = true;\n    }\n    // both spenders and generators consume the same amount\n    _onGaugeSpend() {\n        this._gauge -= GAUGE_GAIN_AMOUNT;\n        this._updateHistory();\n    }\n    _onGaugeGenerate() {\n        if (this.combatants.selected.hasStatus(STATUSES.DISSIPATION.id) || !this._fairyOut) {\n            // can't generate a guage without the fairy, so bail out\n            return;\n        }\n        this._gauge += GAUGE_GAIN_AMOUNT;\n        // figure out if we've capped and add to waste\n        if (this._gauge > GAUGE_MAX) {\n            this._gauge = GAUGE_MAX;\n            this._waste += GAUGE_GAIN_AMOUNT;\n        }\n        this._updateHistory();\n    }\n    _onDeath() {\n        this._fairyOut = false;\n        this._gauge = 0;\n        this._updateHistory();\n    }\n    _updateHistory() {\n        const ts = this.parser.currentTimestamp - this.parser.fight.start_time;\n        this._history.push({ t: ts, y: this._gauge });\n    }\n    _onComplete() {\n        // Warn on fairy not being out at the start\n        if (this._noFairyAtStart) {\n            this.suggestions.add(new Suggestion({\n                icon: ACTIONS.SUMMON_SERAPH.icon,\n                severity: SEVERITY.MEDIUM,\n                content: <Trans id=\"sch.gauge.nofairyatstart.content\">\n\t\t\t\t\tYour fairy is a considerable amount of your healing kit. Make sure to use <ActionLink {...ACTIONS.SUMMON_EOS}/> or <ActionLink {...ACTIONS.SUMMON_SELENE}/> prior to the start of combat\n\t\t\t\t</Trans>,\n                why: <Trans id=\"sch.gauge.nofairyatstart.why\">Your fairy was not summoned at the start of combat.</Trans>,\n            }));\n        }\n        // Suggest that they use their gauge consumers at certain overcap points\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.FEY_BLESSING.icon,\n            tiers: GAUGE_WASTE_SEVERITY,\n            value: this._waste,\n            content: <Trans id=\"sch.gauge.waste.suggestion.content\">Try to make use of your Faerie Gauge abilities <ActionLink {...ACTIONS.FEY_UNION}/> and <ActionLink {...ACTIONS.FEY_BLESSING}/>, since they are free oGCD heals that come naturally from using Aetherflow abilities.</Trans>,\n            why: <Trans id=\"sch.gauge.waste.suggestion.why\">A total of {this._waste} gauge was lost due to exceeding the cap.</Trans>,\n        }));\n    }\n    // Generate the gauge graph\n    output() {\n        const data = {\n            datasets: [\n                {\n                    label: 'Faerie Gauge',\n                    steppedLine: true,\n                    data: this._history,\n                    backgroundColor: GRAPH_COLOR.fade(BG_COLOR_FADE),\n                    borderColor: GRAPH_COLOR.fade(BORDER_COLOR_FADE),\n                },\n            ],\n        };\n        return <Fragment>\n\t\t\t<TimeLineChart data={data}/>\n\t\t\t<Trans id=\"sch.gauge.waste\">\n\t\t\t\tA total of {this._waste} Faerie Gauge was wasted due to overcapping.\n\t\t\t</Trans>\n\t\t</Fragment>;\n    }\n}\nFaerieGauge.handle = 'fairieGauge';\nFaerieGauge.title = t('sch.gauge.title') `Faerie Gauge Usage`;\nFaerieGauge.dependencies = [\n    'combatants',\n    'suggestions',\n];\n","import React from 'react';\nimport { t, Trans, Plural } from '@lingui/macro';\nimport { BuffWindowModule } from 'parser/core/modules/BuffWindow';\nimport { getDataBy } from 'data/getDataBy';\nimport ACTIONS from 'data/ACTIONS';\nimport STATUSES from 'data/STATUSES';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nimport DISPLAY_ORDER from './DISPLAY_ORDER';\nimport { ActionLink } from 'components/ui/DbLink';\nconst MISSED_SWIFTCASTS_SEVERITIES = {\n    1: SEVERITY.MAJOR,\n};\nexport default class Swiftcast extends BuffWindowModule {\n    constructor() {\n        super(...arguments);\n        this.buffAction = ACTIONS.SWIFTCAST;\n        this.buffStatus = STATUSES.SWIFTCAST;\n        this.rotationTableHeader = <Trans id=\"sch.swiftcast.title\">Swiftcast Actions</Trans>;\n    }\n    // override to ignore non-GCD casts\n    onCast(event) {\n        const action = getDataBy(ACTIONS, 'id', event.ability.guid);\n        if (!action || action.autoAttack || !action.castTime) {\n            return;\n        }\n        if (this.activeBuffWindow) {\n            this.activeBuffWindow.rotation.push(event);\n        }\n    }\n    // override since we're not really useing any of the other BuffWindow tracking features\n    onComplete() {\n        const missedSwifts = this.buffWindows.reduce((sum, buffWindow) => {\n            return sum + buffWindow.rotation.length ? 0 : 1;\n        }, 0);\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.SWIFTCAST.icon,\n            content: <Trans id=\"sch.swiftcast.missed.suggestion.content\">Use spells with <ActionLink {...ACTIONS.SWIFTCAST}/> before it expires. This allows you to use spells with cast time instantly, such as <ActionLink {...ACTIONS.RESURRECTION}/> for a quick revive, or <ActionLink {...ACTIONS.BROIL_III}/> for weaving.</Trans>,\n            tiers: MISSED_SWIFTCASTS_SEVERITIES,\n            value: missedSwifts,\n            why: <Trans id=\"sch.swiftcast.missed.suggestion.why\">\n\t\t\t\t{missedSwifts} <Plural value={missedSwifts} one=\"Swiftcast was\" other=\"Swiftcasts were\"/> wasted because you did not use a spell in time.\n\t\t\t</Trans>,\n        }));\n    }\n}\nSwiftcast.displayOrder = DISPLAY_ORDER.SWIFTCAST;\nSwiftcast.handle = 'swiftcast';\nSwiftcast.title = t('sch.swiftcast.title') `Swiftcast Actions`;\n","import React from 'react';\nimport { Table, Button } from 'semantic-ui-react';\nimport { Trans } from '@lingui/react';\nimport { t } from '@lingui/macro';\nimport Module from 'parser/core/Module';\nimport { getDataBy } from 'data';\nimport ACTIONS from 'data/ACTIONS';\nimport { ActionLink } from 'components/ui/DbLink';\nimport { TieredSuggestion, SEVERITY } from 'parser/core/modules/Suggestions';\nconst TIMELINE_UPPER_MOD = 30000;\nconst INTERRUPT_SEVERITY = {\n    2: SEVERITY.MEDIUM,\n    5: SEVERITY.MAJOR,\n};\nexport default class Interrupts extends Module {\n    constructor(...args) {\n        super(...args);\n        this._currentCast = null;\n        this._droppedCasts = [];\n        this._missedTimeMS = 0;\n        this.addEventHook('begincast', { by: 'player' }, this._onBeginCast);\n        this.addEventHook('cast', { by: 'player' }, this._onCast);\n        this.addEventHook('complete', this._onComplete);\n    }\n    _onBeginCast(event) {\n        // if they started casting something, then cancel and start something else, that's definitely an interrupted cast\n        if (this._currentCast) {\n            this._pushDropCasts(event);\n        }\n        this._currentCast = event;\n    }\n    _onCast(event) {\n        const guid = event.ability.guid;\n        // if the thing they started casting doesn't match up with what they cast, that's an interrupted cast\n        if (this._currentCast && guid !== this._currentCast.ability.guid) {\n            this._pushDropCasts(event);\n        }\n        this._currentCast = null;\n    }\n    _pushDropCasts(currentEvent) {\n        this._missedTimeMS += Math.min(this.gcd.getEstimate(), currentEvent.timestamp - this._currentCast.timestamp);\n        this._droppedCasts.push({\n            action: getDataBy(ACTIONS, 'id', this._currentCast.ability.guid),\n            timestamp: this._currentCast.timestamp,\n        });\n    }\n    _onComplete() {\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.INTERJECT.icon,\n            tiers: INTERRUPT_SEVERITY,\n            value: this._droppedCasts.length,\n            content: <Trans id=\"sch.interrupts.suggestion.content\">If you can, try to preposition yourself so you don't have to move during mechanics as much as possible. Utilizing slidecasting will lower the need to use <ActionLink {...ACTIONS.SCH_RUIN_II}/> to instantly relocate or interrupt your current Broil III cast</Trans>,\n            why: <Trans id=\"sch.interrupts.suggestion.why\">You missed {this._droppedCasts.length} casts (approximately {this.parser.formatDuration(this._missedTimeMS)} of total casting time) due to interruption.</Trans>,\n        }));\n    }\n    output() {\n        return <Table compact unstackable celled>\n\t\t\t<Table.Header>\n\t\t\t\t<Table.Row>\n\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t<strong><Trans id=\"sch.interrupts.table.time\">Time</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t<Table.HeaderCell>\n\t\t\t\t\t\t<strong><Trans id=\"sch.interrupts.table.cast\">Cast</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Header>\n\t\t\t<Table.Body>\n\t\t\t\t{this._droppedCasts.map((cast) => <Table.Row key={cast.timestamp}>\n\t\t\t\t\t\t\t<Table.Cell textAlign=\"center\">\n\t\t\t\t\t\t\t\t<span style={{ marginRight: 5 }}>{this.parser.formatTimestamp(cast.timestamp)}</span>\n\t\t\t\t\t\t\t\t<Button circular compact size=\"mini\" icon=\"time\" onClick={() => this.timeline.show(cast.timestamp - this.parser.fight.start_time, cast.timestamp - this.parser.fight.start_time + TIMELINE_UPPER_MOD)}/>\n\t\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t\t<Table.Cell>\n\t\t\t\t\t\t\t\t<ActionLink {...cast.action}/>\n\t\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t</Table.Row>)}\n\t\t\t</Table.Body>\n\t\t</Table>;\n    }\n}\nInterrupts.handle = 'interrupts';\nInterrupts.title = t('sch.interrupts.title') `Interrupted Casts`;\nInterrupts.dependencies = [\n    'timeline',\n    'gcd',\n    'suggestions',\n];\n","import Aetherflow from './Aetherflow';\nimport DoTs from './DoTs';\nimport Weaving from './Weaving';\nimport ChainStrat from './ChainStrat';\nimport FaerieGauge from './FaerieGauge';\nimport Swiftcast from './Swiftcast';\nimport Interrupts from './Interrupts';\nexport default [\n    Weaving,\n    Aetherflow,\n    DoTs,\n    ChainStrat,\n    FaerieGauge,\n    Swiftcast,\n    Interrupts,\n];\n"],"sourceRoot":""}
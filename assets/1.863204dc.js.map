{"version":3,"sources":["webpack:///./node_modules/mathjs/es/plain/number/arithmetic.js","webpack:///./node_modules/mathjs/es/plain/number/bitwise.js","webpack:///./node_modules/mathjs/es/plain/number/logical.js","webpack:///./node_modules/mathjs/es/utils/product.js","webpack:///./node_modules/mathjs/es/plain/number/combinations.js","webpack:///./node_modules/mathjs/es/plain/number/probability.js","webpack:///./node_modules/mathjs/es/plain/number/trigonometry.js","webpack:///./node_modules/mathjs/es/plain/number/utils.js","webpack:///./node_modules/mathjs/es/factoriesNumber.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesTyped.generated.js","webpack:///./node_modules/mathjs/es/utils/is.js","webpack:///./node_modules/mathjs/es/utils/factory.js","webpack:///./node_modules/mathjs/es/utils/number.js","webpack:///./node_modules/mathjs/es/utils/array.js","webpack:///./node_modules/mathjs/es/utils/object.js","webpack:///./node_modules/mathjs/es/error/IndexError.js","webpack:///./node_modules/mathjs/es/utils/log.js","webpack:///./node_modules/mathjs/es/utils/collection.js","webpack:///./node_modules/mathjs/es/error/DimensionError.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesAdd.generated.js","webpack:///./node_modules/mathjs/es/core/function/typed.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesDivide.generated.js","webpack:///./node_modules/mathjs/es/function/statistics/mean.js","webpack:///./node_modules/mathjs/es/function/statistics/utils/improveErrorMessage.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesIsNaN.generated.js","webpack:///./node_modules/mathjs/es/function/utils/isNumeric.js","webpack:///./node_modules/mathjs/es/function/statistics/mode.js","webpack:///./node_modules/mathjs/es/function/matrix/apply.js","webpack:///./node_modules/mathjs/es/function/statistics/variance.js","webpack:///./node_modules/mathjs/es/function/statistics/std.js","webpack:///./node_modules/tiny-emitter/index.js","webpack:///./node_modules/typed-function/typed-function.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesMean.generated.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesSqrt.generated.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesIsInteger.generated.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesApply.generated.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesMultiply.generated.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesSubtract.generated.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesVariance.generated.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesStd.generated.js","webpack:///./node_modules/mathjs/es/error/ArgumentsError.js","webpack:///./node_modules/mathjs/es/core/function/import.js","webpack:///./node_modules/mathjs/es/core/config.js","webpack:///./node_modules/mathjs/es/core/function/config.js","webpack:///./node_modules/mathjs/es/core/create.js","webpack:///./node_modules/mathjs/es/utils/emitter.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesIsNumeric.generated.js","webpack:///./node_modules/mathjs/es/entry/dependenciesNumber/dependenciesMode.generated.js"],"names":["n1","n2","absNumber","a","Math","abs","addNumber","b","subtractNumber","multiplyNumber","divideNumber","unaryMinusNumber","x","unaryPlusNumber","cbrtNumber","ceilNumber","ceil","cubeNumber","expNumber","exp","expm1Number","fixNumber","floor","floorNumber","gcdNumber","Error","r","lcmNumber","t","prod","logNumber","log","log10Number","log2Number","log1pNumber","modNumber","y","signNumber","sqrtNumber","sqrt","squareNumber","xgcdNumber","q","lastx","lasty","powNumber","Infinity","pow","normNumber","signature","bitAndNumber","bitNotNumber","bitOrNumber","bitXorNumber","leftShiftNumber","rightArithShiftNumber","rightLogShiftNumber","notNumber","orNumber","xorNumber","andNumber","product","i","n","half","combinationsNumber","k","TypeError","nMinusk","gammaNumber","isFinite","NaN","PI","sin","twoN","threeN","fourN","fiveN","E","gammaP","length","gammaG","acosNumber","acos","acoshNumber","acotNumber","atan","acothNumber","acscNumber","asin","acschNumber","xInv","asecNumber","asechNumber","ret","asinNumber","asinhNumber","atanNumber","atan2Number","atan2","atanhNumber","cosNumber","cos","coshNumber","cotNumber","tan","cothNumber","e","cscNumber","cschNumber","Number","POSITIVE_INFINITY","secNumber","sechNumber","sinNumber","sinhNumber","tanNumber","tanhNumber","isIntegerNumber","isNegativeNumber","isPositiveNumber","isZeroNumber","isNaNNumber","isNaN","createMultiply","createNumberFactory","createSqrt","createSubtract","createAdd","createDivide","createIsInteger","createIsNaN","name","fn","factory","_ref","typed","typedDependencies","createTyped","_typeof","obj","Symbol","iterator","constructor","prototype","isNumber","isBigNumber","isComplex","Object","getPrototypeOf","isFraction","isUnit","isString","isArray","Array","isMatrix","isCollection","isDenseMatrix","isSparseMatrix","isRange","isIndex","isBoolean","isResultSet","isHelp","isFunction","isDate","Date","isRegExp","RegExp","isObject","isNull","isUndefined","undefined","isAccessorNode","isNode","isArrayNode","isAssignmentNode","isBlockNode","isConditionalNode","isConstantNode","isFunctionAssignmentNode","isFunctionNode","isIndexNode","isObjectNode","isOperatorNode","isParenthesisNode","isRangeNode","isSymbolNode","isChain","typeOf","type","dependencies","create","meta","assertAndCreate","scope","deps","map","stripOptionalNotation","filter","dependency","isOptionalDependency","every","missingDependencies","concat","d","join","assertDependencies","isFactory","slice","sort","isInteger","value","round","sign","log2","LN2","log10","LN10","log1p","cbrt","result","negate","expm1","format","options","precision","notation","toFixed","toExponential","String","rounded","roundDigits","splitNumber","exponent","c","coefficients","newExp","push","significandsDiff","expDiff","decimalIdx","decimals","decimalVal","match","str","toString","toEngineering","exponential","lower","upper","fixedOptions","lowerExp","upperExp","console","warn","JSON","stringify","toPrecision","replace","digits","arguments","toLowerCase","SyntaxError","parseFloat","dot","indexOf","zeros","split","parseInt","splitValue","p","pp","splice","first","shift","unshift","pop","arr","EPSILON","acosh","asinh","atanh","cosh","sinh","tanh","arraySize","s","flatten","array","flat","forEach","callback","last","initial","contains","item","clone","valueOf","mapObject","object","key","hasOwnProperty","deepExtend","prop","deepFlatten","nestedObject","flattenedObject","_deepFlatten","lazy","valueResolver","_value","_uninitialized","defineProperty","get","set","configurable","enumerable","traverse","path","property","call","isLegacyFactory","pickShallow","properties","copy","values","keys","IndexError","index","min","max","this","message","stack","RangeError","isIndexError","messages","warnOnce","_len","args","_key","_console","apply","containsCollections","deepForEach","ii","deepMap","skipZeros","reduce","mat","dim","size","_reduce","val","tran","j","I","J","tmp","_switch","DimensionError","actual","expected","relation","isDimensionError","addDependencies","_createTyped2","BigNumber","Complex","DenseMatrix","Fraction","types","test","conversions","from","to","convert","throwNoBignumber","throwNoComplex","toNumber","throwNoFraction","f","err","throwNoMatrix","matrix","divideDependencies","createMean","add","divide","_mean","sum","num","improveErrorMessage","fnName","details","data","isNaNDependencies","createIsNumeric","isNumeric","createMode","_mode","count","mode","createApply","_apply","createVariance","subtract","multiply","_var","_varDim","normalization","mean","diff","zero","mul","createStd","variance","_std","on","ctx","once","self","listener","off","_","emit","evtArr","len","evts","liveEvents","module","exports","TinyEmitter","ok","notOk","undef","_types","anyType","_ignore","_conversions","ignore","findTypeByName","typeName","entry","findInArray","hint","findTypeIndex","findTypeName","stringifyParams","params","param","typeNames","getTypeName","restParam","parseParam","trim","notEmpty","notIgnore","matchingConversions","matches","conversion","filterConversions","exactTypes","typeIndex","conversionIndex","convertibleTypes","hasRestParam","hasConversions","some","compileTest","test0","test1","tests","compileTests","varIndex","lastTest","testRestParam","getParamAtIndex","getExpectedTypeNames","excludeConversions","isExactType","mergeExpectedParams","signatures","entries","uniq","flatMap","createError","_name","matchingSignatures","nextMatchingDefs","actualType","category","lengths","maxLength","expectedLength","getLowestTypeIndex","getLowestConversionIndex","compareParams","param1","param2","compareSignatures","signature1","signature2","compileArgConversion","conversion0","conversion1","arg","splitParams","ignoreConversionTypes","_splitParams","typeGroups","filteredTypes","typeGroup","createTypedFunction","signaturesMap","parsedSignatures","parsedParam","isInvalidParam","parseSignature","notNull","parsedSignature","conflictingSignature","hasOverlap","len1","len2","restParam1","restParam2","hasConflictingParams","ok0","ok1","ok2","ok3","ok4","ok5","allOk","test00","test10","test20","test30","test40","test50","test01","test11","test21","test31","test41","test51","fns","fnConvert","compiledConversions","fnPreprocess","offset","compileArgsPreprocessing","fn0","fn1","fn2","fn3","fn4","fn5","len0","len3","len4","len5","iStart","iEnd","generic","arg0","arg1","createSignaturesMap","start","end","array1","array2","getName","extractSignatures","validateUnique","_signature","_fn","find","addType","beforeObjectTest","addConversion","meanDependencies","sqrtDependencies","isIntegerDependencies","applyDependencies","multiplyDependencies","subtractDependencies","varianceDependencies","stdDependencies","ArgumentsError","isArgumentsError","importFactory","load","math","importedFactories","_import","wrap","wrapper","transform","_wrap","writable","_defineProperty","isTypedFunction","override","_importTransform","silent","expression","allowedInExpressions","mathWithTransform","_deleteTransform","_importFactory","namespace","isTransformFunctionFactory","existingTransform","existing","resolver","classes","instance","factoryAllowedInExpressions","unsafe","legacyFactoryAllowedInExpressions","isClass","isTransformFunction","docs","error","json","chain","functions","flatValues","flattenImports","_importLegacyFactory","flatName","is","DEFAULT_CONFIG","epsilon","number","predictable","randomSeed","MATRIX_OPTIONS","NUMBER_OPTIONS","validateOption","findIndex","_extends","assign","target","source","factories","config","configInternal","emitter","bind","_config","prev","curr","changes","configFactory","legacyFactories","legacyInstances","internalImport","firstProperty","recreateOnConfigChange","fullName","parts","isNumericDependencies","modeDependencies"],"mappings":"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","file":"assets/1.863204dc.js","sourcesContent":["import { isInteger, log2, log10, cbrt, expm1, sign, toFixed, log1p } from '../../utils/number';\nvar n1 = 'number';\nvar n2 = 'number, number';\nexport function absNumber(a) {\n  return Math.abs(a);\n}\nabsNumber.signature = n1;\nexport function addNumber(a, b) {\n  return a + b;\n}\naddNumber.signature = n2;\nexport function subtractNumber(a, b) {\n  return a - b;\n}\nsubtractNumber.signature = n2;\nexport function multiplyNumber(a, b) {\n  return a * b;\n}\nmultiplyNumber.signature = n2;\nexport function divideNumber(a, b) {\n  return a / b;\n}\ndivideNumber.signature = n2;\nexport function unaryMinusNumber(x) {\n  return -x;\n}\nunaryMinusNumber.signature = n1;\nexport function unaryPlusNumber(x) {\n  return x;\n}\nunaryPlusNumber.signature = n1;\nexport function cbrtNumber(x) {\n  return cbrt(x);\n}\ncbrtNumber.signature = n1;\nexport function ceilNumber(x) {\n  return Math.ceil(x);\n}\nceilNumber.signature = n1;\nexport function cubeNumber(x) {\n  return x * x * x;\n}\ncubeNumber.signature = n1;\nexport function expNumber(x) {\n  return Math.exp(x);\n}\nexpNumber.signature = n1;\nexport function expm1Number(x) {\n  return expm1(x);\n}\nexpm1Number.signature = n1;\nexport function fixNumber(x) {\n  return x > 0 ? Math.floor(x) : Math.ceil(x);\n}\nfixNumber.signature = n1;\nexport function floorNumber(x) {\n  return Math.floor(x);\n}\nfloorNumber.signature = n1;\n/**\n * Calculate gcd for numbers\n * @param {number} a\n * @param {number} b\n * @returns {number} Returns the greatest common denominator of a and b\n */\n\nexport function gcdNumber(a, b) {\n  if (!isInteger(a) || !isInteger(b)) {\n    throw new Error('Parameters in function gcd must be integer numbers');\n  } // https://en.wikipedia.org/wiki/Euclidean_algorithm\n\n\n  var r;\n\n  while (b !== 0) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n\n  return a < 0 ? -a : a;\n}\ngcdNumber.signature = n2;\n/**\n * Calculate lcm for two numbers\n * @param {number} a\n * @param {number} b\n * @returns {number} Returns the least common multiple of a and b\n */\n\nexport function lcmNumber(a, b) {\n  if (!isInteger(a) || !isInteger(b)) {\n    throw new Error('Parameters in function lcm must be integer numbers');\n  }\n\n  if (a === 0 || b === 0) {\n    return 0;\n  } // https://en.wikipedia.org/wiki/Euclidean_algorithm\n  // evaluate lcm here inline to reduce overhead\n\n\n  var t;\n  var prod = a * b;\n\n  while (b !== 0) {\n    t = b;\n    b = a % t;\n    a = t;\n  }\n\n  return Math.abs(prod / a);\n}\nlcmNumber.signature = n2;\n/**\n * Calculate the logarithm of a value.\n * @param {number} x\n * @return {number}\n */\n\nexport function logNumber(x) {\n  return Math.log(x);\n}\nlogNumber.signature = n1;\n/**\n * Calculate the 10-base logarithm of a number\n * @param {number} x\n * @return {number}\n */\n\nexport function log10Number(x) {\n  return log10(x);\n}\nlog10Number.signature = n1;\n/**\n * Calculate the 2-base logarithm of a number\n * @param {number} x\n * @return {number}\n */\n\nexport function log2Number(x) {\n  return log2(x);\n}\nlog2Number.signature = n1;\n/**\n * Calculate the natural logarithm of a `number+1`\n * @param {number} x\n * @returns {number}\n */\n\nexport function log1pNumber(x) {\n  return log1p(x);\n}\nlog1pNumber.signature = n1;\n/**\n * Calculate the modulus of two numbers\n * @param {number} x\n * @param {number} y\n * @returns {number} res\n * @private\n */\n\nexport function modNumber(x, y) {\n  if (y > 0) {\n    // We don't use JavaScript's % operator here as this doesn't work\n    // correctly for x < 0 and x === 0\n    // see https://en.wikipedia.org/wiki/Modulo_operation\n    return x - y * Math.floor(x / y);\n  } else if (y === 0) {\n    return x;\n  } else {\n    // y < 0\n    // TODO: implement mod for a negative divisor\n    throw new Error('Cannot calculate mod for a negative divisor');\n  }\n}\nmodNumber.signature = n2;\n/**\n * Calculate the nth root of a, solve x^root == a\n * http://rosettacode.org/wiki/Nth_root#JavaScript\n * @param {number} a\n * @param {number} root\n * @private\n */\n\nexport function nthRootNumber(a, root) {\n  var inv = root < 0;\n\n  if (inv) {\n    root = -root;\n  }\n\n  if (root === 0) {\n    throw new Error('Root must be non-zero');\n  }\n\n  if (a < 0 && Math.abs(root) % 2 !== 1) {\n    throw new Error('Root must be odd when a is negative.');\n  } // edge cases zero and infinity\n\n\n  if (a === 0) {\n    return inv ? Infinity : 0;\n  }\n\n  if (!isFinite(a)) {\n    return inv ? 0 : a;\n  }\n\n  var x = Math.pow(Math.abs(a), 1 / root); // If a < 0, we require that root is an odd integer,\n  // so (-1) ^ (1/root) = -1\n\n  x = a < 0 ? -x : x;\n  return inv ? 1 / x : x; // Very nice algorithm, but fails with nthRoot(-2, 3).\n  // Newton's method has some well-known problems at times:\n  // https://en.wikipedia.org/wiki/Newton%27s_method#Failure_analysis\n\n  /*\n  let x = 1 // Initial guess\n  let xPrev = 1\n  let i = 0\n  const iMax = 10000\n  do {\n    const delta = (a / Math.pow(x, root - 1) - x) / root\n    xPrev = x\n    x = x + delta\n    i++\n  }\n  while (xPrev !== x && i < iMax)\n   if (xPrev !== x) {\n    throw new Error('Function nthRoot failed to converge')\n  }\n   return inv ? 1 / x : x\n  */\n}\nnthRootNumber.signature = n2;\nexport function signNumber(x) {\n  return sign(x);\n}\nsignNumber.signature = n1;\nexport function sqrtNumber(x) {\n  return Math.sqrt(x);\n}\nsqrtNumber.signature = n1;\nexport function squareNumber(x) {\n  return x * x;\n}\nsquareNumber.signature = n1;\n/**\n * Calculate xgcd for two numbers\n * @param {number} a\n * @param {number} b\n * @return {number} result\n * @private\n */\n\nexport function xgcdNumber(a, b) {\n  // source: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n  var t; // used to swap two variables\n\n  var q; // quotient\n\n  var r; // remainder\n\n  var x = 0;\n  var lastx = 1;\n  var y = 1;\n  var lasty = 0;\n\n  if (!isInteger(a) || !isInteger(b)) {\n    throw new Error('Parameters in function xgcd must be integer numbers');\n  }\n\n  while (b) {\n    q = Math.floor(a / b);\n    r = a - q * b;\n    t = x;\n    x = lastx - q * x;\n    lastx = t;\n    t = y;\n    y = lasty - q * y;\n    lasty = t;\n    a = b;\n    b = r;\n  }\n\n  var res;\n\n  if (a < 0) {\n    res = [-a, -lastx, -lasty];\n  } else {\n    res = [a, a ? lastx : 0, lasty];\n  }\n\n  return res;\n}\nxgcdNumber.signature = n2;\n/**\n * Calculates the power of x to y, x^y, for two numbers.\n * @param {number} x\n * @param {number} y\n * @return {number} res\n */\n\nexport function powNumber(x, y) {\n  // x^Infinity === 0 if -1 < x < 1\n  // A real number 0 is returned instead of complex(0)\n  if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {\n    return 0;\n  }\n\n  return Math.pow(x, y);\n}\npowNumber.signature = n2;\n/**\n * round a number to the given number of decimals, or to zero if decimals is\n * not provided\n * @param {number} value\n * @param {number} decimals       number of decimals, between 0 and 15 (0 by default)\n * @return {number} roundedValue\n */\n\nexport function roundNumber(value) {\n  var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return parseFloat(toFixed(value, decimals));\n}\nroundNumber.signature = n2;\n/**\n * Calculate the norm of a number, the absolute value.\n * @param {number} x\n * @return {number}\n */\n\nexport function normNumber(x) {\n  return Math.abs(x);\n}\nnormNumber.signature = n1;","import { isInteger } from '../../utils/number';\nvar n1 = 'number';\nvar n2 = 'number, number';\nexport function bitAndNumber(x, y) {\n  if (!isInteger(x) || !isInteger(y)) {\n    throw new Error('Integers expected in function bitAnd');\n  }\n\n  return x & y;\n}\nbitAndNumber.signature = n2;\nexport function bitNotNumber(x) {\n  if (!isInteger(x)) {\n    throw new Error('Integer expected in function bitNot');\n  }\n\n  return ~x;\n}\nbitNotNumber.signature = n1;\nexport function bitOrNumber(x, y) {\n  if (!isInteger(x) || !isInteger(y)) {\n    throw new Error('Integers expected in function bitOr');\n  }\n\n  return x | y;\n}\nbitOrNumber.signature = n2;\nexport function bitXorNumber(x, y) {\n  if (!isInteger(x) || !isInteger(y)) {\n    throw new Error('Integers expected in function bitXor');\n  }\n\n  return x ^ y;\n}\nbitXorNumber.signature = n2;\nexport function leftShiftNumber(x, y) {\n  if (!isInteger(x) || !isInteger(y)) {\n    throw new Error('Integers expected in function leftShift');\n  }\n\n  return x << y;\n}\nleftShiftNumber.signature = n2;\nexport function rightArithShiftNumber(x, y) {\n  if (!isInteger(x) || !isInteger(y)) {\n    throw new Error('Integers expected in function rightArithShift');\n  }\n\n  return x >> y;\n}\nrightArithShiftNumber.signature = n2;\nexport function rightLogShiftNumber(x, y) {\n  if (!isInteger(x) || !isInteger(y)) {\n    throw new Error('Integers expected in function rightLogShift');\n  }\n\n  return x >>> y;\n}\nrightLogShiftNumber.signature = n2;","var n1 = 'number';\nvar n2 = 'number, number';\nexport function notNumber(x) {\n  return !x;\n}\nnotNumber.signature = n1;\nexport function orNumber(x, y) {\n  return !!(x || y);\n}\norNumber.signature = n2;\nexport function xorNumber(x, y) {\n  return !!x !== !!y;\n}\nxorNumber.signature = n2;\nexport function andNumber(x, y) {\n  return !!(x && y);\n}\nandNumber.signature = n2;","/** @param {number} i\n *  @param {number} n\n *  @returns {number} product of i to n\n */\nexport function product(i, n) {\n  if (n < i) {\n    return 1;\n  }\n\n  if (n === i) {\n    return n;\n  }\n\n  var half = n + i >> 1; // divide (n + i) by 2 and truncate to integer\n\n  return product(i, half) * product(half + 1, n);\n}","import { isInteger } from '../../utils/number';\nimport { product } from '../../utils/product';\nexport function combinationsNumber(n, k) {\n  if (!isInteger(n) || n < 0) {\n    throw new TypeError('Positive integer value expected in function combinations');\n  }\n\n  if (!isInteger(k) || k < 0) {\n    throw new TypeError('Positive integer value expected in function combinations');\n  }\n\n  if (k > n) {\n    throw new TypeError('k must be less than or equal to n');\n  }\n\n  var nMinusk = n - k;\n  var prodrange;\n\n  if (k < nMinusk) {\n    prodrange = product(nMinusk + 1, n);\n    return prodrange / product(1, k);\n  }\n\n  prodrange = product(k + 1, n);\n  return prodrange / product(1, nMinusk);\n}\ncombinationsNumber.signature = 'number, number';","import { isInteger } from '../../utils/number';\nimport { product } from '../../utils/product';\nexport function gammaNumber(n) {\n  var x;\n\n  if (isInteger(n)) {\n    if (n <= 0) {\n      return isFinite(n) ? Infinity : NaN;\n    }\n\n    if (n > 171) {\n      return Infinity; // Will overflow\n    }\n\n    return product(1, n - 1);\n  }\n\n  if (n < 0.5) {\n    return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));\n  }\n\n  if (n >= 171.35) {\n    return Infinity; // will overflow\n  }\n\n  if (n > 85.0) {\n    // Extended Stirling Approx\n    var twoN = n * n;\n    var threeN = twoN * n;\n    var fourN = threeN * n;\n    var fiveN = fourN * n;\n    return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));\n  }\n\n  --n;\n  x = gammaP[0];\n\n  for (var i = 1; i < gammaP.length; ++i) {\n    x += gammaP[i] / (n + i);\n  }\n\n  var t = n + gammaG + 0.5;\n  return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;\n}\ngammaNumber.signature = 'number'; // TODO: comment on the variables g and p\n\nexport var gammaG = 4.7421875;\nexport var gammaP = [0.99999999999999709182, 57.156235665862923517, -59.597960355475491248, 14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4, 0.46523628927048575665e-4, -0.98374475304879564677e-4, 0.15808870322491248884e-3, -0.21026444172410488319e-3, 0.21743961811521264320e-3, -0.16431810653676389022e-3, 0.84418223983852743293e-4, -0.26190838401581408670e-4, 0.36899182659531622704e-5];","import { acosh, asinh, atanh, cosh, sign, sinh, tanh } from '../../utils/number';\nvar n1 = 'number';\nvar n2 = 'number, number';\nexport function acosNumber(x) {\n  return Math.acos(x);\n}\nacosNumber.signature = n1;\nexport function acoshNumber(x) {\n  return acosh(x);\n}\nacoshNumber.signature = n1;\nexport function acotNumber(x) {\n  return Math.atan(1 / x);\n}\nacotNumber.signature = n1;\nexport function acothNumber(x) {\n  return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;\n}\nacothNumber.signature = n1;\nexport function acscNumber(x) {\n  return Math.asin(1 / x);\n}\nacscNumber.signature = n1;\nexport function acschNumber(x) {\n  var xInv = 1 / x;\n  return Math.log(xInv + Math.sqrt(xInv * xInv + 1));\n}\nacschNumber.signature = n1;\nexport function asecNumber(x) {\n  return Math.acos(1 / x);\n}\nasecNumber.signature = n1;\nexport function asechNumber(x) {\n  var xInv = 1 / x;\n  var ret = Math.sqrt(xInv * xInv - 1);\n  return Math.log(ret + xInv);\n}\nasechNumber.signature = n1;\nexport function asinNumber(x) {\n  return Math.asin(x);\n}\nasinNumber.signature = n1;\nexport function asinhNumber(x) {\n  return asinh(x);\n}\nasinhNumber.signature = n1;\nexport function atanNumber(x) {\n  return Math.atan(x);\n}\natanNumber.signature = n1;\nexport function atan2Number(y, x) {\n  return Math.atan2(y, x);\n}\natan2Number.signature = n2;\nexport function atanhNumber(x) {\n  return atanh(x);\n}\natanhNumber.signature = n1;\nexport function cosNumber(x) {\n  return Math.cos(x);\n}\ncosNumber.signature = n1;\nexport function coshNumber(x) {\n  return cosh(x);\n}\ncoshNumber.signature = n1;\nexport function cotNumber(x) {\n  return 1 / Math.tan(x);\n}\ncotNumber.signature = n1;\nexport function cothNumber(x) {\n  var e = Math.exp(2 * x);\n  return (e + 1) / (e - 1);\n}\ncothNumber.signature = n1;\nexport function cscNumber(x) {\n  return 1 / Math.sin(x);\n}\ncscNumber.signature = n1;\nexport function cschNumber(x) {\n  // consider values close to zero (+/-)\n  if (x === 0) {\n    return Number.POSITIVE_INFINITY;\n  } else {\n    return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign(x);\n  }\n}\ncschNumber.signature = n1;\nexport function secNumber(x) {\n  return 1 / Math.cos(x);\n}\nsecNumber.signature = n1;\nexport function sechNumber(x) {\n  return 2 / (Math.exp(x) + Math.exp(-x));\n}\nsechNumber.signature = n1;\nexport function sinNumber(x) {\n  return Math.sin(x);\n}\nsinNumber.signature = n1;\nexport function sinhNumber(x) {\n  return sinh(x);\n}\nsinhNumber.signature = n1;\nexport function tanNumber(x) {\n  return Math.tan(x);\n}\ntanNumber.signature = n1;\nexport function tanhNumber(x) {\n  return tanh(x);\n}\ntanhNumber.signature = n1;","import { isInteger } from '../../utils/number';\nvar n1 = 'number';\nexport function isIntegerNumber(x) {\n  return isInteger(x);\n}\nisIntegerNumber.signature = n1;\nexport function isNegativeNumber(x) {\n  return x < 0;\n}\nisNegativeNumber.signature = n1;\nexport function isPositiveNumber(x) {\n  return x > 0;\n}\nisPositiveNumber.signature = n1;\nexport function isZeroNumber(x) {\n  return x === 0;\n}\nisZeroNumber.signature = n1;\nexport function isNaNNumber(x) {\n  return Number.isNaN(x);\n}\nisNaNNumber.signature = n1;","import { absNumber, acoshNumber, acosNumber, acothNumber, acotNumber, acschNumber, acscNumber, addNumber, andNumber, asechNumber, asecNumber, asinhNumber, asinNumber, atan2Number, atanhNumber, atanNumber, bitAndNumber, bitNotNumber, bitOrNumber, bitXorNumber, cbrtNumber, ceilNumber, combinationsNumber, coshNumber, cosNumber, cothNumber, cotNumber, cschNumber, cscNumber, cubeNumber, divideNumber, expm1Number, expNumber, fixNumber, floorNumber, gammaNumber, gcdNumber, isIntegerNumber, isNaNNumber, isNegativeNumber, isPositiveNumber, isZeroNumber, lcmNumber, leftShiftNumber, log10Number, log1pNumber, log2Number, logNumber, modNumber, multiplyNumber, normNumber, notNumber, orNumber, powNumber, rightArithShiftNumber, rightLogShiftNumber, sechNumber, secNumber, signNumber, sinhNumber, sinNumber, sqrtNumber, squareNumber, subtractNumber, tanhNumber, tanNumber, unaryMinusNumber, unaryPlusNumber, xgcdNumber, xorNumber } from './plain/number';\nimport { factory } from './utils/factory';\nimport { noIndex, noMatrix, noSubset } from './utils/noop'; // ----------------------------------------------------------------------------\n// classes and functions\n// core\n\nexport { createTyped } from './core/function/typed'; // classes\n\nexport { createResultSet } from './type/resultset/ResultSet';\nexport { createRangeClass } from './type/matrix/Range';\nexport { createHelpClass } from './expression/Help';\nexport { createChainClass } from './type/chain/Chain';\nexport { createHelp } from './expression/function/help';\nexport { createChain } from './type/chain/function/chain'; // algebra\n\nexport { createSimplify } from './function/algebra/simplify';\nexport { createDerivative } from './function/algebra/derivative';\nexport { createRationalize } from './function/algebra/rationalize'; // arithmetic\n\nexport var createUnaryMinus =\n/* #__PURE__ */\ncreateNumberFactory('unaryMinus', unaryMinusNumber);\nexport var createUnaryPlus =\n/* #__PURE__ */\ncreateNumberFactory('unaryPlus', unaryPlusNumber);\nexport var createAbs =\n/* #__PURE__ */\ncreateNumberFactory('abs', absNumber);\nexport var createAddScalar =\n/* #__PURE__ */\ncreateNumberFactory('addScalar', addNumber);\nexport var createCbrt =\n/* #__PURE__ */\ncreateNumberFactory('cbrt', cbrtNumber);\nexport var createCeil =\n/* #__PURE__ */\ncreateNumberFactory('ceil', ceilNumber);\nexport var createCube =\n/* #__PURE__ */\ncreateNumberFactory('cube', cubeNumber);\nexport var createExp =\n/* #__PURE__ */\ncreateNumberFactory('exp', expNumber);\nexport var createExpm1 =\n/* #__PURE__ */\ncreateNumberFactory('expm1', expm1Number);\nexport var createFix =\n/* #__PURE__ */\ncreateNumberFactory('fix', fixNumber);\nexport var createFloor =\n/* #__PURE__ */\ncreateNumberFactory('floor', floorNumber);\nexport var createGcd =\n/* #__PURE__ */\ncreateNumberFactory('gcd', gcdNumber);\nexport var createLcm =\n/* #__PURE__ */\ncreateNumberFactory('lcm', lcmNumber);\nexport var createLog10 =\n/* #__PURE__ */\ncreateNumberFactory('log10', log10Number);\nexport var createLog2 =\n/* #__PURE__ */\ncreateNumberFactory('log2', log2Number);\nexport var createMod =\n/* #__PURE__ */\ncreateNumberFactory('mod', modNumber);\nexport var createMultiplyScalar =\n/* #__PURE__ */\ncreateNumberFactory('multiplyScalar', multiplyNumber);\nexport var createMultiply =\n/* #__PURE__ */\ncreateNumberFactory('multiply', multiplyNumber);\nexport { createNthRootNumber as createNthRoot } from './function/arithmetic/nthRoot';\nexport var createSign =\n/* #__PURE__ */\ncreateNumberFactory('sign', signNumber);\nexport var createSqrt =\n/* #__PURE__ */\ncreateNumberFactory('sqrt', sqrtNumber);\nexport var createSquare =\n/* #__PURE__ */\ncreateNumberFactory('square', squareNumber);\nexport var createSubtract =\n/* #__PURE__ */\ncreateNumberFactory('subtract', subtractNumber);\nexport var createXgcd =\n/* #__PURE__ */\ncreateNumberFactory('xgcd', xgcdNumber);\nexport var createDivideScalar =\n/* #__PURE__ */\ncreateNumberFactory('divideScalar', divideNumber);\nexport var createPow =\n/* #__PURE__ */\ncreateNumberFactory('pow', powNumber);\nexport { createRoundNumber as createRound } from './function/arithmetic/round';\nexport var createLog =\n/* #__PURE__ */\ncreateNumberFactory('log', logNumber);\nexport var createLog1p =\n/* #__PURE__ */\ncreateNumberFactory('log1p', log1pNumber);\nexport var createAdd =\n/* #__PURE__ */\ncreateNumberFactory('add', addNumber);\nexport { createHypot } from './function/arithmetic/hypot';\nexport var createNorm =\n/* #__PURE__ */\ncreateNumberFactory('norm', normNumber);\nexport var createDivide =\n/* #__PURE__ */\ncreateNumberFactory('divide', divideNumber); // bitwise\n\nexport var createBitAnd =\n/* #__PURE__ */\ncreateNumberFactory('bitAnd', bitAndNumber);\nexport var createBitNot =\n/* #__PURE__ */\ncreateNumberFactory('bitNot', bitNotNumber);\nexport var createBitOr =\n/* #__PURE__ */\ncreateNumberFactory('bitOr', bitOrNumber);\nexport var createBitXor =\n/* #__PURE__ */\ncreateNumberFactory('bitXor', bitXorNumber);\nexport var createLeftShift =\n/* #__PURE__ */\ncreateNumberFactory('leftShift', leftShiftNumber);\nexport var createRightArithShift =\n/* #__PURE__ */\ncreateNumberFactory('rightArithShift', rightArithShiftNumber);\nexport var createRightLogShift =\n/* #__PURE__ */\ncreateNumberFactory('rightLogShift', rightLogShiftNumber); // combinatorics\n\nexport { createStirlingS2 } from './function/combinatorics/stirlingS2';\nexport { createBellNumbers } from './function/combinatorics/bellNumbers';\nexport { createCatalan } from './function/combinatorics/catalan';\nexport { createComposition } from './function/combinatorics/composition'; // constants\n\nexport { createE, createUppercaseE, createFalse // createI,\n, createInfinity, createLN10, createLN2, createLOG10E, createLOG2E, createNaN, createNull, createPhi, createPi, createUppercasePi, createSQRT1_2 // eslint-disable-line camelcase\n, createSQRT2, createTau, createTrue, createVersion } from './constants'; // create\n\nexport { createNumber } from './type/number';\nexport { createString } from './type/string';\nexport { createBoolean } from './type/boolean';\nexport { createParser } from './expression/function/parser'; // expression\n\nexport { createNode } from './expression/node/Node';\nexport { createAccessorNode } from './expression/node/AccessorNode';\nexport { createArrayNode } from './expression/node/ArrayNode';\nexport { createAssignmentNode } from './expression/node/AssignmentNode';\nexport { createBlockNode } from './expression/node/BlockNode';\nexport { createConditionalNode } from './expression/node/ConditionalNode';\nexport { createConstantNode } from './expression/node/ConstantNode';\nexport { createFunctionAssignmentNode } from './expression/node/FunctionAssignmentNode';\nexport { createIndexNode } from './expression/node/IndexNode';\nexport { createObjectNode } from './expression/node/ObjectNode';\nexport { createOperatorNode } from './expression/node/OperatorNode';\nexport { createParenthesisNode } from './expression/node/ParenthesisNode';\nexport { createRangeNode } from './expression/node/RangeNode';\nexport { createRelationalNode } from './expression/node/RelationalNode';\nexport { createSymbolNode } from './expression/node/SymbolNode';\nexport { createFunctionNode } from './expression/node/FunctionNode';\nexport { createParse } from './expression/parse';\nexport { createCompile } from './expression/function/compile';\nexport { createEvaluate } from './expression/function/evaluate';\nexport { createParserClass } from './expression/Parser'; // logical\n\nexport var createAnd =\n/* #__PURE__ */\ncreateNumberFactory('and', andNumber);\nexport var createNot =\n/* #__PURE__ */\ncreateNumberFactory('not', notNumber);\nexport var createOr =\n/* #__PURE__ */\ncreateNumberFactory('or', orNumber);\nexport var createXor =\n/* #__PURE__ */\ncreateNumberFactory('xor', xorNumber); // matrix\n\nexport { createApply } from './function/matrix/apply';\nexport { createFilter } from './function/matrix/filter';\nexport { createForEach } from './function/matrix/forEach';\nexport { createMap } from './function/matrix/map';\nexport { createRange } from './function/matrix/range';\nexport { createSize } from './function/matrix/size'; // FIXME: create a lightweight \"number\" implementation of subset only supporting plain objects/arrays\n\nexport var createIndex =\n/* #__PURE__ */\nfactory('index', [], function () {\n  return noIndex;\n});\nexport var createMatrix =\n/* #__PURE__ */\nfactory('matrix', [], function () {\n  return noMatrix;\n}); // FIXME: needed now because subset transform needs it. Remove the need for it in subset\n\nexport var createSubset =\n/* #__PURE__ */\nfactory('subset', [], function () {\n  return noSubset;\n}); // TODO: provide number+array implementations for map, filter, forEach, zeros, ...?\n// TODO: create range implementation for range?\n\nexport { createPartitionSelect } from './function/matrix/partitionSelect'; // probability\n\nexport var createCombinations = createNumberFactory('combinations', combinationsNumber);\nexport var createGamma = createNumberFactory('gamma', gammaNumber);\nexport { createCombinationsWithRep } from './function/probability/combinationsWithRep';\nexport { createFactorial } from './function/probability/factorial';\nexport { createMultinomial } from './function/probability/multinomial';\nexport { createPermutations } from './function/probability/permutations';\nexport { createPickRandom } from './function/probability/pickRandom';\nexport { createRandomNumber as createRandom } from './function/probability/random';\nexport { createRandomInt } from './function/probability/randomInt'; // relational\n\nexport { createEqualScalarNumber as createEqualScalar } from './function/relational/equalScalar';\nexport { createCompareNumber as createCompare } from './function/relational/compare';\nexport { createCompareNatural } from './function/relational/compareNatural';\nexport { createCompareTextNumber as createCompareText } from './function/relational/compareText';\nexport { createEqualNumber as createEqual } from './function/relational/equal';\nexport { createEqualText } from './function/relational/equalText';\nexport { createSmallerNumber as createSmaller } from './function/relational/smaller';\nexport { createSmallerEqNumber as createSmallerEq } from './function/relational/smallerEq';\nexport { createLargerNumber as createLarger } from './function/relational/larger';\nexport { createLargerEqNumber as createLargerEq } from './function/relational/largerEq';\nexport { createDeepEqual } from './function/relational/deepEqual';\nexport { createUnequalNumber as createUnequal } from './function/relational/unequal'; // special\n\nexport { createErf } from './function/special/erf'; // statistics\n\nexport { createMode } from './function/statistics/mode';\nexport { createProd } from './function/statistics/prod';\nexport { createMax } from './function/statistics/max';\nexport { createMin } from './function/statistics/min';\nexport { createSum } from './function/statistics/sum';\nexport { createMean } from './function/statistics/mean';\nexport { createMedian } from './function/statistics/median';\nexport { createMad } from './function/statistics/mad';\nexport { createVariance } from './function/statistics/variance';\nexport { createQuantileSeq } from './function/statistics/quantileSeq';\nexport { createStd } from './function/statistics/std'; // string\n\nexport { createFormat } from './function/string/format';\nexport { createPrint } from './function/string/print'; // trigonometry\n\nexport var createAcos =\n/* #__PURE__ */\ncreateNumberFactory('acos', acosNumber);\nexport var createAcosh =\n/* #__PURE__ */\ncreateNumberFactory('acosh', acoshNumber);\nexport var createAcot =\n/* #__PURE__ */\ncreateNumberFactory('acot', acotNumber);\nexport var createAcoth =\n/* #__PURE__ */\ncreateNumberFactory('acoth', acothNumber);\nexport var createAcsc =\n/* #__PURE__ */\ncreateNumberFactory('acsc', acscNumber);\nexport var createAcsch =\n/* #__PURE__ */\ncreateNumberFactory('acsch', acschNumber);\nexport var createAsec =\n/* #__PURE__ */\ncreateNumberFactory('asec', asecNumber);\nexport var createAsech =\n/* #__PURE__ */\ncreateNumberFactory('asech', asechNumber);\nexport var createAsin =\n/* #__PURE__ */\ncreateNumberFactory('asin', asinNumber);\nexport var createAsinh =\n/* #__PURE__ */\ncreateNumberFactory('asinh', asinhNumber);\nexport var createAtan =\n/* #__PURE__ */\ncreateNumberFactory('atan', atanNumber);\nexport var createAtan2 =\n/* #__PURE__ */\ncreateNumberFactory('atan2', atan2Number);\nexport var createAtanh =\n/* #__PURE__ */\ncreateNumberFactory('atanh', atanhNumber);\nexport var createCos =\n/* #__PURE__ */\ncreateNumberFactory('cos', cosNumber);\nexport var createCosh =\n/* #__PURE__ */\ncreateNumberFactory('cosh', coshNumber);\nexport var createCot =\n/* #__PURE__ */\ncreateNumberFactory('cot', cotNumber);\nexport var createCoth =\n/* #__PURE__ */\ncreateNumberFactory('coth', cothNumber);\nexport var createCsc =\n/* #__PURE__ */\ncreateNumberFactory('csc', cscNumber);\nexport var createCsch =\n/* #__PURE__ */\ncreateNumberFactory('csch', cschNumber);\nexport var createSec =\n/* #__PURE__ */\ncreateNumberFactory('sec', secNumber);\nexport var createSech =\n/* #__PURE__ */\ncreateNumberFactory('sech', sechNumber);\nexport var createSin =\n/* #__PURE__ */\ncreateNumberFactory('sin', sinNumber);\nexport var createSinh =\n/* #__PURE__ */\ncreateNumberFactory('sinh', sinhNumber);\nexport var createTan =\n/* #__PURE__ */\ncreateNumberFactory('tan', tanNumber);\nexport var createTanh =\n/* #__PURE__ */\ncreateNumberFactory('tanh', tanhNumber); // transforms\n\nexport { createApplyTransform } from './expression/transform/apply.transform';\nexport { createFilterTransform } from './expression/transform/filter.transform';\nexport { createForEachTransform } from './expression/transform/forEach.transform';\nexport { createMapTransform } from './expression/transform/map.transform';\nexport { createMaxTransform } from './expression/transform/max.transform';\nexport { createMeanTransform } from './expression/transform/mean.transform';\nexport { createMinTransform } from './expression/transform/min.transform';\nexport { createRangeTransform } from './expression/transform/range.transform';\nexport { createSubsetTransform } from './expression/transform/subset.transform';\nexport { createStdTransform } from './expression/transform/std.transform';\nexport { createSumTransform } from './expression/transform/sum.transform';\nexport { createVarianceTransform } from './expression/transform/variance.transform'; // utils\n\nexport { createClone } from './function/utils/clone';\nexport var createIsInteger =\n/* #__PURE__ */\ncreateNumberFactory('isInteger', isIntegerNumber);\nexport var createIsNegative =\n/* #__PURE__ */\ncreateNumberFactory('isNegative', isNegativeNumber);\nexport { createIsNumeric } from './function/utils/isNumeric';\nexport { createHasNumericValue } from './function/utils/hasNumericValue';\nexport var createIsPositive =\n/* #__PURE__ */\ncreateNumberFactory('isPositive', isPositiveNumber);\nexport var createIsZero =\n/* #__PURE__ */\ncreateNumberFactory('isZero', isZeroNumber);\nexport var createIsNaN =\n/* #__PURE__ */\ncreateNumberFactory('isNaN', isNaNNumber);\nexport { createTypeOf } from './function/utils/typeOf';\nexport { createIsPrime } from './function/utils/isPrime';\nexport { createNumeric } from './function/utils/numeric'; // json\n\nexport { createReviver } from './json/reviver'; // helper function to create a factory function for a function which only needs typed-function\n\nfunction createNumberFactory(name, fn) {\n  return factory(name, ['typed'], function (_ref) {\n    var typed = _ref.typed;\n    return typed(fn);\n  });\n}","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { createTyped } from '../../factoriesNumber.js';\nexport var typedDependencies = {\n  createTyped: createTyped\n};","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// type checks for all known types\n//\n// note that:\n//\n// - check by duck-typing on a property like `isUnit`, instead of checking instanceof.\n//   instanceof cannot be used because that would not allow to pass data from\n//   one instance of math.js to another since each has it's own instance of Unit.\n// - check the `isUnit` property via the constructor, so there will be no\n//   matches for \"fake\" instances like plain objects with a property `isUnit`.\n//   That is important for security reasons.\n// - It must not be possible to override the type checks used internally,\n//   for security reasons, so these functions are not exposed in the expression\n//   parser.\nexport function isNumber(x) {\n  return typeof x === 'number';\n}\nexport function isBigNumber(x) {\n  return x && x.constructor.prototype.isBigNumber === true || false;\n}\nexport function isComplex(x) {\n  return x && _typeof(x) === 'object' && Object.getPrototypeOf(x).isComplex === true || false;\n}\nexport function isFraction(x) {\n  return x && _typeof(x) === 'object' && Object.getPrototypeOf(x).isFraction === true || false;\n}\nexport function isUnit(x) {\n  return x && x.constructor.prototype.isUnit === true || false;\n}\nexport function isString(x) {\n  return typeof x === 'string';\n}\nexport var isArray = Array.isArray;\nexport function isMatrix(x) {\n  return x && x.constructor.prototype.isMatrix === true || false;\n}\n/**\n * Test whether a value is a collection: an Array or Matrix\n * @param {*} x\n * @returns {boolean} isCollection\n */\n\nexport function isCollection(x) {\n  return Array.isArray(x) || isMatrix(x);\n}\nexport function isDenseMatrix(x) {\n  return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;\n}\nexport function isSparseMatrix(x) {\n  return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;\n}\nexport function isRange(x) {\n  return x && x.constructor.prototype.isRange === true || false;\n}\nexport function isIndex(x) {\n  return x && x.constructor.prototype.isIndex === true || false;\n}\nexport function isBoolean(x) {\n  return typeof x === 'boolean';\n}\nexport function isResultSet(x) {\n  return x && x.constructor.prototype.isResultSet === true || false;\n}\nexport function isHelp(x) {\n  return x && x.constructor.prototype.isHelp === true || false;\n}\nexport function isFunction(x) {\n  return typeof x === 'function';\n}\nexport function isDate(x) {\n  return x instanceof Date;\n}\nexport function isRegExp(x) {\n  return x instanceof RegExp;\n}\nexport function isObject(x) {\n  return !!(x && _typeof(x) === 'object' && x.constructor === Object && !isComplex(x) && !isFraction(x));\n}\nexport function isNull(x) {\n  return x === null;\n}\nexport function isUndefined(x) {\n  return x === undefined;\n}\nexport function isAccessorNode(x) {\n  return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isArrayNode(x) {\n  return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isAssignmentNode(x) {\n  return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isBlockNode(x) {\n  return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isConditionalNode(x) {\n  return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isConstantNode(x) {\n  return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isFunctionAssignmentNode(x) {\n  return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isFunctionNode(x) {\n  return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isIndexNode(x) {\n  return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isNode(x) {\n  return x && x.isNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isObjectNode(x) {\n  return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isOperatorNode(x) {\n  return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isParenthesisNode(x) {\n  return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isRangeNode(x) {\n  return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isSymbolNode(x) {\n  return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isChain(x) {\n  return x && x.constructor.prototype.isChain === true || false;\n}\nexport function typeOf(x) {\n  var t = _typeof(x);\n\n  if (t === 'object') {\n    // JavaScript types\n    if (x === null) return 'null';\n    if (Array.isArray(x)) return 'Array';\n    if (x instanceof Date) return 'Date';\n    if (x instanceof RegExp) return 'RegExp'; // math.js types\n\n    if (isBigNumber(x)) return 'BigNumber';\n    if (isComplex(x)) return 'Complex';\n    if (isFraction(x)) return 'Fraction';\n    if (isMatrix(x)) return 'Matrix';\n    if (isUnit(x)) return 'Unit';\n    if (isIndex(x)) return 'Index';\n    if (isRange(x)) return 'Range';\n    if (isResultSet(x)) return 'ResultSet';\n    if (isNode(x)) return x.type;\n    if (isChain(x)) return 'Chain';\n    if (isHelp(x)) return 'Help';\n    return 'Object';\n  }\n\n  if (t === 'function') return 'Function';\n  return t; // can be 'string', 'number', 'boolean', ...\n}","import { contains } from './array';\nimport { pickShallow } from './object';\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]         Optional object with meta information that will be attached\n *                                to the created factory function as property `meta`.\n * @returns {function}\n */\n\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n\n  return assertAndCreate;\n}\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\n\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(function (factory) {\n    factoriesByName[factory.fn] = factory;\n  });\n\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (contains(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n\n      if (factory.dependencies.some(function (d) {\n        return containsDependency(factoriesByName[d], dependency);\n      })) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var sorted = [];\n\n  function addFactory(factory) {\n    var index = 0;\n\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n\n    sorted.splice(index, 0, factory);\n  } // sort regular factory functions\n\n\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\n\n  factories.filter(function (factory) {\n    return !isFactory(factory);\n  }).forEach(addFactory);\n  return sorted;\n} // TODO: comment or cleanup if unused in the end\n\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(function (factory) {\n    return factory(scope);\n  });\n  return scope;\n}\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\n\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\n\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(function (dependency) {\n    return !isOptionalDependency(dependency);\n  }) // filter optionals\n  .every(function (dependency) {\n    return scope[dependency] !== undefined;\n  });\n\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(function (dependency) {\n      return scope[dependency] === undefined;\n    }); // TODO: create a custom error class for this, a MathjsError or something like that\n\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(function (d) {\n      return \"\\\"\".concat(d, \"\\\"\");\n    }).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}","import { mapObject } from './object';\nimport { isNumber } from './is';\n/**\n * @typedef {{sign: '+' | '-' | '', coefficients: number[], exponent: number}} SplitValue\n */\n\n/**\n * Check if a number is integer\n * @param {number | boolean} value\n * @return {boolean} isInteger\n */\n\nexport function isInteger(value) {\n  if (typeof value === 'boolean') {\n    return true;\n  }\n\n  return isFinite(value) ? value === Math.round(value) : false; // Note: we use ==, not ===, as we can have Booleans as well\n}\n/**\n * Calculate the sign of a number\n * @param {number} x\n * @returns {number}\n */\n\nexport var sign =\n/* #__PURE__ */\nMath.sign || function (x) {\n  if (x > 0) {\n    return 1;\n  } else if (x < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n/**\n * Calculate the base-2 logarithm of a number\n * @param {number} x\n * @returns {number}\n */\n\nexport var log2 =\n/* #__PURE__ */\nMath.log2 || function log2(x) {\n  return Math.log(x) / Math.LN2;\n};\n/**\n * Calculate the base-10 logarithm of a number\n * @param {number} x\n * @returns {number}\n */\n\nexport var log10 =\n/* #__PURE__ */\nMath.log10 || function log10(x) {\n  return Math.log(x) / Math.LN10;\n};\n/**\n * Calculate the natural logarithm of a number + 1\n * @param {number} x\n * @returns {number}\n */\n\nexport var log1p =\n/* #__PURE__ */\nMath.log1p || function (x) {\n  return Math.log(x + 1);\n};\n/**\n * Calculate cubic root for a number\n *\n * Code from es6-shim.js:\n *   https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1564-L1577\n *\n * @param {number} x\n * @returns {number} Returns the cubic root of x\n */\n\nexport var cbrt =\n/* #__PURE__ */\nMath.cbrt || function cbrt(x) {\n  if (x === 0) {\n    return x;\n  }\n\n  var negate = x < 0;\n  var result;\n\n  if (negate) {\n    x = -x;\n  }\n\n  if (isFinite(x)) {\n    result = Math.exp(Math.log(x) / 3); // from https://en.wikipedia.org/wiki/Cube_root#Numerical_methods\n\n    result = (x / (result * result) + 2 * result) / 3;\n  } else {\n    result = x;\n  }\n\n  return negate ? -result : result;\n};\n/**\n * Calculates exponentiation minus 1\n * @param {number} x\n * @return {number} res\n */\n\nexport var expm1 =\n/* #__PURE__ */\nMath.expm1 || function expm1(x) {\n  return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;\n};\n/**\n * Convert a number to a formatted string representation.\n *\n * Syntax:\n *\n *    format(value)\n *    format(value, options)\n *    format(value, precision)\n *    format(value, fn)\n *\n * Where:\n *\n *    {number} value   The value to be formatted\n *    {Object} options An object with formatting options. Available options:\n *                     {string} notation\n *                         Number notation. Choose from:\n *                         'fixed'          Always use regular number notation.\n *                                          For example '123.40' and '14000000'\n *                         'exponential'    Always use exponential notation.\n *                                          For example '1.234e+2' and '1.4e+7'\n *                         'engineering'    Always use engineering notation.\n *                                          For example '123.4e+0' and '14.0e+6'\n *                         'auto' (default) Regular number notation for numbers\n *                                          having an absolute value between\n *                                          `lowerExp` and `upperExp` bounds, and\n *                                          uses exponential notation elsewhere.\n *                                          Lower bound is included, upper bound\n *                                          is excluded.\n *                                          For example '123.4' and '1.4e7'.\n *                     {number} precision   A number between 0 and 16 to round\n *                                          the digits of the number.\n *                                          In case of notations 'exponential',\n *                                          'engineering', and 'auto',\n *                                          `precision` defines the total\n *                                          number of significant digits returned.\n *                                          In case of notation 'fixed',\n *                                          `precision` defines the number of\n *                                          significant digits after the decimal\n *                                          point.\n *                                          `precision` is undefined by default,\n *                                          not rounding any digits.\n *                     {number} lowerExp    Exponent determining the lower boundary\n *                                          for formatting a value with an exponent\n *                                          when `notation='auto`.\n *                                          Default value is `-3`.\n *                     {number} upperExp    Exponent determining the upper boundary\n *                                          for formatting a value with an exponent\n *                                          when `notation='auto`.\n *                                          Default value is `5`.\n *    {Function} fn    A custom formatting function. Can be used to override the\n *                     built-in notations. Function `fn` is called with `value` as\n *                     parameter and must return a string. Is useful for example to\n *                     format all values inside a matrix in a particular way.\n *\n * Examples:\n *\n *    format(6.4)                                        // '6.4'\n *    format(1240000)                                    // '1.24e6'\n *    format(1/3)                                        // '0.3333333333333333'\n *    format(1/3, 3)                                     // '0.333'\n *    format(21385, 2)                                   // '21000'\n *    format(12.071, {notation: 'fixed'})                // '12'\n *    format(2.3,    {notation: 'fixed', precision: 2})  // '2.30'\n *    format(52.8,   {notation: 'exponential'})          // '5.28e+1'\n *    format(12345678, {notation: 'engineering'})        // '12.345678e+6'\n *\n * @param {number} value\n * @param {Object | Function | number} [options]\n * @return {string} str The formatted value\n */\n\nexport function format(value, options) {\n  if (typeof options === 'function') {\n    // handle format(value, fn)\n    return options(value);\n  } // handle special cases\n\n\n  if (value === Infinity) {\n    return 'Infinity';\n  } else if (value === -Infinity) {\n    return '-Infinity';\n  } else if (isNaN(value)) {\n    return 'NaN';\n  } // default values for options\n\n\n  var notation = 'auto';\n  var precision;\n\n  if (options) {\n    // determine notation from options\n    if (options.notation) {\n      notation = options.notation;\n    } // determine precision from options\n\n\n    if (isNumber(options)) {\n      precision = options;\n    } else if (isNumber(options.precision)) {\n      precision = options.precision;\n    }\n  } // handle the various notations\n\n\n  switch (notation) {\n    case 'fixed':\n      return toFixed(value, precision);\n\n    case 'exponential':\n      return toExponential(value, precision);\n\n    case 'engineering':\n      return toEngineering(value, precision);\n\n    case 'auto':\n      // TODO: clean up some day. Deprecated since: 2018-01-24\n      // @deprecated upper and lower are replaced with upperExp and lowerExp since v4.0.0\n      if (options && options.exponential && (options.exponential.lower !== undefined || options.exponential.upper !== undefined)) {\n        var fixedOptions = mapObject(options, function (x) {\n          return x;\n        });\n        fixedOptions.exponential = undefined;\n\n        if (options.exponential.lower !== undefined) {\n          fixedOptions.lowerExp = Math.round(Math.log(options.exponential.lower) / Math.LN10);\n        }\n\n        if (options.exponential.upper !== undefined) {\n          fixedOptions.upperExp = Math.round(Math.log(options.exponential.upper) / Math.LN10);\n        }\n\n        console.warn('Deprecation warning: Formatting options exponential.lower and exponential.upper ' + '(minimum and maximum value) ' + 'are replaced with exponential.lowerExp and exponential.upperExp ' + '(minimum and maximum exponent) since version 4.0.0. ' + 'Replace ' + JSON.stringify(options) + ' with ' + JSON.stringify(fixedOptions));\n        return toPrecision(value, precision, fixedOptions);\n      } // remove trailing zeros after the decimal point\n\n\n      return toPrecision(value, precision, options && options).replace(/((\\.\\d*?)(0+))($|e)/, function () {\n        var digits = arguments[2];\n        var e = arguments[4];\n        return digits !== '.' ? digits + e : e;\n      });\n\n    default:\n      throw new Error('Unknown notation \"' + notation + '\". ' + 'Choose \"auto\", \"exponential\", or \"fixed\".');\n  }\n}\n/**\n * Split a number into sign, coefficients, and exponent\n * @param {number | string} value\n * @return {SplitValue}\n *              Returns an object containing sign, coefficients, and exponent\n */\n\nexport function splitNumber(value) {\n  // parse the input value\n  var match = String(value).toLowerCase().match(/^0*?(-?)(\\d+\\.?\\d*)(e([+-]?\\d+))?$/);\n\n  if (!match) {\n    throw new SyntaxError('Invalid number ' + value);\n  }\n\n  var sign = match[1];\n  var digits = match[2];\n  var exponent = parseFloat(match[4] || '0');\n  var dot = digits.indexOf('.');\n  exponent += dot !== -1 ? dot - 1 : digits.length - 1;\n  var coefficients = digits.replace('.', '') // remove the dot (must be removed before removing leading zeros)\n  .replace(/^0*/, function (zeros) {\n    // remove leading zeros, add their count to the exponent\n    exponent -= zeros.length;\n    return '';\n  }).replace(/0*$/, '') // remove trailing zeros\n  .split('').map(function (d) {\n    return parseInt(d);\n  });\n\n  if (coefficients.length === 0) {\n    coefficients.push(0);\n    exponent++;\n  }\n\n  return {\n    sign: sign,\n    coefficients: coefficients,\n    exponent: exponent\n  };\n}\n/**\n * Format a number in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'\n * @param {number | string} value\n * @param {number} [precision]        Optional number of significant figures to return.\n */\n\nexport function toEngineering(value, precision) {\n  if (isNaN(value) || !isFinite(value)) {\n    return String(value);\n  }\n\n  var rounded = roundDigits(splitNumber(value), precision);\n  var e = rounded.exponent;\n  var c = rounded.coefficients; // find nearest lower multiple of 3 for exponent\n\n  var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;\n\n  if (isNumber(precision)) {\n    // add zeroes to give correct sig figs\n    while (precision > c.length || e - newExp + 1 > c.length) {\n      c.push(0);\n    }\n  } else {\n    // concatenate coefficients with necessary zeros\n    var significandsDiff = e >= 0 ? e : Math.abs(newExp); // add zeros if necessary (for ex: 1e+8)\n\n    while (c.length - 1 < significandsDiff) {\n      c.push(0);\n    }\n  } // find difference in exponents\n\n\n  var expDiff = Math.abs(e - newExp);\n  var decimalIdx = 1; // push decimal index over by expDiff times\n\n  while (expDiff > 0) {\n    decimalIdx++;\n    expDiff--;\n  } // if all coefficient values are zero after the decimal point and precision is unset, don't add a decimal value.\n  // otherwise concat with the rest of the coefficients\n\n\n  var decimals = c.slice(decimalIdx).join('');\n  var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? '.' + decimals : '';\n  var str = c.slice(0, decimalIdx).join('') + decimalVal + 'e' + (e >= 0 ? '+' : '') + newExp.toString();\n  return rounded.sign + str;\n}\n/**\n * Format a number with fixed notation.\n * @param {number | string} value\n * @param {number} [precision=undefined]  Optional number of decimals after the\n *                                        decimal point. null by default.\n */\n\nexport function toFixed(value, precision) {\n  if (isNaN(value) || !isFinite(value)) {\n    return String(value);\n  }\n\n  var splitValue = splitNumber(value);\n  var rounded = typeof precision === 'number' ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;\n  var c = rounded.coefficients;\n  var p = rounded.exponent + 1; // exponent may have changed\n  // append zeros if needed\n\n  var pp = p + (precision || 0);\n\n  if (c.length < pp) {\n    c = c.concat(zeros(pp - c.length));\n  } // prepend zeros if needed\n\n\n  if (p < 0) {\n    c = zeros(-p + 1).concat(c);\n    p = 1;\n  } // insert a dot if needed\n\n\n  if (p < c.length) {\n    c.splice(p, 0, p === 0 ? '0.' : '.');\n  }\n\n  return rounded.sign + c.join('');\n}\n/**\n * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'\n * @param {number | string} value\n * @param {number} [precision]  Number of digits in formatted output.\n *                              If not provided, the maximum available digits\n *                              is used.\n */\n\nexport function toExponential(value, precision) {\n  if (isNaN(value) || !isFinite(value)) {\n    return String(value);\n  } // round if needed, else create a clone\n\n\n  var split = splitNumber(value);\n  var rounded = precision ? roundDigits(split, precision) : split;\n  var c = rounded.coefficients;\n  var e = rounded.exponent; // append zeros if needed\n\n  if (c.length < precision) {\n    c = c.concat(zeros(precision - c.length));\n  } // format as `C.CCCe+EEE` or `C.CCCe-EEE`\n\n\n  var first = c.shift();\n  return rounded.sign + first + (c.length > 0 ? '.' + c.join('') : '') + 'e' + (e >= 0 ? '+' : '') + e;\n}\n/**\n * Format a number with a certain precision\n * @param {number | string} value\n * @param {number} [precision=undefined] Optional number of digits.\n * @param {{lowerExp: number | undefined, upperExp: number | undefined}} [options]\n *                                       By default:\n *                                         lowerExp = -3 (incl)\n *                                         upper = +5 (excl)\n * @return {string}\n */\n\nexport function toPrecision(value, precision, options) {\n  if (isNaN(value) || !isFinite(value)) {\n    return String(value);\n  } // determine lower and upper bound for exponential notation.\n\n\n  var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;\n  var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5;\n  var split = splitNumber(value);\n  var rounded = precision ? roundDigits(split, precision) : split;\n\n  if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {\n    // exponential notation\n    return toExponential(value, precision);\n  } else {\n    var c = rounded.coefficients;\n    var e = rounded.exponent; // append trailing zeros\n\n    if (c.length < precision) {\n      c = c.concat(zeros(precision - c.length));\n    } // append trailing zeros\n    // TODO: simplify the next statement\n\n\n    c = c.concat(zeros(e - c.length + 1 + (c.length < precision ? precision - c.length : 0))); // prepend zeros\n\n    c = zeros(-e).concat(c);\n    var dot = e > 0 ? e : 0;\n\n    if (dot < c.length - 1) {\n      c.splice(dot + 1, 0, '.');\n    }\n\n    return rounded.sign + c.join('');\n  }\n}\n/**\n * Round the number of digits of a number *\n * @param {SplitValue} split       A value split with .splitNumber(value)\n * @param {number} precision  A positive integer\n * @return {SplitValue}\n *              Returns an object containing sign, coefficients, and exponent\n *              with rounded digits\n */\n\nexport function roundDigits(split, precision) {\n  // create a clone\n  var rounded = {\n    sign: split.sign,\n    coefficients: split.coefficients,\n    exponent: split.exponent\n  };\n  var c = rounded.coefficients; // prepend zeros if needed\n\n  while (precision <= 0) {\n    c.unshift(0);\n    rounded.exponent++;\n    precision++;\n  }\n\n  if (c.length > precision) {\n    var removed = c.splice(precision, c.length - precision);\n\n    if (removed[0] >= 5) {\n      var i = precision - 1;\n      c[i]++;\n\n      while (c[i] === 10) {\n        c.pop();\n\n        if (i === 0) {\n          c.unshift(0);\n          rounded.exponent++;\n          i++;\n        }\n\n        i--;\n        c[i]++;\n      }\n    }\n  }\n\n  return rounded;\n}\n/**\n * Create an array filled with zeros.\n * @param {number} length\n * @return {Array}\n */\n\nfunction zeros(length) {\n  var arr = [];\n\n  for (var i = 0; i < length; i++) {\n    arr.push(0);\n  }\n\n  return arr;\n}\n/**\n * Count the number of significant digits of a number.\n *\n * For example:\n *   2.34 returns 3\n *   0.0034 returns 2\n *   120.5e+30 returns 4\n *\n * @param {number} value\n * @return {number} digits   Number of significant digits\n */\n\n\nexport function digits(value) {\n  return value.toExponential().replace(/e.*$/, '') // remove exponential notation\n  .replace(/^0\\.?0*|\\./, '') // remove decimal point and leading zeros\n  .length;\n}\n/**\n * Minimum number added to one that makes the result different than one\n */\n\nexport var DBL_EPSILON = Number.EPSILON || 2.2204460492503130808472633361816E-16;\n/**\n * Compares two floating point numbers.\n * @param {number} x          First value to compare\n * @param {number} y          Second value to compare\n * @param {number} [epsilon]  The maximum relative difference between x and y\n *                            If epsilon is undefined or null, the function will\n *                            test whether x and y are exactly equal.\n * @return {boolean} whether the two numbers are nearly equal\n*/\n\nexport function nearlyEqual(x, y, epsilon) {\n  // if epsilon is null or undefined, test whether x and y are exactly equal\n  if (epsilon === null || epsilon === undefined) {\n    return x === y;\n  }\n\n  if (x === y) {\n    return true;\n  } // NaN\n\n\n  if (isNaN(x) || isNaN(y)) {\n    return false;\n  } // at this point x and y should be finite\n\n\n  if (isFinite(x) && isFinite(y)) {\n    // check numbers are very close, needed when comparing numbers near zero\n    var diff = Math.abs(x - y);\n\n    if (diff < DBL_EPSILON) {\n      return true;\n    } else {\n      // use relative error\n      return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;\n    }\n  } // Infinite and Number or negative Infinite and positive Infinite cases\n\n\n  return false;\n}\n/**\n * Calculate the hyperbolic arccos of a number\n * @param {number} x\n * @return {number}\n */\n\nexport var acosh = Math.acosh || function (x) {\n  return Math.log(Math.sqrt(x * x - 1) + x);\n};\nexport var asinh = Math.asinh || function (x) {\n  return Math.log(Math.sqrt(x * x + 1) + x);\n};\n/**\n * Calculate the hyperbolic arctangent of a number\n * @param {number} x\n * @return {number}\n */\n\nexport var atanh = Math.atanh || function (x) {\n  return Math.log((1 + x) / (1 - x)) / 2;\n};\n/**\n * Calculate the hyperbolic cosine of a number\n * @param {number} x\n * @returns {number}\n */\n\nexport var cosh = Math.cosh || function (x) {\n  return (Math.exp(x) + Math.exp(-x)) / 2;\n};\n/**\n * Calculate the hyperbolic sine of a number\n * @param {number} x\n * @returns {number}\n */\n\nexport var sinh = Math.sinh || function (x) {\n  return (Math.exp(x) - Math.exp(-x)) / 2;\n};\n/**\n * Calculate the hyperbolic tangent of a number\n * @param {number} x\n * @returns {number}\n */\n\nexport var tanh = Math.tanh || function (x) {\n  var e = Math.exp(2 * x);\n  return (e - 1) / (e + 1);\n};","import { isInteger } from './number';\nimport { isNumber } from './is';\nimport { format } from './string';\nimport { DimensionError } from '../error/DimensionError';\nimport { IndexError } from '../error/IndexError';\n/**\n * Calculate the size of a multi dimensional array.\n * This function checks the size of the first entry, it does not validate\n * whether all dimensions match. (use function `validate` for that)\n * @param {Array} x\n * @Return {Number[]} size\n */\n\nexport function arraySize(x) {\n  var s = [];\n\n  while (Array.isArray(x)) {\n    s.push(x.length);\n    x = x[0];\n  }\n\n  return s;\n}\n/**\n * Recursively validate whether each element in a multi dimensional array\n * has a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @param {number} dim   Current dimension\n * @throws DimensionError\n * @private\n */\n\nfunction _validate(array, size, dim) {\n  var i;\n  var len = array.length;\n\n  if (len !== size[dim]) {\n    throw new DimensionError(len, size[dim]);\n  }\n\n  if (dim < size.length - 1) {\n    // recursively validate each child array\n    var dimNext = dim + 1;\n\n    for (i = 0; i < len; i++) {\n      var child = array[i];\n\n      if (!Array.isArray(child)) {\n        throw new DimensionError(size.length - 1, size.length, '<');\n      }\n\n      _validate(array[i], size, dimNext);\n    }\n  } else {\n    // last dimension. none of the childs may be an array\n    for (i = 0; i < len; i++) {\n      if (Array.isArray(array[i])) {\n        throw new DimensionError(size.length + 1, size.length, '>');\n      }\n    }\n  }\n}\n/**\n * Validate whether each element in a multi dimensional array has\n * a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @throws DimensionError\n */\n\n\nexport function validate(array, size) {\n  var isScalar = size.length === 0;\n\n  if (isScalar) {\n    // scalar\n    if (Array.isArray(array)) {\n      throw new DimensionError(array.length, 0);\n    }\n  } else {\n    // array\n    _validate(array, size, 0);\n  }\n}\n/**\n * Test whether index is an integer number with index >= 0 and index < length\n * when length is provided\n * @param {number} index    Zero-based index\n * @param {number} [length] Length of the array\n */\n\nexport function validateIndex(index, length) {\n  if (!isNumber(index) || !isInteger(index)) {\n    throw new TypeError('Index must be an integer (value: ' + index + ')');\n  }\n\n  if (index < 0 || typeof length === 'number' && index >= length) {\n    throw new IndexError(index, length);\n  }\n}\n/**\n * Resize a multi dimensional array. The resized array is returned.\n * @param {Array} array         Array to be resized\n * @param {Array.<number>} size Array with the size of each dimension\n * @param {*} [defaultValue=0]  Value to be filled in in new entries,\n *                              zero by default. Specify for example `null`,\n *                              to clearly see entries that are not explicitly\n *                              set.\n * @return {Array} array         The resized array\n */\n\nexport function resize(array, size, defaultValue) {\n  // TODO: add support for scalars, having size=[] ?\n  // check the type of the arguments\n  if (!Array.isArray(array) || !Array.isArray(size)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (size.length === 0) {\n    throw new Error('Resizing to scalar is not supported');\n  } // check whether size contains positive integers\n\n\n  size.forEach(function (value) {\n    if (!isNumber(value) || !isInteger(value) || value < 0) {\n      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n    }\n  }); // recursively resize the array\n\n  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;\n\n  _resize(array, size, 0, _defaultValue);\n\n  return array;\n}\n/**\n * Recursively resize a multi dimensional array\n * @param {Array} array         Array to be resized\n * @param {number[]} size       Array with the size of each dimension\n * @param {number} dim          Current dimension\n * @param {*} [defaultValue]    Value to be filled in in new entries,\n *                              undefined by default.\n * @private\n */\n\nfunction _resize(array, size, dim, defaultValue) {\n  var i;\n  var elem;\n  var oldLen = array.length;\n  var newLen = size[dim];\n  var minLen = Math.min(oldLen, newLen); // apply new length\n\n  array.length = newLen;\n\n  if (dim < size.length - 1) {\n    // non-last dimension\n    var dimNext = dim + 1; // resize existing child arrays\n\n    for (i = 0; i < minLen; i++) {\n      // resize child array\n      elem = array[i];\n\n      if (!Array.isArray(elem)) {\n        elem = [elem]; // add a dimension\n\n        array[i] = elem;\n      }\n\n      _resize(elem, size, dimNext, defaultValue);\n    } // create new child arrays\n\n\n    for (i = minLen; i < newLen; i++) {\n      // get child array\n      elem = [];\n      array[i] = elem; // resize new child array\n\n      _resize(elem, size, dimNext, defaultValue);\n    }\n  } else {\n    // last dimension\n    // remove dimensions of existing values\n    for (i = 0; i < minLen; i++) {\n      while (Array.isArray(array[i])) {\n        array[i] = array[i][0];\n      }\n    } // fill new elements with the default value\n\n\n    for (i = minLen; i < newLen; i++) {\n      array[i] = defaultValue;\n    }\n  }\n}\n/**\n * Re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n *\n * @throws {DimensionError}       If the product of the new dimension sizes does\n *                                not equal that of the old ones\n */\n\n\nexport function reshape(array, sizes) {\n  var flatArray = flatten(array);\n  var newArray;\n\n  function product(arr) {\n    return arr.reduce(function (prev, curr) {\n      return prev * curr;\n    });\n  }\n\n  if (!Array.isArray(array) || !Array.isArray(sizes)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (sizes.length === 0) {\n    throw new DimensionError(0, product(arraySize(array)), '!=');\n  }\n\n  var totalSize = 1;\n\n  for (var sizeIndex = 0; sizeIndex < sizes.length; sizeIndex++) {\n    totalSize *= sizes[sizeIndex];\n  }\n\n  if (flatArray.length !== totalSize) {\n    throw new DimensionError(product(sizes), product(arraySize(array)), '!=');\n  }\n\n  try {\n    newArray = _reshape(flatArray, sizes);\n  } catch (e) {\n    if (e instanceof DimensionError) {\n      throw new DimensionError(product(sizes), product(arraySize(array)), '!=');\n    }\n\n    throw e;\n  }\n\n  return newArray;\n}\n/**\n * Iteratively re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n */\n\nfunction _reshape(array, sizes) {\n  // testing if there are enough elements for the requested shape\n  var tmpArray = array;\n  var tmpArray2; // for each dimensions starting by the last one and ignoring the first one\n\n  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {\n    var size = sizes[sizeIndex];\n    tmpArray2 = []; // aggregate the elements of the current tmpArray in elements of the requested size\n\n    var length = tmpArray.length / size;\n\n    for (var i = 0; i < length; i++) {\n      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));\n    } // set it as the new tmpArray for the next loop turn or for return\n\n\n    tmpArray = tmpArray2;\n  }\n\n  return tmpArray;\n}\n/**\n * Squeeze a multi dimensional array\n * @param {Array} array\n * @param {Array} [size]\n * @returns {Array} returns the array itself\n */\n\n\nexport function squeeze(array, size) {\n  var s = size || arraySize(array); // squeeze outer dimensions\n\n  while (Array.isArray(array) && array.length === 1) {\n    array = array[0];\n    s.shift();\n  } // find the first dimension to be squeezed\n\n\n  var dims = s.length;\n\n  while (s[dims - 1] === 1) {\n    dims--;\n  } // squeeze inner dimensions\n\n\n  if (dims < s.length) {\n    array = _squeeze(array, dims, 0);\n    s.length = dims;\n  }\n\n  return array;\n}\n/**\n * Recursively squeeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _squeeze(array, dims, dim) {\n  var i, ii;\n\n  if (dim < dims) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _squeeze(array[i], dims, next);\n    }\n  } else {\n    while (Array.isArray(array)) {\n      array = array[0];\n    }\n  }\n\n  return array;\n}\n/**\n * Unsqueeze a multi dimensional array: add dimensions when missing\n *\n * Paramter `size` will be mutated to match the new, unqueezed matrix size.\n *\n * @param {Array} array\n * @param {number} dims       Desired number of dimensions of the array\n * @param {number} [outer]    Number of outer dimensions to be added\n * @param {Array} [size] Current size of array.\n * @returns {Array} returns the array itself\n * @private\n */\n\n\nexport function unsqueeze(array, dims, outer, size) {\n  var s = size || arraySize(array); // unsqueeze outer dimensions\n\n  if (outer) {\n    for (var i = 0; i < outer; i++) {\n      array = [array];\n      s.unshift(1);\n    }\n  } // unsqueeze inner dimensions\n\n\n  array = _unsqueeze(array, dims, 0);\n\n  while (s.length < dims) {\n    s.push(1);\n  }\n\n  return array;\n}\n/**\n * Recursively unsqueeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _unsqueeze(array, dims, dim) {\n  var i, ii;\n\n  if (Array.isArray(array)) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _unsqueeze(array[i], dims, next);\n    }\n  } else {\n    for (var d = dim; d < dims; d++) {\n      array = [array];\n    }\n  }\n\n  return array;\n}\n/**\n * Flatten a multi dimensional array, put all elements in a one dimensional\n * array\n * @param {Array} array   A multi dimensional array\n * @return {Array}        The flattened array (1 dimensional)\n */\n\n\nexport function flatten(array) {\n  if (!Array.isArray(array)) {\n    // if not an array, return as is\n    return array;\n  }\n\n  var flat = [];\n  array.forEach(function callback(value) {\n    if (Array.isArray(value)) {\n      value.forEach(callback); // traverse through sub-arrays recursively\n    } else {\n      flat.push(value);\n    }\n  });\n  return flat;\n}\n/**\n * A safe map\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function map(array, callback) {\n  return Array.prototype.map.call(array, callback);\n}\n/**\n * A safe forEach\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function forEach(array, callback) {\n  Array.prototype.forEach.call(array, callback);\n}\n/**\n * A safe filter\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function filter(array, callback) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, callback);\n}\n/**\n * Filter values in a callback given a regular expression\n * @param {Array} array\n * @param {RegExp} regexp\n * @return {Array} Returns the filtered array\n * @private\n */\n\nexport function filterRegExp(array, regexp) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, function (entry) {\n    return regexp.test(entry);\n  });\n}\n/**\n * A safe join\n * @param {Array} array\n * @param {string} separator\n */\n\nexport function join(array, separator) {\n  return Array.prototype.join.call(array, separator);\n}\n/**\n * Assign a numeric identifier to every element of a sorted array\n * @param {Array} a  An array\n * @return {Array} An array of objects containing the original value and its identifier\n */\n\nexport function identify(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n  var count = 0;\n  b[0] = {\n    value: a[0],\n    identifier: 0\n  };\n\n  for (var i = 1; i < a.length; i++) {\n    if (a[i] === a[i - 1]) {\n      count++;\n    } else {\n      count = 0;\n    }\n\n    b.push({\n      value: a[i],\n      identifier: count\n    });\n  }\n\n  return b;\n}\n/**\n * Remove the numeric identifier from the elements\n * @param {array} a  An array\n * @return {array} An array of values without identifiers\n */\n\nexport function generalize(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n\n  for (var i = 0; i < a.length; i++) {\n    b.push(a[i].value);\n  }\n\n  return b;\n}\n/**\n * Check the datatype of a given object\n * This is a low level implementation that should only be used by\n * parent Matrix classes such as SparseMatrix or DenseMatrix\n * This method does not validate Array Matrix shape\n * @param {Array} array\n * @param {function} typeOf   Callback function to use to determine the type of a value\n * @return string\n */\n\nexport function getArrayDataType(array, typeOf) {\n  var type; // to hold type info\n\n  var length = 0; // to hold length value to ensure it has consistent sizes\n\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n    var isArray = Array.isArray(item); // Saving the target matrix row size\n\n    if (i === 0 && isArray) {\n      length = item.length;\n    } // If the current item is an array but the length does not equal the targetVectorSize\n\n\n    if (isArray && item.length !== length) {\n      return undefined;\n    }\n\n    var itemType = isArray ? getArrayDataType(item, typeOf) // recurse into a nested array\n    : typeOf(item);\n\n    if (type === undefined) {\n      type = itemType; // first item\n    } else if (type !== itemType) {\n      return 'mixed';\n    } else {// we're good, everything has the same type so far\n    }\n  }\n\n  return type;\n}\n/**\n * Return the last item from an array\n * @param array\n * @returns {*}\n */\n\nexport function last(array) {\n  return array[array.length - 1];\n}\n/**\n * Get all but the last element of array.\n */\n\nexport function initial(array) {\n  return array.slice(0, array.length - 1);\n}\n/**\n * Test whether an array or string contains an item\n * @param {Array | string} array\n * @param {*} item\n * @return {boolean}\n */\n\nexport function contains(array, item) {\n  return array.indexOf(item) !== -1;\n}","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { isBigNumber } from './is';\n/**\n * Clone an object\n *\n *     clone(x)\n *\n * Can clone any primitive type, array, and object.\n * If x has a function clone, this function will be invoked to clone the object.\n *\n * @param {*} x\n * @return {*} clone\n */\n\nexport function clone(x) {\n  var type = _typeof(x); // immutable primitive types\n\n\n  if (type === 'number' || type === 'string' || type === 'boolean' || x === null || x === undefined) {\n    return x;\n  } // use clone function of the object when available\n\n\n  if (typeof x.clone === 'function') {\n    return x.clone();\n  } // array\n\n\n  if (Array.isArray(x)) {\n    return x.map(function (value) {\n      return clone(value);\n    });\n  }\n\n  if (x instanceof Date) return new Date(x.valueOf());\n  if (isBigNumber(x)) return x; // bignumbers are immutable\n\n  if (x instanceof RegExp) throw new TypeError('Cannot clone ' + x); // TODO: clone a RegExp\n  // object\n\n  return mapObject(x, clone);\n}\n/**\n * Apply map to all properties of an object\n * @param {Object} object\n * @param {function} callback\n * @return {Object} Returns a copy of the object with mapped properties\n */\n\nexport function mapObject(object, callback) {\n  var clone = {};\n\n  for (var key in object) {\n    if (hasOwnProperty(object, key)) {\n      clone[key] = callback(object[key]);\n    }\n  }\n\n  return clone;\n}\n/**\n * Extend object a with the properties of object b\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n */\n\nexport function extend(a, b) {\n  for (var prop in b) {\n    if (hasOwnProperty(b, prop)) {\n      a[prop] = b[prop];\n    }\n  }\n\n  return a;\n}\n/**\n * Deep extend an object a with the properties of object b\n * @param {Object} a\n * @param {Object} b\n * @returns {Object}\n */\n\nexport function deepExtend(a, b) {\n  // TODO: add support for Arrays to deepExtend\n  if (Array.isArray(b)) {\n    throw new TypeError('Arrays are not supported by deepExtend');\n  }\n\n  for (var prop in b) {\n    if (hasOwnProperty(b, prop)) {\n      if (b[prop] && b[prop].constructor === Object) {\n        if (a[prop] === undefined) {\n          a[prop] = {};\n        }\n\n        if (a[prop] && a[prop].constructor === Object) {\n          deepExtend(a[prop], b[prop]);\n        } else {\n          a[prop] = b[prop];\n        }\n      } else if (Array.isArray(b[prop])) {\n        throw new TypeError('Arrays are not supported by deepExtend');\n      } else {\n        a[prop] = b[prop];\n      }\n    }\n  }\n\n  return a;\n}\n/**\n * Deep test equality of all fields in two pairs of arrays or objects.\n * Compares values and functions strictly (ie. 2 is not the same as '2').\n * @param {Array | Object} a\n * @param {Array | Object} b\n * @returns {boolean}\n */\n\nexport function deepStrictEqual(a, b) {\n  var prop, i, len;\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) {\n      return false;\n    }\n\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0, len = a.length; i < len; i++) {\n      if (!deepStrictEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else if (typeof a === 'function') {\n    return a === b;\n  } else if (a instanceof Object) {\n    if (Array.isArray(b) || !(b instanceof Object)) {\n      return false;\n    }\n\n    for (prop in a) {\n      // noinspection JSUnfilteredForInLoop\n      if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {\n        return false;\n      }\n    }\n\n    for (prop in b) {\n      // noinspection JSUnfilteredForInLoop\n      if (!(prop in a) || !deepStrictEqual(a[prop], b[prop])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return a === b;\n  }\n}\n/**\n * Recursively flatten a nested object.\n * @param {Object} nestedObject\n * @return {Object} Returns the flattened object\n */\n\nexport function deepFlatten(nestedObject) {\n  var flattenedObject = {};\n\n  _deepFlatten(nestedObject, flattenedObject);\n\n  return flattenedObject;\n} // helper function used by deepFlatten\n\nfunction _deepFlatten(nestedObject, flattenedObject) {\n  for (var prop in nestedObject) {\n    if (hasOwnProperty(nestedObject, prop)) {\n      var value = nestedObject[prop];\n\n      if (_typeof(value) === 'object' && value !== null) {\n        _deepFlatten(value, flattenedObject);\n      } else {\n        flattenedObject[prop] = value;\n      }\n    }\n  }\n}\n/**\n * Test whether the current JavaScript engine supports Object.defineProperty\n * @returns {boolean} returns true if supported\n */\n\n\nexport function canDefineProperty() {\n  // test needed for broken IE8 implementation\n  try {\n    if (Object.defineProperty) {\n      Object.defineProperty({}, 'x', {\n        get: function get() {}\n      });\n      return true;\n    }\n  } catch (e) {}\n\n  return false;\n}\n/**\n * Attach a lazy loading property to a constant.\n * The given function `fn` is called once when the property is first requested.\n *\n * @param {Object} object         Object where to add the property\n * @param {string} prop           Property name\n * @param {Function} valueResolver Function returning the property value. Called\n *                                without arguments.\n */\n\nexport function lazy(object, prop, valueResolver) {\n  var _uninitialized = true;\n\n  var _value;\n\n  Object.defineProperty(object, prop, {\n    get: function get() {\n      if (_uninitialized) {\n        _value = valueResolver();\n        _uninitialized = false;\n      }\n\n      return _value;\n    },\n    set: function set(value) {\n      _value = value;\n      _uninitialized = false;\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\n/**\n * Traverse a path into an object.\n * When a namespace is missing, it will be created\n * @param {Object} object\n * @param {string | string[]} path   A dot separated string like 'name.space'\n * @return {Object} Returns the object at the end of the path\n */\n\nexport function traverse(object, path) {\n  if (path && typeof path === 'string') {\n    return traverse(object, path.split('.'));\n  }\n\n  var obj = object;\n\n  if (path) {\n    for (var i = 0; i < path.length; i++) {\n      var key = path[i];\n\n      if (!(key in obj)) {\n        obj[key] = {};\n      }\n\n      obj = obj[key];\n    }\n  }\n\n  return obj;\n}\n/**\n * A safe hasOwnProperty\n * @param {Object} object\n * @param {string} property\n */\n\nexport function hasOwnProperty(object, property) {\n  return object && Object.hasOwnProperty.call(object, property);\n}\n/**\n * Test whether an object is a factory. a factory has fields:\n *\n * - factory: function (type: Object, config: Object, load: function, typed: function [, math: Object])   (required)\n * - name: string (optional)\n * - path: string    A dot separated path (optional)\n * - math: boolean   If true (false by default), the math namespace is passed\n *                   as fifth argument of the factory function\n *\n * @param {*} object\n * @returns {boolean}\n */\n\nexport function isLegacyFactory(object) {\n  return object && typeof object.factory === 'function';\n}\n/**\n * Get a nested property from an object\n * @param {Object} object\n * @param {string | string[]} path\n * @returns {Object}\n */\n\nexport function get(object, path) {\n  if (typeof path === 'string') {\n    if (isPath(path)) {\n      return get(object, path.split('.'));\n    } else {\n      return object[path];\n    }\n  }\n\n  var child = object;\n\n  for (var i = 0; i < path.length; i++) {\n    var key = path[i];\n    child = child ? child[key] : undefined;\n  }\n\n  return child;\n}\n/**\n * Set a nested property in an object\n * Mutates the object itself\n * If the path doesn't exist, it will be created\n * @param {Object} object\n * @param {string | string[]} path\n * @param {*} value\n * @returns {Object}\n */\n\nexport function set(object, path, value) {\n  if (typeof path === 'string') {\n    if (isPath(path)) {\n      return set(object, path.split('.'), value);\n    } else {\n      object[path] = value;\n      return object;\n    }\n  }\n\n  var child = object;\n\n  for (var i = 0; i < path.length - 1; i++) {\n    var key = path[i];\n\n    if (child[key] === undefined) {\n      child[key] = {};\n    }\n\n    child = child[key];\n  }\n\n  if (path.length > 0) {\n    var lastKey = path[path.length - 1];\n    child[lastKey] = value;\n  }\n\n  return object;\n}\n/**\n * Create an object composed of the picked object properties\n * @param {Object} object\n * @param {string[]} properties\n * @param {function} [transform] Optional value to transform a value when picking it\n * @return {Object}\n */\n\nexport function pick(object, properties, transform) {\n  var copy = {};\n\n  for (var i = 0; i < properties.length; i++) {\n    var key = properties[i];\n    var value = get(object, key);\n\n    if (value !== undefined) {\n      set(copy, key, transform ? transform(value, key) : value);\n    }\n  }\n\n  return copy;\n}\n/**\n * Shallow version of pick, creating an object composed of the picked object properties\n * but not for nested properties\n * @param {Object} object\n * @param {string[]} properties\n * @return {Object}\n */\n\nexport function pickShallow(object, properties) {\n  var copy = {};\n\n  for (var i = 0; i < properties.length; i++) {\n    var key = properties[i];\n    var value = object[key];\n\n    if (value !== undefined) {\n      copy[key] = value;\n    }\n  }\n\n  return copy;\n}\nexport function values(object) {\n  return Object.keys(object).map(function (key) {\n    return object[key];\n  });\n} // helper function to test whether a string contains a path like 'user.name'\n\nfunction isPath(str) {\n  return str.indexOf('.') !== -1;\n}","/**\n * Create a range error with the message:\n *     'Index out of range (index < min)'\n *     'Index out of range (index < max)'\n *\n * @param {number} index     The actual index\n * @param {number} [min=0]   Minimum index (included)\n * @param {number} [max]     Maximum index (excluded)\n * @extends RangeError\n */\nexport function IndexError(index, min, max) {\n  if (!(this instanceof IndexError)) {\n    throw new SyntaxError('Constructor must be called with the new operator');\n  }\n\n  this.index = index;\n\n  if (arguments.length < 3) {\n    this.min = 0;\n    this.max = min;\n  } else {\n    this.min = min;\n    this.max = max;\n  }\n\n  if (this.min !== undefined && this.index < this.min) {\n    this.message = 'Index out of range (' + this.index + ' < ' + this.min + ')';\n  } else if (this.max !== undefined && this.index >= this.max) {\n    this.message = 'Index out of range (' + this.index + ' > ' + (this.max - 1) + ')';\n  } else {\n    this.message = 'Index out of range (' + this.index + ')';\n  }\n\n  this.stack = new Error().stack;\n}\nIndexError.prototype = new RangeError();\nIndexError.prototype.constructor = RangeError;\nIndexError.prototype.name = 'IndexError';\nIndexError.prototype.isIndexError = true;","/**\n * Log a console.warn message only once\n */\nexport var warnOnce = function () {\n  var messages = {};\n  return function warnOnce() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var message = args.join(', ');\n\n    if (!messages[message]) {\n      var _console;\n\n      messages[message] = true;\n\n      (_console = console).warn.apply(_console, ['Warning:'].concat(args));\n    }\n  };\n}();","import { isCollection, isMatrix } from './is';\nimport { IndexError } from '../error/IndexError';\nimport { arraySize } from './array';\n/**\n * Test whether an array contains collections\n * @param {Array} array\n * @returns {boolean} Returns true when the array contains one or multiple\n *                    collections (Arrays or Matrices). Returns false otherwise.\n */\n\nexport function containsCollections(array) {\n  for (var i = 0; i < array.length; i++) {\n    if (isCollection(array[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Recursively loop over all elements in a given multi dimensional array\n * and invoke the callback on each of the elements.\n * @param {Array | Matrix} array\n * @param {Function} callback     The callback method is invoked with one\n *                                parameter: the current element in the array\n */\n\nexport function deepForEach(array, callback) {\n  if (isMatrix(array)) {\n    array = array.valueOf();\n  }\n\n  for (var i = 0, ii = array.length; i < ii; i++) {\n    var value = array[i];\n\n    if (Array.isArray(value)) {\n      deepForEach(value, callback);\n    } else {\n      callback(value);\n    }\n  }\n}\n/**\n * Execute the callback function element wise for each element in array and any\n * nested array\n * Returns an array with the results\n * @param {Array | Matrix} array\n * @param {Function} callback   The callback is called with two parameters:\n *                              value1 and value2, which contain the current\n *                              element of both arrays.\n * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n *\n * @return {Array | Matrix} res\n */\n\nexport function deepMap(array, callback, skipZeros) {\n  if (array && typeof array.map === 'function') {\n    // TODO: replace array.map with a for loop to improve performance\n    return array.map(function (x) {\n      return deepMap(x, callback, skipZeros);\n    });\n  } else {\n    return callback(array);\n  }\n}\n/**\n * Reduce a given matrix or array to a new matrix or\n * array with one less dimension, applying the given\n * callback in the selected dimension.\n * @param {Array | Matrix} mat\n * @param {number} dim\n * @param {Function} callback\n * @return {Array | Matrix} res\n */\n\nexport function reduce(mat, dim, callback) {\n  var size = Array.isArray(mat) ? arraySize(mat) : mat.size();\n\n  if (dim < 0 || dim >= size.length) {\n    // TODO: would be more clear when throwing a DimensionError here\n    throw new IndexError(dim, size.length);\n  }\n\n  if (isMatrix(mat)) {\n    return mat.create(_reduce(mat.valueOf(), dim, callback));\n  } else {\n    return _reduce(mat, dim, callback);\n  }\n}\n/**\n * Recursively reduce a matrix\n * @param {Array} mat\n * @param {number} dim\n * @param {Function} callback\n * @returns {Array} ret\n * @private\n */\n\nfunction _reduce(mat, dim, callback) {\n  var i, ret, val, tran;\n\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      val = mat[0];\n\n      for (i = 1; i < mat.length; i++) {\n        val = callback(val, mat[i]);\n      }\n\n      return val;\n    } else {\n      tran = _switch(mat);\n      ret = [];\n\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _reduce(tran[i], dim - 1, callback);\n      }\n\n      return ret;\n    }\n  } else {\n    ret = [];\n\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _reduce(mat[i], dim - 1, callback);\n    }\n\n    return ret;\n  }\n}\n/**\n * Transpose a matrix\n * @param {Array} mat\n * @returns {Array} ret\n * @private\n */\n\n\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n\n    ret.push(tmp);\n  }\n\n  return ret;\n} // TODO: document function scatter\n\n\nexport function scatter(a, j, w, x, u, mark, c, f, inverse, update, value) {\n  // a arrays\n  var avalues = a._values;\n  var aindex = a._index;\n  var aptr = a._ptr; // c arrays\n\n  var cindex = c._index; // vars\n\n  var k, k0, k1, i; // check we need to process values (pattern matrix)\n\n  if (x) {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i); // x(i) = A, check we need to call function this time\n\n        if (update) {\n          // copy value to workspace calling callback function\n          x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]); // function was called on current row\n\n          u[i] = mark;\n        } else {\n          // copy value to workspace\n          x[i] = avalues[k];\n        }\n      } else {\n        // i exists in C already\n        x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]); // function was called on current row\n\n        u[i] = mark;\n      }\n    }\n  } else {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i);\n      } else {\n        // indicate function was called on current row\n        u[i] = mark;\n      }\n    }\n  }\n}","/**\n * Create a range error with the message:\n *     'Dimension mismatch (<actual size> != <expected size>)'\n * @param {number | number[]} actual        The actual size\n * @param {number | number[]} expected      The expected size\n * @param {string} [relation='!=']          Optional relation between actual\n *                                          and expected size: '!=', '<', etc.\n * @extends RangeError\n */\nexport function DimensionError(actual, expected, relation) {\n  if (!(this instanceof DimensionError)) {\n    throw new SyntaxError('Constructor must be called with the new operator');\n  }\n\n  this.actual = actual;\n  this.expected = expected;\n  this.relation = relation;\n  this.message = 'Dimension mismatch (' + (Array.isArray(actual) ? '[' + actual.join(', ') + ']' : actual) + ' ' + (this.relation || '!=') + ' ' + (Array.isArray(expected) ? '[' + expected.join(', ') + ']' : expected) + ')';\n  this.stack = new Error().stack;\n}\nDimensionError.prototype = new RangeError();\nDimensionError.prototype.constructor = RangeError;\nDimensionError.prototype.name = 'DimensionError';\nDimensionError.prototype.isDimensionError = true;","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { typedDependencies } from './dependenciesTyped.generated';\nimport { createAdd } from '../../factoriesNumber.js';\nexport var addDependencies = {\n  typedDependencies: typedDependencies,\n  createAdd: createAdd\n};","/**\n * Create a typed-function which checks the types of the arguments and\n * can match them against multiple provided signatures. The typed-function\n * automatically converts inputs in order to find a matching signature.\n * Typed functions throw informative errors in case of wrong input arguments.\n *\n * See the library [typed-function](https://github.com/josdejong/typed-function)\n * for detailed documentation.\n *\n * Syntax:\n *\n *     math.typed(name, signatures) : function\n *     math.typed(signatures) : function\n *\n * Examples:\n *\n *     // create a typed function with multiple types per argument (type union)\n *     const fn2 = typed({\n *       'number | boolean': function (b) {\n *         return 'b is a number or boolean'\n *       },\n *       'string, number | boolean': function (a, b) {\n *         return 'a is a string, b is a number or boolean'\n *       }\n *     })\n *\n *     // create a typed function with an any type argument\n *     const log = typed({\n *       'string, any': function (event, data) {\n *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))\n *       }\n *     })\n *\n * @param {string} [name]                          Optional name for the typed-function\n * @param {Object<string, function>} signatures   Object with one or multiple function signatures\n * @returns {function} The created typed-function.\n */\nimport { isAccessorNode, isArray, isArrayNode, isAssignmentNode, isBigNumber, isBlockNode, isBoolean, isChain, isComplex, isConditionalNode, isConstantNode, isDate, isDenseMatrix, isFraction, isFunction, isFunctionAssignmentNode, isFunctionNode, isHelp, isIndex, isIndexNode, isMatrix, isNode, isNull, isNumber, isObject, isObjectNode, isOperatorNode, isParenthesisNode, isRange, isRangeNode, isRegExp, isResultSet, isSparseMatrix, isString, isSymbolNode, isUndefined, isUnit } from '../../utils/is';\nimport typedFunction from 'typed-function';\nimport { digits } from '../../utils/number';\nimport { factory } from '../../utils/factory'; // returns a new instance of typed-function\n\nvar _createTyped2 = function _createTyped() {\n  // initially, return the original instance of typed-function\n  // consecutively, return a new instance from typed.create.\n  _createTyped2 = typedFunction.create;\n  return typedFunction;\n};\n\nvar dependencies = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];\n/**\n * Factory function for creating a new typed instance\n * @param {Object} dependencies   Object with data types like Complex and BigNumber\n * @returns {Function}\n */\n\nexport var createTyped =\n/* #__PURE__ */\nfactory('typed', dependencies, function createTyped(_ref) {\n  var BigNumber = _ref.BigNumber,\n      Complex = _ref.Complex,\n      DenseMatrix = _ref.DenseMatrix,\n      Fraction = _ref.Fraction;\n\n  // TODO: typed-function must be able to silently ignore signatures with unknown data types\n  // get a new instance of typed-function\n  var typed = _createTyped2(); // define all types. The order of the types determines in which order function\n  // arguments are type-checked (so for performance it's important to put the\n  // most used types first).\n\n\n  typed.types = [{\n    name: 'number',\n    test: isNumber\n  }, {\n    name: 'Complex',\n    test: isComplex\n  }, {\n    name: 'BigNumber',\n    test: isBigNumber\n  }, {\n    name: 'Fraction',\n    test: isFraction\n  }, {\n    name: 'Unit',\n    test: isUnit\n  }, {\n    name: 'string',\n    test: isString\n  }, {\n    name: 'Chain',\n    test: isChain\n  }, {\n    name: 'Array',\n    test: isArray\n  }, {\n    name: 'Matrix',\n    test: isMatrix\n  }, {\n    name: 'DenseMatrix',\n    test: isDenseMatrix\n  }, {\n    name: 'SparseMatrix',\n    test: isSparseMatrix\n  }, {\n    name: 'Range',\n    test: isRange\n  }, {\n    name: 'Index',\n    test: isIndex\n  }, {\n    name: 'boolean',\n    test: isBoolean\n  }, {\n    name: 'ResultSet',\n    test: isResultSet\n  }, {\n    name: 'Help',\n    test: isHelp\n  }, {\n    name: 'function',\n    test: isFunction\n  }, {\n    name: 'Date',\n    test: isDate\n  }, {\n    name: 'RegExp',\n    test: isRegExp\n  }, {\n    name: 'null',\n    test: isNull\n  }, {\n    name: 'undefined',\n    test: isUndefined\n  }, {\n    name: 'AccessorNode',\n    test: isAccessorNode\n  }, {\n    name: 'ArrayNode',\n    test: isArrayNode\n  }, {\n    name: 'AssignmentNode',\n    test: isAssignmentNode\n  }, {\n    name: 'BlockNode',\n    test: isBlockNode\n  }, {\n    name: 'ConditionalNode',\n    test: isConditionalNode\n  }, {\n    name: 'ConstantNode',\n    test: isConstantNode\n  }, {\n    name: 'FunctionNode',\n    test: isFunctionNode\n  }, {\n    name: 'FunctionAssignmentNode',\n    test: isFunctionAssignmentNode\n  }, {\n    name: 'IndexNode',\n    test: isIndexNode\n  }, {\n    name: 'Node',\n    test: isNode\n  }, {\n    name: 'ObjectNode',\n    test: isObjectNode\n  }, {\n    name: 'OperatorNode',\n    test: isOperatorNode\n  }, {\n    name: 'ParenthesisNode',\n    test: isParenthesisNode\n  }, {\n    name: 'RangeNode',\n    test: isRangeNode\n  }, {\n    name: 'SymbolNode',\n    test: isSymbolNode\n  }, {\n    name: 'Object',\n    test: isObject\n  } // order 'Object' last, it matches on other classes too\n  ];\n  typed.conversions = [{\n    from: 'number',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      } // note: conversion from number to BigNumber can fail if x has >15 digits\n\n\n      if (digits(x) > 15) {\n        throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');\n      }\n\n      return new BigNumber(x);\n    }\n  }, {\n    from: 'number',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x, 0);\n    }\n  }, {\n    from: 'number',\n    to: 'string',\n    convert: function convert(x) {\n      return x + '';\n    }\n  }, {\n    from: 'BigNumber',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.toNumber(), 0);\n    }\n  }, {\n    from: 'Fraction',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');\n    }\n  }, {\n    from: 'Fraction',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.valueOf(), 0);\n    }\n  }, {\n    from: 'number',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      var f = new Fraction(x);\n\n      if (f.valueOf() !== x) {\n        throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');\n      }\n\n      return f;\n    }\n  }, {\n    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`\n    //  from: 'Fraction',\n    //  to: 'number',\n    //  convert: function (x) {\n    //    return x.valueOf()\n    //  }\n    // }, {\n    from: 'string',\n    to: 'number',\n    convert: function convert(x) {\n      var n = Number(x);\n\n      if (isNaN(n)) {\n        throw new Error('Cannot convert \"' + x + '\" to a number');\n      }\n\n      return n;\n    }\n  }, {\n    from: 'string',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      try {\n        return new BigNumber(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to BigNumber');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      try {\n        return new Fraction(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Fraction');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      try {\n        return new Complex(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Complex');\n      }\n    }\n  }, {\n    from: 'boolean',\n    to: 'number',\n    convert: function convert(x) {\n      return +x;\n    }\n  }, {\n    from: 'boolean',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      return new BigNumber(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      return new Fraction(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'string',\n    convert: function convert(x) {\n      return String(x);\n    }\n  }, {\n    from: 'Array',\n    to: 'Matrix',\n    convert: function convert(array) {\n      if (!DenseMatrix) {\n        throwNoMatrix();\n      }\n\n      return new DenseMatrix(array);\n    }\n  }, {\n    from: 'Matrix',\n    to: 'Array',\n    convert: function convert(matrix) {\n      return matrix.valueOf();\n    }\n  }];\n  return typed;\n});\n\nfunction throwNoBignumber(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a BigNumber: no class 'BigNumber' provided\"));\n}\n\nfunction throwNoComplex(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Complex number: no class 'Complex' provided\"));\n}\n\nfunction throwNoMatrix() {\n  throw new Error('Cannot convert array into a Matrix: no class \\'DenseMatrix\\' provided');\n}\n\nfunction throwNoFraction(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Fraction, no class 'Fraction' provided.\"));\n}","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { typedDependencies } from './dependenciesTyped.generated';\nimport { createDivide } from '../../factoriesNumber.js';\nexport var divideDependencies = {\n  typedDependencies: typedDependencies,\n  createDivide: createDivide\n};","import { containsCollections, deepForEach, reduce } from '../../utils/collection';\nimport { arraySize } from '../../utils/array';\nimport { factory } from '../../utils/factory';\nimport { improveErrorMessage } from './utils/improveErrorMessage';\nvar name = 'mean';\nvar dependencies = ['typed', 'add', 'divide'];\nexport var createMean =\n/* #__PURE__ */\nfactory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      add = _ref.add,\n      divide = _ref.divide;\n\n  /**\n   * Compute the mean value of matrix or a list with values.\n   * In case of a multi dimensional array, the mean of the flattened array\n   * will be calculated. When `dim` is provided, the maximum over the selected\n   * dimension will be calculated. Parameter `dim` is zero-based.\n   *\n   * Syntax:\n   *\n   *     math.mean(a, b, c, ...)\n   *     math.mean(A)\n   *     math.mean(A, dim)\n   *\n   * Examples:\n   *\n   *     math.mean(2, 1, 4, 3)                     // returns 2.5\n   *     math.mean([1, 2.7, 3.2, 4])               // returns 2.725\n   *\n   *     math.mean([[2, 5], [6, 3], [1, 7]], 0)    // returns [3, 5]\n   *     math.mean([[2, 5], [6, 3], [1, 7]], 1)    // returns [3.5, 4.5, 4]\n   *\n   * See also:\n   *\n   *     median, min, max, sum, prod, std, variance\n   *\n   * @param {... *} args  A single matrix or or multiple scalar values\n   * @return {*} The mean of all values\n   */\n  return typed(name, {\n    // mean([a, b, c, d, ...])\n    'Array | Matrix': _mean,\n    // mean([a, b, c, d, ...], dim)\n    'Array | Matrix, number | BigNumber': _nmeanDim,\n    // mean(a, b, c, d, ...)\n    '...': function _(args) {\n      if (containsCollections(args)) {\n        throw new TypeError('Scalar values expected in function mean');\n      }\n\n      return _mean(args);\n    }\n  });\n  /**\n   * Calculate the mean value in an n-dimensional array, returning a\n   * n-1 dimensional array\n   * @param {Array} array\n   * @param {number} dim\n   * @return {number} mean\n   * @private\n   */\n\n  function _nmeanDim(array, dim) {\n    try {\n      var sum = reduce(array, dim, add);\n      var s = Array.isArray(array) ? arraySize(array) : array.size();\n      return divide(sum, s[dim]);\n    } catch (err) {\n      throw improveErrorMessage(err, 'mean');\n    }\n  }\n  /**\n   * Recursively calculate the mean value in an n-dimensional array\n   * @param {Array} array\n   * @return {number} mean\n   * @private\n   */\n\n\n  function _mean(array) {\n    var sum;\n    var num = 0;\n    deepForEach(array, function (value) {\n      try {\n        sum = sum === undefined ? value : add(sum, value);\n        num++;\n      } catch (err) {\n        throw improveErrorMessage(err, 'mean', value);\n      }\n    });\n\n    if (num === 0) {\n      throw new Error('Cannot calculate the mean of an empty array');\n    }\n\n    return divide(sum, num);\n  }\n});","import { typeOf } from '../../../utils/is';\n/**\n * Improve error messages for statistics functions. Errors are typically\n * thrown in an internally used function like larger, causing the error\n * not to mention the function (like max) which is actually used by the user.\n *\n * @param {Error} err\n * @param {String} fnName\n * @param {*} [value]\n * @return {Error}\n */\n\nexport function improveErrorMessage(err, fnName, value) {\n  // TODO: add information with the index (also needs transform in expression parser)\n  var details;\n\n  if (String(err).indexOf('Unexpected type') !== -1) {\n    details = arguments.length > 2 ? ' (type: ' + typeOf(value) + ', value: ' + JSON.stringify(value) + ')' : ' (type: ' + err.data.actual + ')';\n    return new TypeError('Cannot calculate ' + fnName + ', unexpected type of argument' + details);\n  }\n\n  if (String(err).indexOf('complex numbers') !== -1) {\n    details = arguments.length > 2 ? ' (type: ' + typeOf(value) + ', value: ' + JSON.stringify(value) + ')' : '';\n    return new TypeError('Cannot calculate ' + fnName + ', no ordering relation is defined for complex numbers' + details);\n  }\n\n  return err;\n}","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { typedDependencies } from './dependenciesTyped.generated';\nimport { createIsNaN } from '../../factoriesNumber.js';\nexport var isNaNDependencies = {\n  typedDependencies: typedDependencies,\n  createIsNaN: createIsNaN\n};","import { deepMap } from '../../utils/collection';\nimport { factory } from '../../utils/factory';\nvar name = 'isNumeric';\nvar dependencies = ['typed'];\nexport var createIsNumeric =\n/* #__PURE__ */\nfactory(name, dependencies, function (_ref) {\n  var typed = _ref.typed;\n\n  /**\n   * Test whether a value is an numeric value.\n   *\n   * The function is evaluated element-wise in case of Array or Matrix input.\n   *\n   * Syntax:\n   *\n   *     math.isNumeric(x)\n   *\n   * Examples:\n   *\n   *    math.isNumeric(2)                     // returns true\n   *    math.isNumeric('2')                   // returns false\n   *    math.hasNumericValue('2')             // returns true\n   *    math.isNumeric(0)                     // returns true\n   *    math.isNumeric(math.bignumber(500))   // returns true\n   *    math.isNumeric(math.fraction(4))      // returns true\n   *    math.isNumeric(math.complex('2-4i')   // returns false\n   *    math.isNumeric([2.3, 'foo', false])   // returns [true, false, true]\n   *\n   * See also:\n   *\n   *    isZero, isPositive, isNegative, isInteger, hasNumericValue\n   *\n   * @param {*} x       Value to be tested\n   * @return {boolean}  Returns true when `x` is a `number`, `BigNumber`,\n   *                    `Fraction`, or `boolean`. Returns false for other types.\n   *                    Throws an error in case of unknown types.\n   */\n  var isNumeric = typed(name, {\n    'number | BigNumber | Fraction | boolean': function numberBigNumberFractionBoolean() {\n      return true;\n    },\n    'Complex | Unit | string | null | undefined | Node': function ComplexUnitStringNullUndefinedNode() {\n      return false;\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, isNumeric);\n    }\n  });\n  return isNumeric;\n});","import { flatten } from '../../utils/array';\nimport { factory } from '../../utils/factory';\nvar name = 'mode';\nvar dependencies = ['typed', 'isNaN', 'isNumeric'];\nexport var createMode =\n/* #__PURE__ */\nfactory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      isNaN = _ref.isNaN,\n      isNumeric = _ref.isNumeric;\n\n  /**\n  * Computes the mode of a set of numbers or a list with values(numbers or characters).\n  * If there are more than one modes, it returns a list of those values.\n  *\n  * Syntax:\n  *\n  *     math.mode(a, b, c, ...)\n  *     math.mode(A)\n  *\n  * Examples:\n  *\n  *     math.mode(2, 1, 4, 3, 1)                            // returns [1]\n  *     math.mode([1, 2.7, 3.2, 4, 2.7])                    // returns [2.7]\n  *     math.mode(1, 4, 6, 1, 6)                             // returns [1, 6]\n  *     math.mode('a','a','b','c')                           // returns [\"a\"]\n  *     math.mode(1, 1.5, 'abc')                             // returns [1, 1.5, \"abc\"]\n  *\n  * See also:\n  *\n  *     median,\n  *     mean\n  *\n  * @param {... *} args  A single matrix\n  * @return {*} The mode of all values\n  */\n  return typed(name, {\n    'Array | Matrix': _mode,\n    '...': function _(args) {\n      return _mode(args);\n    }\n  });\n  /**\n   * Calculates the mode in an 1-dimensional array\n   * @param {Array} values\n   * @return {Array} mode\n   * @private\n   */\n\n  function _mode(values) {\n    values = flatten(values.valueOf());\n    var num = values.length;\n\n    if (num === 0) {\n      throw new Error('Cannot calculate mode of an empty array');\n    }\n\n    var count = {};\n    var mode = [];\n    var max = 0;\n\n    for (var i = 0; i < values.length; i++) {\n      var value = values[i];\n\n      if (isNumeric(value) && isNaN(value)) {\n        throw new Error('Cannot calculate mode of an array containing NaN values');\n      }\n\n      if (!(value in count)) {\n        count[value] = 0;\n      }\n\n      count[value]++;\n\n      if (count[value] === max) {\n        mode.push(value);\n      } else if (count[value] > max) {\n        max = count[value];\n        mode = [value];\n      }\n    }\n\n    return mode;\n  }\n});","import { factory } from '../../utils/factory';\nimport { arraySize } from '../../utils/array';\nimport { isMatrix } from '../../utils/is';\nimport { IndexError } from '../../error/IndexError';\nvar name = 'apply';\nvar dependencies = ['typed', 'isInteger'];\nexport var createApply =\n/* #__PURE__ */\nfactory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      isInteger = _ref.isInteger;\n\n  /**\n   * Apply a function that maps an array to a scalar\n   * along a given axis of a matrix or array.\n   * Returns a new matrix or array with one less dimension than the input.\n   *\n   * Syntax:\n   *\n   *     math.apply(A, dim, callback)\n   *\n   * Where:\n   *\n   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.\n   *\n   * Examples:\n   *\n   *    const A = [[1, 2], [3, 4]]\n   *    const sum = math.sum\n   *\n   *    math.apply(A, 0, sum)             // returns [4, 6]\n   *    math.apply(A, 1, sum)             // returns [3, 7]\n   *\n   * See also:\n   *\n   *    map, filter, forEach\n   *\n   * @param {Array | Matrix} array   The input Matrix\n   * @param {number} dim             The dimension along which the callback is applied\n   * @param {Function} callback      The callback function that is applied. This Function\n   *                                 should take an array or 1-d matrix as an input and\n   *                                 return a number.\n   * @return {Array | Matrix} res    The residual matrix with the function applied over some dimension.\n   */\n  var apply = typed(name, {\n    'Array | Matrix, number | BigNumber, function': function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {\n      if (!isInteger(dim)) {\n        throw new TypeError('Integer number expected for dimension');\n      }\n\n      var size = Array.isArray(mat) ? arraySize(mat) : mat.size();\n\n      if (dim < 0 || dim >= size.length) {\n        throw new IndexError(dim, size.length);\n      }\n\n      if (isMatrix(mat)) {\n        return mat.create(_apply(mat.valueOf(), dim, callback));\n      } else {\n        return _apply(mat, dim, callback);\n      }\n    }\n  });\n  return apply;\n});\n/**\n * Recursively reduce a matrix\n * @param {Array} mat\n * @param {number} dim\n * @param {Function} callback\n * @returns {Array} ret\n * @private\n */\n\nfunction _apply(mat, dim, callback) {\n  var i, ret, tran;\n\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      return callback(mat);\n    } else {\n      tran = _switch(mat);\n      ret = [];\n\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _apply(tran[i], dim - 1, callback);\n      }\n\n      return ret;\n    }\n  } else {\n    ret = [];\n\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _apply(mat[i], dim - 1, callback);\n    }\n\n    return ret;\n  }\n}\n/**\n * Transpose a matrix\n * @param {Array} mat\n * @returns {Array} ret\n * @private\n */\n\n\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n\n    ret.push(tmp);\n  }\n\n  return ret;\n}","import { deepForEach } from '../../utils/collection';\nimport { isBigNumber } from '../../utils/is';\nimport { factory } from '../../utils/factory';\nimport { improveErrorMessage } from './utils/improveErrorMessage';\nimport { warnOnce } from '../../utils/log';\nvar DEFAULT_NORMALIZATION = 'unbiased';\nvar name = 'variance';\nvar dependencies = ['typed', 'add', 'subtract', 'multiply', 'divide', 'apply', 'isNaN'];\nexport var createVariance =\n/* #__PURE__ */\nfactory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      apply = _ref.apply,\n      isNaN = _ref.isNaN;\n\n  /**\n   * Compute the variance of a matrix or a  list with values.\n   * In case of a (multi dimensional) array or matrix, the variance over all\n   * elements will be calculated.\n   *\n   * Additionally, it is possible to compute the variance along the rows\n   * or columns of a matrix by specifying the dimension as the second argument.\n   *\n   * Optionally, the type of normalization can be specified as the final\n   * parameter. The parameter `normalization` can be one of the following values:\n   *\n   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)\n   * - 'uncorrected'        The sum of squared errors is divided by n\n   * - 'biased'             The sum of squared errors is divided by (n + 1)\n   *\n   *\n   * Note that older browser may not like the variable name `var`. In that\n   * case, the function can be called as `math['var'](...)` instead of\n   * `math.var(...)`.\n   *\n   * Syntax:\n   *\n   *     math.variance(a, b, c, ...)\n   *     math.variance(A)\n   *     math.variance(A, normalization)\n   *     math.variance(A, dimension)\n   *     math.variance(A, dimension, normalization)\n   *\n   * Examples:\n   *\n   *     math.variance(2, 4, 6)                     // returns 4\n   *     math.variance([2, 4, 6, 8])                // returns 6.666666666666667\n   *     math.variance([2, 4, 6, 8], 'uncorrected') // returns 5\n   *     math.variance([2, 4, 6, 8], 'biased')      // returns 4\n   *\n   *     math.variance([[1, 2, 3], [4, 5, 6]])      // returns 3.5\n   *     math.variance([[1, 2, 3], [4, 6, 8]], 0)   // returns [4.5, 8, 12.5]\n   *     math.variance([[1, 2, 3], [4, 6, 8]], 1)   // returns [1, 4]\n   *     math.variance([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.5, 2]\n   *\n   * See also:\n   *\n   *    mean, median, max, min, prod, std, sum\n   *\n   * @param {Array | Matrix} array\n   *                        A single matrix or or multiple scalar values\n   * @param {string} [normalization='unbiased']\n   *                        Determines how to normalize the variance.\n   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.\n   * @param dimension {number | BigNumber}\n   *                        Determines the axis to compute the variance for a matrix\n   * @return {*} The variance\n   */\n  return typed(name, {\n    // variance([a, b, c, d, ...])\n    'Array | Matrix': function ArrayMatrix(array) {\n      return _var(array, DEFAULT_NORMALIZATION);\n    },\n    // variance([a, b, c, d, ...], normalization)\n    'Array | Matrix, string': _var,\n    // variance([a, b, c, c, ...], dim)\n    'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {\n      return _varDim(array, dim, DEFAULT_NORMALIZATION);\n    },\n    // variance([a, b, c, c, ...], dim, normalization)\n    'Array | Matrix, number | BigNumber, string': _varDim,\n    // variance(a, b, c, d, ...)\n    '...': function _(args) {\n      return _var(args, DEFAULT_NORMALIZATION);\n    }\n  });\n  /**\n   * Recursively calculate the variance of an n-dimensional array\n   * @param {Array} array\n   * @param {string} normalization\n   *                        Determines how to normalize the variance:\n   *                        - 'unbiased'    The sum of squared errors is divided by (n - 1)\n   *                        - 'uncorrected' The sum of squared errors is divided by n\n   *                        - 'biased'      The sum of squared errors is divided by (n + 1)\n   * @return {number | BigNumber} variance\n   * @private\n   */\n\n  function _var(array, normalization) {\n    var sum = 0;\n    var num = 0;\n\n    if (array.length === 0) {\n      throw new SyntaxError('Function variance requires one or more parameters (0 provided)');\n    } // calculate the mean and number of elements\n\n\n    deepForEach(array, function (value) {\n      try {\n        sum = add(sum, value);\n        num++;\n      } catch (err) {\n        throw improveErrorMessage(err, 'variance', value);\n      }\n    });\n    if (num === 0) throw new Error('Cannot calculate variance of an empty array');\n    var mean = divide(sum, num); // calculate the variance\n\n    sum = 0;\n    deepForEach(array, function (value) {\n      var diff = subtract(value, mean);\n      sum = add(sum, multiply(diff, diff));\n    });\n\n    if (isNaN(sum)) {\n      return sum;\n    }\n\n    switch (normalization) {\n      case 'uncorrected':\n        return divide(sum, num);\n\n      case 'biased':\n        return divide(sum, num + 1);\n\n      case 'unbiased':\n        {\n          var zero = isBigNumber(sum) ? sum.mul(0) : 0;\n          return num === 1 ? zero : divide(sum, num - 1);\n        }\n\n      default:\n        throw new Error('Unknown normalization \"' + normalization + '\". ' + 'Choose \"unbiased\" (default), \"uncorrected\", or \"biased\".');\n    }\n  }\n\n  function _varDim(array, dim, normalization) {\n    try {\n      if (array.length === 0) {\n        throw new SyntaxError('Function variance requires one or more parameters (0 provided)');\n      }\n\n      return apply(array, dim, function (x) {\n        return _var(x, normalization);\n      });\n    } catch (err) {\n      throw improveErrorMessage(err, 'variance');\n    }\n  }\n}); // For backward compatibility, deprecated since version 6.0.0. Date: 2018-11-09\n\nexport var createDeprecatedVar =\n/* #__PURE__ */\nfactory('var', ['variance'], function (_ref2) {\n  var variance = _ref2.variance;\n  return function () {\n    warnOnce('Function \"var\" has been renamed to \"variance\" in v6.0.0, please use the new function instead.');\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return variance.apply(variance, args);\n  };\n});","import { factory } from '../../utils/factory';\nvar name = 'std';\nvar dependencies = ['typed', 'sqrt', 'variance'];\nexport var createStd =\n/* #__PURE__ */\nfactory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      sqrt = _ref.sqrt,\n      variance = _ref.variance;\n\n  /**\n   * Compute the standard deviation of a matrix or a  list with values.\n   * The standard deviations is defined as the square root of the variance:\n   * `std(A) = sqrt(variance(A))`.\n   * In case of a (multi dimensional) array or matrix, the standard deviation\n   * over all elements will be calculated by default, unless an axis is specified\n   * in which case the standard deviation will be computed along that axis.\n   *\n   * Additionally, it is possible to compute the standard deviation along the rows\n   * or columns of a matrix by specifying the dimension as the second argument.\n   *\n   * Optionally, the type of normalization can be specified as the final\n   * parameter. The parameter `normalization` can be one of the following values:\n   *\n   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)\n   * - 'uncorrected'        The sum of squared errors is divided by n\n   * - 'biased'             The sum of squared errors is divided by (n + 1)\n   *\n   *\n   * Syntax:\n   *\n   *     math.std(a, b, c, ...)\n   *     math.std(A)\n   *     math.std(A, normalization)\n   *     math.std(A, dimension)\n   *     math.std(A, dimension, normalization)\n   *\n   * Examples:\n   *\n   *     math.std(2, 4, 6)                     // returns 2\n   *     math.std([2, 4, 6, 8])                // returns 2.581988897471611\n   *     math.std([2, 4, 6, 8], 'uncorrected') // returns 2.23606797749979\n   *     math.std([2, 4, 6, 8], 'biased')      // returns 2\n   *\n   *     math.std([[1, 2, 3], [4, 5, 6]])      // returns 1.8708286933869707\n   *     math.std([[1, 2, 3], [4, 6, 8]], 0)    // returns [2.1213203435596424, 2.8284271247461903, 3.5355339059327378]\n   *     math.std([[1, 2, 3], [4, 6, 8]], 1)    // returns [1, 2]\n   *     math.std([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.7071067811865476, 1.4142135623730951]\n   *\n   * See also:\n   *\n   *    mean, median, max, min, prod, sum, variance\n   *\n   * @param {Array | Matrix} array\n   *                        A single matrix or or multiple scalar values\n   * @param {string} [normalization='unbiased']\n   *                        Determines how to normalize the variance.\n   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.\n   * @param dimension {number | BigNumber}\n   *                        Determines the axis to compute the standard deviation for a matrix\n   * @return {*} The standard deviation\n   */\n  return typed(name, {\n    // std([a, b, c, d, ...])\n    'Array | Matrix': _std,\n    // std([a, b, c, d, ...], normalization)\n    'Array | Matrix, string': _std,\n    // std([a, b, c, c, ...], dim)\n    'Array | Matrix, number | BigNumber': _std,\n    // std([a, b, c, c, ...], dim, normalization)\n    'Array | Matrix, number | BigNumber, string': _std,\n    // std(a, b, c, d, ...)\n    '...': function _(args) {\n      return _std(args);\n    }\n  });\n\n  function _std(array, normalization) {\n    if (array.length === 0) {\n      throw new SyntaxError('Function std requires one or more parameters (0 provided)');\n    }\n\n    try {\n      return sqrt(variance.apply(null, arguments));\n    } catch (err) {\n      if (err instanceof TypeError && err.message.indexOf(' variance') !== -1) {\n        throw new TypeError(err.message.replace(' variance', ' std'));\n      } else {\n        throw err;\n      }\n    }\n  }\n});","function E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      evtArr[i].fn.apply(evtArr[i].ctx, data);\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\nmodule.exports.TinyEmitter = E;\n","/**\n * typed-function\n *\n * Type checking for JavaScript functions\n *\n * https://github.com/josdejong/typed-function\n */\n'use strict';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // OldNode. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like OldNode.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.typed = factory();\n  }\n}(this, function () {\n\n  function ok () {\n    return true;\n  }\n\n  function notOk () {\n    return false;\n  }\n\n  function undef () {\n    return undefined;\n  }\n\n  /**\n   * @typedef {{\n   *   params: Param[],\n   *   fn: function\n   * }} Signature\n   *\n   * @typedef {{\n   *   types: Type[],\n   *   restParam: boolean\n   * }} Param\n   *\n   * @typedef {{\n   *   name: string,\n   *   typeIndex: number,\n   *   test: function,\n   *   conversion?: ConversionDef,\n   *   conversionIndex: number,\n   * }} Type\n   *\n   * @typedef {{\n   *   from: string,\n   *   to: string,\n   *   convert: function (*) : *\n   * }} ConversionDef\n   *\n   * @typedef {{\n   *   name: string,\n   *   test: function(*) : boolean\n   * }} TypeDef\n   */\n\n  // create a new instance of typed-function\n  function create () {\n    // data type tests\n    var _types = [\n      { name: 'number',    test: function (x) { return typeof x === 'number' } },\n      { name: 'string',    test: function (x) { return typeof x === 'string' } },\n      { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },\n      { name: 'Function',  test: function (x) { return typeof x === 'function'} },\n      { name: 'Array',     test: Array.isArray },\n      { name: 'Date',      test: function (x) { return x instanceof Date } },\n      { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },\n      { name: 'Object',    test: function (x) {\n        return typeof x === 'object' && x !== null && x.constructor === Object\n      }},\n      { name: 'null',      test: function (x) { return x === null } },\n      { name: 'undefined', test: function (x) { return x === undefined } }\n    ];\n\n    var anyType = {\n      name: 'any',\n      test: ok\n    }\n\n    // types which need to be ignored\n    var _ignore = [];\n\n    // type conversions\n    var _conversions = [];\n\n    // This is a temporary object, will be replaced with a typed function at the end\n    var typed = {\n      types: _types,\n      conversions: _conversions,\n      ignore: _ignore\n    };\n\n    /**\n     * Find the test function for a type\n     * @param {String} typeName\n     * @return {TypeDef} Returns the type definition when found,\n     *                    Throws a TypeError otherwise\n     */\n    function findTypeByName (typeName) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.name === typeName;\n      });\n\n      if (entry) {\n        return entry;\n      }\n\n      if (typeName === 'any') { // special baked-in case 'any'\n        return anyType;\n      }\n\n      var hint = findInArray(typed.types, function (entry) {\n        return entry.name.toLowerCase() === typeName.toLowerCase();\n      });\n\n      throw new TypeError('Unknown type \"' + typeName + '\"' +\n          (hint ? ('. Did you mean \"' + hint.name + '\"?') : ''));\n    }\n\n    /**\n     * Find the index of a type definition. Handles special case 'any'\n     * @param {TypeDef} type\n     * @return {number}\n     */\n    function findTypeIndex(type) {\n      if (type === anyType) {\n        return 999;\n      }\n\n      return typed.types.indexOf(type);\n    }\n\n    /**\n     * Find a type that matches a value.\n     * @param {*} value\n     * @return {string} Returns the name of the first type for which\n     *                  the type test matches the value.\n     */\n    function findTypeName(value) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.test(value);\n      });\n\n      if (entry) {\n        return entry.name;\n      }\n\n      throw new TypeError('Value has unknown type. Value: ' + value);\n    }\n\n    /**\n     * Find a specific signature from a (composed) typed function, for example:\n     *\n     *   typed.find(fn, ['number', 'string'])\n     *   typed.find(fn, 'number, string')\n     *\n     * Function find only only works for exact matches.\n     *\n     * @param {Function} fn                   A typed-function\n     * @param {string | string[]} signature   Signature to be found, can be\n     *                                        an array or a comma separated string.\n     * @return {Function}                     Returns the matching signature, or\n     *                                        throws an error when no signature\n     *                                        is found.\n     */\n    function find (fn, signature) {\n      if (!fn.signatures) {\n        throw new TypeError('Function is no typed-function');\n      }\n\n      // normalize input\n      var arr;\n      if (typeof signature === 'string') {\n        arr = signature.split(',');\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = arr[i].trim();\n        }\n      }\n      else if (Array.isArray(signature)) {\n        arr = signature;\n      }\n      else {\n        throw new TypeError('String array or a comma separated string expected');\n      }\n\n      var str = arr.join(',');\n\n      // find an exact match\n      var match = fn.signatures[str];\n      if (match) {\n        return match;\n      }\n\n      // TODO: extend find to match non-exact signatures\n\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');\n    }\n\n    /**\n     * Convert a given value to another data type.\n     * @param {*} value\n     * @param {string} type\n     */\n    function convert (value, type) {\n      var from = findTypeName(value);\n\n      // check conversion is needed\n      if (type === from) {\n        return value;\n      }\n\n      for (var i = 0; i < typed.conversions.length; i++) {\n        var conversion = typed.conversions[i];\n        if (conversion.from === from && conversion.to === type) {\n          return conversion.convert(value);\n        }\n      }\n\n      throw new Error('Cannot convert from ' + from + ' to ' + type);\n    }\n    \n    /**\n     * Stringify parameters in a normalized way\n     * @param {Param[]} params\n     * @return {string}\n     */\n    function stringifyParams (params) {\n      return params\n          .map(function (param) {\n            var typeNames = param.types.map(getTypeName);\n\n            return (param.restParam ? '...' : '') + typeNames.join('|');\n          })\n          .join(',');\n    }\n\n    /**\n     * Parse a parameter, like \"...number | boolean\"\n     * @param {string} param\n     * @param {ConversionDef[]} conversions\n     * @return {Param} param\n     */\n    function parseParam (param, conversions) {\n      var restParam = param.indexOf('...') === 0;\n      var types = (!restParam)\n          ? param\n          : (param.length > 3)\n              ? param.slice(3)\n              : 'any';\n\n      var typeNames = types.split('|').map(trim)\n          .filter(notEmpty)\n          .filter(notIgnore);\n\n      var matchingConversions = filterConversions(conversions, typeNames);\n\n      var exactTypes = typeNames.map(function (typeName) {\n        var type = findTypeByName(typeName);\n\n        return {\n          name: typeName,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: null,\n          conversionIndex: -1\n        };\n      });\n\n      var convertibleTypes = matchingConversions.map(function (conversion) {\n        var type = findTypeByName(conversion.from);\n\n        return {\n          name: conversion.from,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: conversion,\n          conversionIndex: conversions.indexOf(conversion)\n        };\n      });\n\n      return {\n        types: exactTypes.concat(convertibleTypes),\n        restParam: restParam\n      };\n    }\n\n    /**\n     * Parse a signature with comma separated parameters,\n     * like \"number | boolean, ...string\"\n     * @param {string} signature\n     * @param {function} fn\n     * @param {ConversionDef[]} conversions\n     * @return {Signature | null} signature\n     */\n    function parseSignature (signature, fn, conversions) {\n      var params = [];\n\n      if (signature.trim() !== '') {\n        params = signature\n            .split(',')\n            .map(trim)\n            .map(function (param, index, array) {\n              var parsedParam = parseParam(param, conversions);\n\n              if (parsedParam.restParam && (index !== array.length - 1)) {\n                throw new SyntaxError('Unexpected rest parameter \"' + param + '\": ' +\n                    'only allowed for the last parameter');\n              }\n\n              return parsedParam;\n          });\n      }\n\n      if (params.some(isInvalidParam)) {\n        // invalid signature: at least one parameter has no types\n        // (they may have been filtered)\n        return null;\n      }\n\n      return {\n        params: params,\n        fn: fn\n      };\n    }\n\n    /**\n     * Test whether a set of params contains a restParam\n     * @param {Param[]} params\n     * @return {boolean} Returns true when the last parameter is a restParam\n     */\n    function hasRestParam(params) {\n      var param = last(params)\n      return param ? param.restParam : false;\n    }\n\n    /**\n     * Test whether a parameter contains conversions\n     * @param {Param} param\n     * @return {boolean} Returns true when at least one of the parameters\n     *                   contains a conversion.\n     */\n    function hasConversions(param) {\n      return param.types.some(function (type) {\n        return type.conversion != null;\n      });\n    }\n\n    /**\n     * Create a type test for a single parameter, which can have one or multiple\n     * types.\n     * @param {Param} param\n     * @return {function(x: *) : boolean} Returns a test function\n     */\n    function compileTest(param) {\n      if (!param || param.types.length === 0) {\n        // nothing to do\n        return ok;\n      }\n      else if (param.types.length === 1) {\n        return findTypeByName(param.types[0].name).test;\n      }\n      else if (param.types.length === 2) {\n        var test0 = findTypeByName(param.types[0].name).test;\n        var test1 = findTypeByName(param.types[1].name).test;\n        return function or(x) {\n          return test0(x) || test1(x);\n        }\n      }\n      else { // param.types.length > 2\n        var tests = param.types.map(function (type) {\n          return findTypeByName(type.name).test;\n        })\n        return function or(x) {\n          for (var i = 0; i < tests.length; i++) {\n            if (tests[i](x)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n    }\n\n    /**\n     * Create a test for all parameters of a signature\n     * @param {Param[]} params\n     * @return {function(args: Array<*>) : boolean}\n     */\n    function compileTests(params) {\n      var tests, test0, test1;\n\n      if (hasRestParam(params)) {\n        // variable arguments like '...number'\n        tests = initial(params).map(compileTest);\n        var varIndex = tests.length;\n        var lastTest = compileTest(last(params));\n        var testRestParam = function (args) {\n          for (var i = varIndex; i < args.length; i++) {\n            if (!lastTest(args[i])) {\n              return false;\n            }\n          }\n          return true;\n        }\n\n        return function testArgs(args) {\n          for (var i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false;\n            }\n          }\n          return testRestParam(args) && (args.length >= varIndex + 1);\n        };\n      }\n      else {\n        // no variable arguments\n        if (params.length === 0) {\n          return function testArgs(args) {\n            return args.length === 0;\n          };\n        }\n        else if (params.length === 1) {\n          test0 = compileTest(params[0]);\n          return function testArgs(args) {\n            return test0(args[0]) && args.length === 1;\n          };\n        }\n        else if (params.length === 2) {\n          test0 = compileTest(params[0]);\n          test1 = compileTest(params[1]);\n          return function testArgs(args) {\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\n          };\n        }\n        else { // arguments.length > 2\n          tests = params.map(compileTest);\n          return function testArgs(args) {\n            for (var i = 0; i < tests.length; i++) {\n              if (!tests[i](args[i])) {\n                return false;\n              }\n            }\n            return args.length === tests.length;\n          };\n        }\n      }\n    }\n\n    /**\n     * Find the parameter at a specific index of a signature.\n     * Handles rest parameters.\n     * @param {Signature} signature\n     * @param {number} index\n     * @return {Param | null} Returns the matching parameter when found,\n     *                        null otherwise.\n     */\n    function getParamAtIndex(signature, index) {\n      return index < signature.params.length\n          ? signature.params[index]\n          : hasRestParam(signature.params)\n              ? last(signature.params)\n              : null\n    }\n\n    /**\n     * Get all type names of a parameter\n     * @param {Signature} signature\n     * @param {number} index\n     * @param {boolean} excludeConversions\n     * @return {string[]} Returns an array with type names\n     */\n    function getExpectedTypeNames (signature, index, excludeConversions) {\n      var param = getParamAtIndex(signature, index);\n      var types = param\n          ? excludeConversions\n                  ? param.types.filter(isExactType)\n                  : param.types\n          : [];\n\n      return types.map(getTypeName);\n    }\n\n    /**\n     * Returns the name of a type\n     * @param {Type} type\n     * @return {string} Returns the type name\n     */\n    function getTypeName(type) {\n      return type.name;\n    }\n\n    /**\n     * Test whether a type is an exact type or conversion\n     * @param {Type} type\n     * @return {boolean} Returns true when\n     */\n    function isExactType(type) {\n      return type.conversion === null || type.conversion === undefined;\n    }\n\n    /**\n     * Helper function for creating error messages: create an array with\n     * all available types on a specific argument index.\n     * @param {Signature[]} signatures\n     * @param {number} index\n     * @return {string[]} Returns an array with available types\n     */\n    function mergeExpectedParams(signatures, index) {\n      var typeNames = uniq(flatMap(signatures, function (signature) {\n        return getExpectedTypeNames(signature, index, false);\n      }));\n\n      return (typeNames.indexOf('any') !== -1) ? ['any'] : typeNames;\n    }\n\n    /**\n     * Create\n     * @param {string} name             The name of the function\n     * @param {array.<*>} args          The actual arguments passed to the function\n     * @param {Signature[]} signatures  A list with available signatures\n     * @return {TypeError} Returns a type error with additional data\n     *                     attached to it in the property `data`\n     */\n    function createError(name, args, signatures) {\n      var err, expected;\n      var _name = name || 'unnamed';\n\n      // test for wrong type at some index\n      var matchingSignatures = signatures;\n      var index;\n      for (index = 0; index < args.length; index++) {\n        var nextMatchingDefs = matchingSignatures.filter(function (signature) {\n          var test = compileTest(getParamAtIndex(signature, index));\n          return (index < signature.params.length || hasRestParam(signature.params)) &&\n              test(args[index]);\n        });\n\n        if (nextMatchingDefs.length === 0) {\n          // no matching signatures anymore, throw error \"wrong type\"\n          expected = mergeExpectedParams(matchingSignatures, index);\n          if (expected.length > 0) {\n            var actualType = findTypeName(args[index]);\n\n            err = new TypeError('Unexpected type of argument in function ' + _name +\n                ' (expected: ' + expected.join(' or ') +\n                ', actual: ' + actualType + ', index: ' + index + ')');\n            err.data = {\n              category: 'wrongType',\n              fn: _name,\n              index: index,\n              actual: actualType,\n              expected: expected\n            }\n            return err;\n          }\n        }\n        else {\n          matchingSignatures = nextMatchingDefs;\n        }\n      }\n\n      // test for too few arguments\n      var lengths = matchingSignatures.map(function (signature) {\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\n      });\n      if (args.length < Math.min.apply(null, lengths)) {\n        expected = mergeExpectedParams(matchingSignatures, index);\n        err = new TypeError('Too few arguments in function ' + _name +\n            ' (expected: ' + expected.join(' or ') +\n            ', index: ' + args.length + ')');\n        err.data = {\n          category: 'tooFewArgs',\n          fn: _name,\n          index: args.length,\n          expected: expected\n        }\n        return err;\n      }\n\n      // test for too many arguments\n      var maxLength = Math.max.apply(null, lengths);\n      if (args.length > maxLength) {\n        err = new TypeError('Too many arguments in function ' + _name +\n            ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\n        err.data = {\n          category: 'tooManyArgs',\n          fn: _name,\n          index: args.length,\n          expectedLength: maxLength\n        }\n        return err;\n      }\n\n      err = new TypeError('Arguments of type \"' + args.join(', ') +\n          '\" do not match any of the defined signatures of function ' + _name + '.');\n      err.data = {\n        category: 'mismatch',\n        actual: args.map(findTypeName)\n      }\n      return err;\n    }\n\n    /**\n     * Find the lowest index of all exact types of a parameter (no conversions)\n     * @param {Param} param\n     * @return {number} Returns the index of the lowest type in typed.types\n     */\n    function getLowestTypeIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].typeIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Find the lowest index of the conversion of all types of the parameter\n     * having a conversion\n     * @param {Param} param\n     * @return {number} Returns the lowest index of the conversions of this type\n     */\n    function getLowestConversionIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (!isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].conversionIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Compare two params\n     * @param {Param} param1\n     * @param {Param} param2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareParams (param1, param2) {\n      var c;\n\n      // compare having a rest parameter or not\n      c = param1.restParam - param2.restParam;\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare having conversions or not\n      c = hasConversions(param1) - hasConversions(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of the types\n      c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of any conversion\n      return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\n    }\n\n    /**\n     * Compare two signatures\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareSignatures (signature1, signature2) {\n      var len = Math.min(signature1.params.length, signature2.params.length);\n      var i;\n      var c;\n\n      // compare whether the params have conversions at all or not\n      c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions)\n      if (c !== 0) {\n        return c;\n      }\n\n      // next compare whether the params have conversions one by one\n      for (i = 0; i < len; i++) {\n        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the types of the params one by one\n      for (i = 0; i < len; i++) {\n        c = compareParams(signature1.params[i], signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the number of params\n      return signature1.params.length - signature2.params.length;\n    }\n\n    /**\n     * Get params containing all types that can be converted to the defined types.\n     *\n     * @param {ConversionDef[]} conversions\n     * @param {string[]} typeNames\n     * @return {ConversionDef[]} Returns the conversions that are available\n     *                        for every type (if any)\n     */\n    function filterConversions(conversions, typeNames) {\n      var matches = {};\n\n      conversions.forEach(function (conversion) {\n        if (typeNames.indexOf(conversion.from) === -1 &&\n            typeNames.indexOf(conversion.to) !== -1 &&\n            !matches[conversion.from]) {\n          matches[conversion.from] = conversion;\n        }\n      });\n\n      return Object.keys(matches).map(function (from) {\n        return matches[from];\n      });\n    }\n\n    /**\n     * Preprocess arguments before calling the original function:\n     * - if needed convert the parameters\n     * - in case of rest parameters, move the rest parameters into an Array\n     * @param {Param[]} params\n     * @param {function} fn\n     * @return {function} Returns a wrapped function\n     */\n    function compileArgsPreprocessing(params, fn) {\n      var fnConvert = fn;\n\n      // TODO: can we make this wrapper function smarter/simpler?\n\n      if (params.some(hasConversions)) {\n        var restParam = hasRestParam(params);\n        var compiledConversions = params.map(compileArgConversion)\n\n        fnConvert = function convertArgs() {\n          var args = [];\n          var last = restParam ? arguments.length - 1 : arguments.length;\n          for (var i = 0; i < last; i++) {\n            args[i] = compiledConversions[i](arguments[i]);\n          }\n          if (restParam) {\n            args[last] = arguments[last].map(compiledConversions[last]);\n          }\n\n          return fn.apply(null, args);\n        }\n      }\n\n      var fnPreprocess = fnConvert;\n      if (hasRestParam(params)) {\n        var offset = params.length - 1;\n\n        fnPreprocess = function preprocessRestParams () {\n          return fnConvert.apply(null,\n              slice(arguments, 0, offset).concat([slice(arguments, offset)]));\n        }\n      }\n\n      return fnPreprocess;\n    }\n\n    /**\n     * Compile conversion for a parameter to the right type\n     * @param {Param} param\n     * @return {function} Returns the wrapped function that will convert arguments\n     *\n     */\n    function compileArgConversion(param) {\n      var test0, test1, conversion0, conversion1;\n      var tests = [];\n      var conversions = [];\n\n      param.types.forEach(function (type) {\n        if (type.conversion) {\n          tests.push(findTypeByName(type.conversion.from).test);\n          conversions.push(type.conversion.convert);\n        }\n      });\n\n      // create optimized conversion functions depending on the number of conversions\n      switch (conversions.length) {\n        case 0:\n          return function convertArg(arg) {\n            return arg;\n          }\n\n        case 1:\n          test0 = tests[0]\n          conversion0 = conversions[0];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            return arg;\n          }\n\n        case 2:\n          test0 = tests[0]\n          test1 = tests[1]\n          conversion0 = conversions[0];\n          conversion1 = conversions[1];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            if (test1(arg)) {\n              return conversion1(arg)\n            }\n            return arg;\n          }\n\n        default:\n          return function convertArg(arg) {\n            for (var i = 0; i < conversions.length; i++) {\n              if (tests[i](arg)) {\n                return conversions[i](arg);\n              }\n            }\n            return arg;\n          }\n      }\n    }\n\n    /**\n     * Convert an array with signatures into a map with signatures,\n     * where signatures with union types are split into separate signatures\n     *\n     * Throws an error when there are conflicting types\n     *\n     * @param {Signature[]} signatures\n     * @return {Object.<string, function>}  Returns a map with signatures\n     *                                      as key and the original function\n     *                                      of this signature as value.\n     */\n    function createSignaturesMap(signatures) {\n      var signaturesMap = {};\n      signatures.forEach(function (signature) {\n        if (!signature.params.some(hasConversions)) {\n          splitParams(signature.params, true).forEach(function (params) {\n            signaturesMap[stringifyParams(params)] = signature.fn;\n          });\n        }\n      });\n\n      return signaturesMap;\n    }\n\n    /**\n     * Split params with union types in to separate params.\n     *\n     * For example:\n     *\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n     *     // returns:\n     *     // [\n     *     //   ['Array', 'string'],\n     *     //   ['Array', 'RegExp'],\n     *     //   ['Object', 'string'],\n     *     //   ['Object', 'RegExp']\n     *     // ]\n     *\n     * @param {Param[]} params\n     * @param {boolean} ignoreConversionTypes\n     * @return {Param[]}\n     */\n    function splitParams(params, ignoreConversionTypes) {\n      function _splitParams(params, index, types) {\n        if (index < params.length) {\n          var param = params[index]\n          var filteredTypes = ignoreConversionTypes\n              ? param.types.filter(isExactType)\n              : param.types;\n          var typeGroups\n\n          if (param.restParam) {\n            // split the types of a rest parameter in two:\n            // one with only exact types, and one with exact types and conversions\n            var exactTypes = filteredTypes.filter(isExactType)\n            typeGroups = exactTypes.length < filteredTypes.length\n                ? [exactTypes, filteredTypes]\n                : [filteredTypes]\n\n          }\n          else {\n            // split all the types of a regular parameter into one type per group\n            typeGroups = filteredTypes.map(function (type) {\n              return [type]\n            })\n          }\n\n          // recurse over the groups with types\n          return flatMap(typeGroups, function (typeGroup) {\n            return _splitParams(params, index + 1, types.concat([typeGroup]));\n          });\n\n        }\n        else {\n          // we've reached the end of the parameters. Now build a new Param\n          var splittedParams = types.map(function (type, typeIndex) {\n            return {\n              types: type,\n              restParam: (typeIndex === params.length - 1) && hasRestParam(params)\n            }\n          });\n\n          return [splittedParams];\n        }\n      }\n\n      return _splitParams(params, 0, []);\n    }\n\n    /**\n     * Test whether two signatures have a conflicting signature\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\n     */\n    function hasConflictingParams(signature1, signature2) {\n      var ii = Math.max(signature1.params.length, signature2.params.length);\n\n      for (var i = 0; i < ii; i++) {\n        var typesNames1 = getExpectedTypeNames(signature1, i, true);\n        var typesNames2 = getExpectedTypeNames(signature2, i, true);\n\n        if (!hasOverlap(typesNames1, typesNames2)) {\n          return false;\n        }\n      }\n\n      var len1 = signature1.params.length;\n      var len2 = signature2.params.length;\n      var restParam1 = hasRestParam(signature1.params);\n      var restParam2 = hasRestParam(signature2.params);\n\n      return restParam1\n          ? restParam2 ? (len1 === len2) : (len2 >= len1)\n          : restParam2 ? (len1 >= len2)  : (len1 === len2)\n    }\n\n    /**\n     * Create a typed function\n     * @param {String} name               The name for the typed function\n     * @param {Object.<string, function>} signaturesMap\n     *                                    An object with one or\n     *                                    multiple signatures as key, and the\n     *                                    function corresponding to the\n     *                                    signature as value.\n     * @return {function}  Returns the created typed function.\n     */\n    function createTypedFunction(name, signaturesMap) {\n      if (Object.keys(signaturesMap).length === 0) {\n        throw new SyntaxError('No signatures provided');\n      }\n\n      // parse the signatures, and check for conflicts\n      var parsedSignatures = [];\n      Object.keys(signaturesMap)\n          .map(function (signature) {\n            return parseSignature(signature, signaturesMap[signature], typed.conversions);\n          })\n          .filter(notNull)\n          .forEach(function (parsedSignature) {\n            // check whether this parameter conflicts with already parsed signatures\n            var conflictingSignature = findInArray(parsedSignatures, function (s) {\n              return hasConflictingParams(s, parsedSignature)\n            });\n            if (conflictingSignature) {\n              throw new TypeError('Conflicting signatures \"' +\n                  stringifyParams(conflictingSignature.params) + '\" and \"' +\n                  stringifyParams(parsedSignature.params) + '\".');\n            }\n\n            parsedSignatures.push(parsedSignature);\n          });\n\n      // split and filter the types of the signatures, and then order them\n      var signatures = flatMap(parsedSignatures, function (parsedSignature) {\n        var params = parsedSignature ? splitParams(parsedSignature.params, false) : []\n\n        return params.map(function (params) {\n          return {\n            params: params,\n            fn: parsedSignature.fn\n          };\n        });\n      }).filter(notNull);\n\n      signatures.sort(compareSignatures);\n\n      // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\n      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\n      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\n      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\n      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\n      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\n      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;\n\n      // compile the tests\n      var tests = signatures.map(function (signature) {\n        return compileTests(signature.params);\n      });\n\n      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\n      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\n      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\n      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\n      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\n      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\n\n      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\n      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\n      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\n      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\n      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\n      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;\n\n      // compile the functions\n      var fns = signatures.map(function(signature) {\n        return compileArgsPreprocessing(signature.params, signature.fn)\n      });\n\n      var fn0 = ok0 ? fns[0] : undef;\n      var fn1 = ok1 ? fns[1] : undef;\n      var fn2 = ok2 ? fns[2] : undef;\n      var fn3 = ok3 ? fns[3] : undef;\n      var fn4 = ok4 ? fns[4] : undef;\n      var fn5 = ok5 ? fns[5] : undef;\n\n      var len0 = ok0 ? signatures[0].params.length : -1;\n      var len1 = ok1 ? signatures[1].params.length : -1;\n      var len2 = ok2 ? signatures[2].params.length : -1;\n      var len3 = ok3 ? signatures[3].params.length : -1;\n      var len4 = ok4 ? signatures[4].params.length : -1;\n      var len5 = ok5 ? signatures[5].params.length : -1;\n\n      // simple and generic, but also slow\n      var iStart = allOk ? 6 : 0;\n      var iEnd = signatures.length;\n      var generic = function generic() {\n        'use strict';\n\n        for (var i = iStart; i < iEnd; i++) {\n          if (tests[i](arguments)) {\n            return fns[i].apply(null, arguments);\n          }\n        }\n\n        throw createError(name, arguments, signatures);\n      }\n\n      // create the typed function\n      // fast, specialized version. Falls back to the slower, generic one if needed\n      var fn = function fn(arg0, arg1) {\n        'use strict';\n\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(null, arguments); }\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(null, arguments); }\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(null, arguments); }\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(null, arguments); }\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(null, arguments); }\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(null, arguments); }\n\n        return generic.apply(null, arguments);\n      }\n\n      // attach name the typed function\n      try {\n        Object.defineProperty(fn, 'name', {value: name});\n      }\n      catch (err) {\n        // old browsers do not support Object.defineProperty and some don't support setting the name property\n        // the function name is not essential for the functioning, it's mostly useful for debugging,\n        // so it's fine to have unnamed functions.\n      }\n\n      // attach signatures to the function\n      fn.signatures = createSignaturesMap(signatures);\n\n      return fn;\n    }\n\n    /**\n     * Test whether a type should be NOT be ignored\n     * @param {string} typeName\n     * @return {boolean}\n     */\n    function notIgnore(typeName) {\n      return typed.ignore.indexOf(typeName) === -1;\n    }\n\n    /**\n     * trim a string\n     * @param {string} str\n     * @return {string}\n     */\n    function trim(str) {\n      return str.trim();\n    }\n\n    /**\n     * Test whether a string is not empty\n     * @param {string} str\n     * @return {boolean}\n     */\n    function notEmpty(str) {\n      return !!str;\n    }\n\n    /**\n     * test whether a value is not strict equal to null\n     * @param {*} value\n     * @return {boolean}\n     */\n    function notNull(value) {\n      return value !== null;\n    }\n\n    /**\n     * Test whether a parameter has no types defined\n     * @param {Param} param\n     * @return {boolean}\n     */\n    function isInvalidParam (param) {\n      return param.types.length === 0;\n    }\n\n    /**\n     * Return all but the last items of an array\n     * @param {Array} arr\n     * @return {Array}\n     */\n    function initial(arr) {\n      return arr.slice(0, arr.length - 1);\n    }\n\n    /**\n     * return the last item of an array\n     * @param {Array} arr\n     * @return {*}\n     */\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n\n    /**\n     * Slice an array or function Arguments\n     * @param {Array | Arguments | IArguments} arr\n     * @param {number} start\n     * @param {number} [end]\n     * @return {Array}\n     */\n    function slice(arr, start, end) {\n      return Array.prototype.slice.call(arr, start, end);\n    }\n\n    /**\n     * Test whether an array contains some item\n     * @param {Array} array\n     * @param {*} item\n     * @return {boolean} Returns true if array contains item, false if not.\n     */\n    function contains(array, item) {\n      return array.indexOf(item) !== -1;\n    }\n\n    /**\n     * Test whether two arrays have overlapping items\n     * @param {Array} array1\n     * @param {Array} array2\n     * @return {boolean} Returns true when at least one item exists in both arrays\n     */\n    function hasOverlap(array1, array2) {\n      for (var i = 0; i < array1.length; i++) {\n        if (contains(array2, array1[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Return the first item from an array for which test(arr[i]) returns true\n     * @param {Array} arr\n     * @param {function} test\n     * @return {* | undefined} Returns the first matching item\n     *                         or undefined when there is no match\n     */\n    function findInArray(arr, test) {\n      for (var i = 0; i < arr.length; i++) {\n        if (test(arr[i])) {\n          return arr[i];\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * Filter unique items of an array with strings\n     * @param {string[]} arr\n     * @return {string[]}\n     */\n    function uniq(arr) {\n      var entries = {}\n      for (var i = 0; i < arr.length; i++) {\n        entries[arr[i]] = true;\n      }\n      return Object.keys(entries);\n    }\n\n    /**\n     * Flat map the result invoking a callback for every item in an array.\n     * https://gist.github.com/samgiles/762ee337dff48623e729\n     * @param {Array} arr\n     * @param {function} callback\n     * @return {Array}\n     */\n    function flatMap(arr, callback) {\n      return Array.prototype.concat.apply([], arr.map(callback));\n    }\n\n    /**\n     * Retrieve the function name from a set of typed functions,\n     * and check whether the name of all functions match (if given)\n     * @param {function[]} fns\n     */\n    function getName (fns) {\n      var name = '';\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // check whether the names are the same when defined\n        if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {\n          if (name === '') {\n            name = fn.name;\n          }\n          else if (name !== fn.name) {\n            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');\n            err.data = {\n              actual: fn.name,\n              expected: name\n            };\n            throw err;\n          }\n        }\n      }\n\n      return name;\n    }\n\n    // extract and merge all signatures of a list with typed functions\n    function extractSignatures(fns) {\n      var err;\n      var signaturesMap = {};\n\n      function validateUnique(_signature, _fn) {\n        if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {\n          err = new Error('Signature \"' + _signature + '\" is defined twice');\n          err.data = {signature: _signature};\n          throw err;\n          // else: both signatures point to the same function, that's fine\n        }\n      }\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // test whether this is a typed-function\n        if (typeof fn.signatures === 'object') {\n          // merge the signatures\n          for (var signature in fn.signatures) {\n            if (fn.signatures.hasOwnProperty(signature)) {\n              validateUnique(signature, fn.signatures[signature]);\n              signaturesMap[signature] = fn.signatures[signature];\n            }\n          }\n        }\n        else if (typeof fn.signature === 'string') {\n          validateUnique(fn.signature, fn);\n          signaturesMap[fn.signature] = fn;\n        }\n        else {\n          err = new TypeError('Function is no typed-function (index: ' + i + ')');\n          err.data = {index: i};\n          throw err;\n        }\n      }\n\n      return signaturesMap;\n    }\n\n    typed = createTypedFunction('typed', {\n      'string, Object': createTypedFunction,\n      'Object': function (signaturesMap) {\n        // find existing name\n        var fns = [];\n        for (var signature in signaturesMap) {\n          if (signaturesMap.hasOwnProperty(signature)) {\n            fns.push(signaturesMap[signature]);\n          }\n        }\n        var name = getName(fns);\n        return createTypedFunction(name, signaturesMap);\n      },\n      '...Function': function (fns) {\n        return createTypedFunction(getName(fns), extractSignatures(fns));\n      },\n      'string, ...Function': function (name, fns) {\n        return createTypedFunction(name, extractSignatures(fns));\n      }\n    });\n\n    typed.create = create;\n    typed.types = _types;\n    typed.conversions = _conversions;\n    typed.ignore = _ignore;\n    typed.convert = convert;\n    typed.find = find;\n\n    /**\n     * add a type\n     * @param {{name: string, test: function}} type\n     * @param {boolean} [beforeObjectTest=true]\n     *                          If true, the new test will be inserted before\n     *                          the test with name 'Object' (if any), since\n     *                          tests for Object match Array and classes too.\n     */\n    typed.addType = function (type, beforeObjectTest) {\n      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected');\n      }\n\n      if (beforeObjectTest !== false) {\n        for (var i = 0; i < typed.types.length; i++) {\n          if (typed.types[i].name === 'Object') {\n            typed.types.splice(i, 0, type);\n            return\n          }\n        }\n      }\n\n      typed.types.push(type);\n    };\n\n    // add a conversion\n    typed.addConversion = function (conversion) {\n      if (!conversion\n          || typeof conversion.from !== 'string'\n          || typeof conversion.to !== 'string'\n          || typeof conversion.convert !== 'function') {\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\n      }\n\n      typed.conversions.push(conversion);\n    };\n\n    return typed;\n  }\n\n  return create();\n}));","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { addDependencies } from './dependenciesAdd.generated';\nimport { divideDependencies } from './dependenciesDivide.generated';\nimport { typedDependencies } from './dependenciesTyped.generated';\nimport { createMean } from '../../factoriesNumber.js';\nexport var meanDependencies = {\n  addDependencies: addDependencies,\n  divideDependencies: divideDependencies,\n  typedDependencies: typedDependencies,\n  createMean: createMean\n};","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { typedDependencies } from './dependenciesTyped.generated';\nimport { createSqrt } from '../../factoriesNumber.js';\nexport var sqrtDependencies = {\n  typedDependencies: typedDependencies,\n  createSqrt: createSqrt\n};","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { typedDependencies } from './dependenciesTyped.generated';\nimport { createIsInteger } from '../../factoriesNumber.js';\nexport var isIntegerDependencies = {\n  typedDependencies: typedDependencies,\n  createIsInteger: createIsInteger\n};","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { isIntegerDependencies } from './dependenciesIsInteger.generated';\nimport { typedDependencies } from './dependenciesTyped.generated';\nimport { createApply } from '../../factoriesNumber.js';\nexport var applyDependencies = {\n  isIntegerDependencies: isIntegerDependencies,\n  typedDependencies: typedDependencies,\n  createApply: createApply\n};","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { typedDependencies } from './dependenciesTyped.generated';\nimport { createMultiply } from '../../factoriesNumber.js';\nexport var multiplyDependencies = {\n  typedDependencies: typedDependencies,\n  createMultiply: createMultiply\n};","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { typedDependencies } from './dependenciesTyped.generated';\nimport { createSubtract } from '../../factoriesNumber.js';\nexport var subtractDependencies = {\n  typedDependencies: typedDependencies,\n  createSubtract: createSubtract\n};","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { addDependencies } from './dependenciesAdd.generated';\nimport { applyDependencies } from './dependenciesApply.generated';\nimport { divideDependencies } from './dependenciesDivide.generated';\nimport { isNaNDependencies } from './dependenciesIsNaN.generated';\nimport { multiplyDependencies } from './dependenciesMultiply.generated';\nimport { subtractDependencies } from './dependenciesSubtract.generated';\nimport { typedDependencies } from './dependenciesTyped.generated';\nimport { createVariance } from '../../factoriesNumber.js';\nexport var varianceDependencies = {\n  addDependencies: addDependencies,\n  applyDependencies: applyDependencies,\n  divideDependencies: divideDependencies,\n  isNaNDependencies: isNaNDependencies,\n  multiplyDependencies: multiplyDependencies,\n  subtractDependencies: subtractDependencies,\n  typedDependencies: typedDependencies,\n  createVariance: createVariance\n};","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { sqrtDependencies } from './dependenciesSqrt.generated';\nimport { typedDependencies } from './dependenciesTyped.generated';\nimport { varianceDependencies } from './dependenciesVariance.generated';\nimport { createStd } from '../../factoriesNumber.js';\nexport var stdDependencies = {\n  sqrtDependencies: sqrtDependencies,\n  typedDependencies: typedDependencies,\n  varianceDependencies: varianceDependencies,\n  createStd: createStd\n};","/**\n * Create a syntax error with the message:\n *     'Wrong number of arguments in function <fn> (<count> provided, <min>-<max> expected)'\n * @param {string} fn     Function name\n * @param {number} count  Actual argument count\n * @param {number} min    Minimum required argument count\n * @param {number} [max]  Maximum required argument count\n * @extends Error\n */\nexport function ArgumentsError(fn, count, min, max) {\n  if (!(this instanceof ArgumentsError)) {\n    throw new SyntaxError('Constructor must be called with the new operator');\n  }\n\n  this.fn = fn;\n  this.count = count;\n  this.min = min;\n  this.max = max;\n  this.message = 'Wrong number of arguments in function ' + fn + ' (' + count + ' provided, ' + min + (max !== undefined && max !== null ? '-' + max : '') + ' expected)';\n  this.stack = new Error().stack;\n}\nArgumentsError.prototype = new Error();\nArgumentsError.prototype.constructor = Error;\nArgumentsError.prototype.name = 'ArgumentsError';\nArgumentsError.prototype.isArgumentsError = true;","function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { isBigNumber, isComplex, isFraction, isMatrix, isUnit } from '../../utils/is';\nimport { isFactory, stripOptionalNotation } from '../../utils/factory';\nimport { hasOwnProperty, isLegacyFactory, lazy, traverse } from '../../utils/object';\nimport { contains } from '../../utils/array';\nimport { ArgumentsError } from '../../error/ArgumentsError';\nimport { warnOnce } from '../../utils/log';\nexport function importFactory(typed, load, math, importedFactories) {\n  /**\n   * Import functions from an object or a module.\n   *\n   * This function is only available on a mathjs instance created using `create`.\n   *\n   * Syntax:\n   *\n   *    math.import(functions)\n   *    math.import(functions, options)\n   *\n   * Where:\n   *\n   * - `functions: Object`\n   *   An object with functions or factories to be imported.\n   * - `options: Object` An object with import options. Available options:\n   *   - `override: boolean`\n   *     If true, existing functions will be overwritten. False by default.\n   *   - `silent: boolean`\n   *     If true, the function will not throw errors on duplicates or invalid\n   *     types. False by default.\n   *   - `wrap: boolean`\n   *     If true, the functions will be wrapped in a wrapper function\n   *     which converts data types like Matrix to primitive data types like Array.\n   *     The wrapper is needed when extending math.js with libraries which do not\n   *     support these data type. False by default.\n   *\n   * Examples:\n   *\n   *    import { create, all } from 'mathjs'\n   *    import * as numbers from 'numbers'\n   *\n   *    // create a mathjs instance\n   *    const math = create(all)\n   *\n   *    // define new functions and variables\n   *    math.import({\n   *      myvalue: 42,\n   *      hello: function (name) {\n   *        return 'hello, ' + name + '!'\n   *      }\n   *    })\n   *\n   *    // use the imported function and variable\n   *    math.myvalue * 2               // 84\n   *    math.hello('user')             // 'hello, user!'\n   *\n   *    // import the npm module 'numbers'\n   *    // (must be installed first with `npm install numbers`)\n   *    math.import(numbers, {wrap: true})\n   *\n   *    math.fibonacci(7) // returns 13\n   *\n   * @param {Object | Array} functions  Object with functions to be imported.\n   * @param {Object} [options]          Import options.\n   */\n  function mathImport(functions, options) {\n    var num = arguments.length;\n\n    if (num !== 1 && num !== 2) {\n      throw new ArgumentsError('import', num, 1, 2);\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    function flattenImports(flatValues, value, name) {\n      if (isLegacyFactory(value)) {\n        // legacy factories don't always have a name,\n        // let's not handle them via the new flatValues\n        _importLegacyFactory(value, options);\n      } else if (Array.isArray(value)) {\n        value.forEach(function (item) {\n          return flattenImports(flatValues, item);\n        });\n      } else if (_typeof(value) === 'object') {\n        for (var _name in value) {\n          if (hasOwnProperty(value, _name)) {\n            flattenImports(flatValues, value[_name], _name);\n          }\n        }\n      } else if (isFactory(value) || name !== undefined) {\n        var flatName = isFactory(value) ? isTransformFunctionFactory(value) ? value.fn + '.transform' : // TODO: this is ugly\n        value.fn : name; // we allow importing the same function twice if it points to the same implementation\n\n        if (hasOwnProperty(flatValues, flatName) && flatValues[flatName] !== value && !options.silent) {\n          throw new Error('Cannot import \"' + flatName + '\" twice');\n        }\n\n        flatValues[flatName] = value;\n      } else {\n        if (!options.silent) {\n          throw new TypeError('Factory, Object, or Array expected');\n        }\n      }\n    }\n\n    var flatValues = {};\n    flattenImports(flatValues, functions);\n\n    for (var name in flatValues) {\n      if (hasOwnProperty(flatValues, name)) {\n        // console.log('import', name)\n        var value = flatValues[name];\n\n        if (isFactory(value)) {\n          // we ignore name here and enforce the name of the factory\n          // maybe at some point we do want to allow overriding it\n          // in that case we can implement an option overrideFactoryNames: true\n          _importFactory(value, options);\n        } else if (isSupportedType(value)) {\n          _import(name, value, options);\n        } else {\n          if (!options.silent) {\n            throw new TypeError('Factory, Object, or Array expected');\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Add a property to the math namespace\n   * @param {string} name\n   * @param {*} value\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n\n\n  function _import(name, value, options) {\n    // TODO: refactor this function, it's to complicated and contains duplicate code\n    if (options.wrap && typeof value === 'function') {\n      // create a wrapper around the function\n      value = _wrap(value);\n    } // turn a plain function with a typed-function signature into a typed-function\n\n\n    if (hasTypedFunctionSignature(value)) {\n      value = typed(name, _defineProperty({}, value.signature, value));\n    }\n\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\n      if (options.override) {\n        // give the typed function the right name\n        value = typed(name, value.signatures);\n      } else {\n        // merge the existing and typed function\n        value = typed(math[name], value);\n      }\n\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (math[name] === undefined || options.override) {\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (!options.silent) {\n      throw new Error('Cannot import \"' + name + '\": already exists');\n    }\n  }\n\n  function _importTransform(name, value) {\n    if (value && typeof value.transform === 'function') {\n      math.expression.transform[name] = value.transform;\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value.transform;\n      }\n    } else {\n      // remove existing transform\n      delete math.expression.transform[name];\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value;\n      }\n    }\n  }\n\n  function _deleteTransform(name) {\n    delete math.expression.transform[name];\n\n    if (allowedInExpressions(name)) {\n      math.expression.mathWithTransform[name] = math[name];\n    } else {\n      delete math.expression.mathWithTransform[name];\n    }\n  }\n  /**\n   * Create a wrapper a round an function which converts the arguments\n   * to their primitive values (like convert a Matrix to Array)\n   * @param {Function} fn\n   * @return {Function} Returns the wrapped function\n   * @private\n   */\n\n\n  function _wrap(fn) {\n    var wrapper = function wrapper() {\n      var args = [];\n\n      for (var i = 0, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        args[i] = arg && arg.valueOf();\n      }\n\n      return fn.apply(math, args);\n    };\n\n    if (fn.transform) {\n      wrapper.transform = fn.transform;\n    }\n\n    return wrapper;\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {{factory: Function, name: string, path: string, math: boolean}} factory\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n  // TODO: _importLegacyFactory is deprecated since v6.0.0, clean up some day\n\n\n  function _importLegacyFactory(factory, options) {\n    warnOnce('Factories of type { name, factory } are deprecated since v6. ' + 'Please create your factory functions using the math.factory function.');\n\n    if (typeof factory.name === 'string') {\n      var name = factory.name;\n      var existingTransform = name in math.expression.transform;\n      var namespace = factory.path ? traverse(math, factory.path) : math;\n      var existing = hasOwnProperty(namespace, name) ? namespace[name] : undefined;\n\n      var resolver = function resolver() {\n        var instance = load(factory);\n\n        if (instance && typeof instance.transform === 'function') {\n          throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n        }\n\n        if (isTypedFunction(existing) && isTypedFunction(instance)) {\n          if (options.override) {// replace the existing typed function (nothing to do)\n          } else {\n            // merge the existing and new typed function\n            instance = typed(existing, instance);\n          }\n\n          return instance;\n        }\n\n        if (existing === undefined || options.override) {\n          return instance;\n        }\n\n        if (options.silent) {\n          return existing;\n        } else {\n          throw new Error('Cannot import \"' + name + '\": already exists');\n        }\n      };\n\n      if (factory.lazy !== false) {\n        lazy(namespace, name, resolver);\n\n        if (existingTransform) {\n          _deleteTransform(name);\n        } else {\n          if (factory.path === 'expression.transform' || legacyFactoryAllowedInExpressions(factory)) {\n            lazy(math.expression.mathWithTransform, name, resolver);\n          }\n        }\n      } else {\n        namespace[name] = resolver();\n\n        if (existingTransform) {\n          _deleteTransform(name);\n        } else {\n          if (factory.path === 'expression.transform' || legacyFactoryAllowedInExpressions(factory)) {\n            math.expression.mathWithTransform[name] = resolver();\n          }\n        }\n      }\n\n      var key = factory.path ? factory.path + '.' + factory.name : factory.name;\n      importedFactories[key] = factory;\n      math.emit('import', name, resolver, factory.path);\n    } else {\n      // unnamed factory.\n      // no lazy loading\n      load(factory);\n    }\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {function(scope: object)} factory\n   * @param {Object} options  See import for a description of the options\n   * @param {string} [name=factory.name] Optional custom name\n   * @private\n   */\n\n\n  function _importFactory(factory, options) {\n    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : factory.fn;\n\n    if (contains(name, '.')) {\n      throw new Error('Factory name should not contain a nested path. ' + 'Name: ' + JSON.stringify(name));\n    }\n\n    var namespace = isTransformFunctionFactory(factory) ? math.expression.transform : math;\n    var existingTransform = name in math.expression.transform;\n    var existing = hasOwnProperty(namespace, name) ? namespace[name] : undefined;\n\n    var resolver = function resolver() {\n      // collect all dependencies, handle finding both functions and classes and other special cases\n      var dependencies = {};\n      factory.dependencies.map(stripOptionalNotation).forEach(function (dependency) {\n        if (contains(dependency, '.')) {\n          throw new Error('Factory dependency should not contain a nested path. ' + 'Name: ' + JSON.stringify(dependency));\n        }\n\n        if (dependency === 'math') {\n          dependencies.math = math;\n        } else if (dependency === 'mathWithTransform') {\n          dependencies.mathWithTransform = math.expression.mathWithTransform;\n        } else if (dependency === 'classes') {\n          // special case for json reviver\n          dependencies.classes = math;\n        } else {\n          dependencies[dependency] = math[dependency];\n        }\n      });\n      var instance =\n      /* #__PURE__ */\n      factory(dependencies);\n\n      if (instance && typeof instance.transform === 'function') {\n        throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n      }\n\n      if (existing === undefined || options.override) {\n        return instance;\n      }\n\n      if (isTypedFunction(existing) && isTypedFunction(instance)) {\n        // merge the existing and new typed function\n        return typed(existing, instance);\n      }\n\n      if (options.silent) {\n        // keep existing, ignore imported function\n        return existing;\n      } else {\n        throw new Error('Cannot import \"' + name + '\": already exists');\n      }\n    }; // TODO: add unit test with non-lazy factory\n\n\n    if (!factory.meta || factory.meta.lazy !== false) {\n      lazy(namespace, name, resolver); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          lazy(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } else {\n      namespace[name] = resolver(); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          lazy(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } // TODO: improve factories, store a list with imports instead which can be re-played\n\n\n    importedFactories[name] = factory;\n    math.emit('import', name, resolver);\n  }\n  /**\n   * Check whether given object is a type which can be imported\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\n   * @return {boolean}\n   * @private\n   */\n\n\n  function isSupportedType(object) {\n    return typeof object === 'function' || typeof object === 'number' || typeof object === 'string' || typeof object === 'boolean' || object === null || isUnit(object) || isComplex(object) || isBigNumber(object) || isFraction(object) || isMatrix(object) || Array.isArray(object);\n  }\n  /**\n   * Test whether a given thing is a typed-function\n   * @param {*} fn\n   * @return {boolean} Returns true when `fn` is a typed-function\n   */\n\n\n  function isTypedFunction(fn) {\n    return typeof fn === 'function' && _typeof(fn.signatures) === 'object';\n  }\n\n  function hasTypedFunctionSignature(fn) {\n    return typeof fn === 'function' && typeof fn.signature === 'string';\n  }\n\n  function allowedInExpressions(name) {\n    return !hasOwnProperty(unsafe, name);\n  }\n\n  function legacyFactoryAllowedInExpressions(factory) {\n    return factory.path === undefined && !hasOwnProperty(unsafe, factory.name);\n  }\n\n  function factoryAllowedInExpressions(factory) {\n    return factory.fn.indexOf('.') === -1 && // FIXME: make checking on path redundant, check on meta data instead\n    !hasOwnProperty(unsafe, factory.fn) && (!factory.meta || !factory.meta.isClass);\n  }\n\n  function isTransformFunctionFactory(factory) {\n    return factory !== undefined && factory.meta !== undefined && factory.meta.isTransformFunction === true || false;\n  } // namespaces and functions not available in the parser for safety reasons\n\n\n  var unsafe = {\n    expression: true,\n    type: true,\n    docs: true,\n    error: true,\n    json: true,\n    chain: true // chain method not supported. Note that there is a unit chain too.\n\n  };\n  return mathImport;\n}","export var DEFAULT_CONFIG = {\n  // minimum relative difference between two compared values,\n  // used by all comparison functions\n  epsilon: 1e-12,\n  // type of default matrix output. Choose 'matrix' (default) or 'array'\n  matrix: 'Matrix',\n  // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction\n  number: 'number',\n  // number of significant digits in BigNumbers\n  precision: 64,\n  // predictable output type of functions. When true, output type depends only\n  // on the input types. When false (default), output type can vary depending\n  // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when\n  // predictable is false, and returns `NaN` when true.\n  predictable: false,\n  // random seed for seeded pseudo random number generation\n  // null = randomly seed\n  randomSeed: null\n};","import { clone, mapObject, deepExtend } from '../../utils/object';\nimport { DEFAULT_CONFIG } from '../config';\nexport var MATRIX_OPTIONS = ['Matrix', 'Array']; // valid values for option matrix\n\nexport var NUMBER_OPTIONS = ['number', 'BigNumber', 'Fraction']; // valid values for option number\n\nexport function configFactory(config, emit) {\n  /**\n   * Set configuration options for math.js, and get current options.\n   * Will emit a 'config' event, with arguments (curr, prev, changes).\n   *\n   * This function is only available on a mathjs instance created using `create`.\n   *\n   * Syntax:\n   *\n   *     math.config(config: Object): Object\n   *\n   * Examples:\n   *\n   *\n   *     import { create, all } from 'mathjs'\n   *\n   *     // create a mathjs instance\n   *     const math = create(all)\n   *\n   *     math.config().number                // outputs 'number'\n   *     math.evaluate('0.4')                // outputs number 0.4\n   *     math.config({number: 'Fraction'})\n   *     math.evaluate('0.4')                // outputs Fraction 2/5\n   *\n   * @param {Object} [options] Available options:\n   *                            {number} epsilon\n   *                              Minimum relative difference between two\n   *                              compared values, used by all comparison functions.\n   *                            {string} matrix\n   *                              A string 'Matrix' (default) or 'Array'.\n   *                            {string} number\n   *                              A string 'number' (default), 'BigNumber', or 'Fraction'\n   *                            {number} precision\n   *                              The number of significant digits for BigNumbers.\n   *                              Not applicable for Numbers.\n   *                            {string} parenthesis\n   *                              How to display parentheses in LaTeX and string\n   *                              output.\n   *                            {string} randomSeed\n   *                              Random seed for seeded pseudo random number generator.\n   *                              Set to null to randomly seed.\n   * @return {Object} Returns the current configuration\n   */\n  function _config(options) {\n    if (options) {\n      var prev = mapObject(config, clone); // validate some of the options\n\n      validateOption(options, 'matrix', MATRIX_OPTIONS);\n      validateOption(options, 'number', NUMBER_OPTIONS); // merge options\n\n      deepExtend(config, options);\n      var curr = mapObject(config, clone);\n      var changes = mapObject(options, clone); // emit 'config' event\n\n      emit('config', curr, prev, changes);\n      return curr;\n    } else {\n      return mapObject(config, clone);\n    }\n  } // attach the valid options to the function so they can be extended\n\n\n  _config.MATRIX_OPTIONS = MATRIX_OPTIONS;\n  _config.NUMBER_OPTIONS = NUMBER_OPTIONS; // attach the config properties as readonly properties to the config function\n\n  Object.keys(DEFAULT_CONFIG).forEach(function (key) {\n    Object.defineProperty(_config, key, {\n      get: function get() {\n        return config[key];\n      },\n      enumerable: true,\n      configurable: true\n    });\n  });\n  return _config;\n}\n/**\n * Test whether an Array contains a specific item.\n * @param {Array.<string>} array\n * @param {string} item\n * @return {boolean}\n */\n\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1;\n}\n/**\n * Find a string in an array. Case insensitive search\n * @param {Array.<string>} array\n * @param {string} item\n * @return {number} Returns the index when found. Returns -1 when not found\n */\n\n\nfunction findIndex(array, item) {\n  return array.map(function (i) {\n    return i.toLowerCase();\n  }).indexOf(item.toLowerCase());\n}\n/**\n * Validate an option\n * @param {Object} options         Object with options\n * @param {string} name            Name of the option to validate\n * @param {Array.<string>} values  Array with valid values for this option\n */\n\n\nfunction validateOption(options, name, values) {\n  if (options[name] !== undefined && !contains(values, options[name])) {\n    var index = findIndex(values, options[name]);\n\n    if (index !== -1) {\n      // right value, wrong casing\n      // TODO: lower case values are deprecated since v3, remove this warning some day.\n      console.warn('Warning: Wrong casing for configuration option \"' + name + '\", should be \"' + values[index] + '\" instead of \"' + options[name] + '\".');\n      options[name] = values[index]; // change the option to the right casing\n    } else {\n      // unknown value\n      console.warn('Warning: Unknown value \"' + options[name] + '\" for configuration option \"' + name + '\". Available options: ' + values.map(JSON.stringify).join(', ') + '.');\n    }\n  }\n}","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport './../utils/polyfills';\nimport { deepFlatten, isLegacyFactory, lazy, traverse, values } from './../utils/object';\nimport * as emitter from './../utils/emitter';\nimport { importFactory } from './function/import';\nimport { configFactory } from './function/config';\nimport { factory, isFactory } from '../utils/factory';\nimport { isAccessorNode, isArray, isArrayNode, isAssignmentNode, isBigNumber, isBlockNode, isBoolean, isChain, isCollection, isComplex, isConditionalNode, isConstantNode, isDate, isDenseMatrix, isFraction, isFunction, isFunctionAssignmentNode, isFunctionNode, isHelp, isIndex, isIndexNode, isMatrix, isNode, isNull, isNumber, isObject, isObjectNode, isOperatorNode, isParenthesisNode, isRange, isRangeNode, isRegExp, isResultSet, isSparseMatrix, isString, isSymbolNode, isUndefined, isUnit } from '../utils/is';\nimport { initial, last } from '../utils/array';\nimport { warnOnce } from '../utils/log';\nimport { ArgumentsError } from '../error/ArgumentsError';\nimport { DimensionError } from '../error/DimensionError';\nimport { IndexError } from '../error/IndexError';\nimport { DEFAULT_CONFIG } from './config';\n/**\n * Create a mathjs instance from given factory functions and optionally config\n *\n * Usage:\n *\n *     const mathjs1 = create({ createAdd, createMultiply, ...})\n *     const config = { number: 'BigNumber' }\n *     const mathjs2 = create(all, config)\n *\n * @param {Object} [factories] An object with factory functions\n *                             The object can contain nested objects,\n *                             all nested objects will be flattened.\n * @param {Object} [config]    Available options:\n *                            {number} epsilon\n *                              Minimum relative difference between two\n *                              compared values, used by all comparison functions.\n *                            {string} matrix\n *                              A string 'Matrix' (default) or 'Array'.\n *                            {string} number\n *                              A string 'number' (default), 'BigNumber', or 'Fraction'\n *                            {number} precision\n *                              The number of significant digits for BigNumbers.\n *                              Not applicable for Numbers.\n *                            {boolean} predictable\n *                              Predictable output type of functions. When true,\n *                              output type depends only on the input types. When\n *                              false (default), output type can vary depending\n *                              on input values. For example `math.sqrt(-4)`\n *                              returns `complex('2i')` when predictable is false, and\n *                              returns `NaN` when true.\n *                            {string} randomSeed\n *                              Random seed for seeded pseudo random number generator.\n *                              Set to null to randomly seed.\n * @returns {Object} Returns a bare-bone math.js instance containing\n *                   functions:\n *                   - `import` to add new functions\n *                   - `config` to change configuration\n *                   - `on`, `off`, `once`, `emit` for events\n */\n\nexport function create(factories, config) {\n  var configInternal = _extends({}, DEFAULT_CONFIG, config); // simple test for ES5 support\n\n\n  if (typeof Object.create !== 'function') {\n    throw new Error('ES5 not supported by this JavaScript engine. ' + 'Please load the es5-shim and es5-sham library for compatibility.');\n  } // create the mathjs instance\n\n\n  var math = emitter.mixin({\n    // only here for backward compatibility for legacy factory functions\n    isNumber: isNumber,\n    isComplex: isComplex,\n    isBigNumber: isBigNumber,\n    isFraction: isFraction,\n    isUnit: isUnit,\n    isString: isString,\n    isArray: isArray,\n    isMatrix: isMatrix,\n    isCollection: isCollection,\n    isDenseMatrix: isDenseMatrix,\n    isSparseMatrix: isSparseMatrix,\n    isRange: isRange,\n    isIndex: isIndex,\n    isBoolean: isBoolean,\n    isResultSet: isResultSet,\n    isHelp: isHelp,\n    isFunction: isFunction,\n    isDate: isDate,\n    isRegExp: isRegExp,\n    isObject: isObject,\n    isNull: isNull,\n    isUndefined: isUndefined,\n    isAccessorNode: isAccessorNode,\n    isArrayNode: isArrayNode,\n    isAssignmentNode: isAssignmentNode,\n    isBlockNode: isBlockNode,\n    isConditionalNode: isConditionalNode,\n    isConstantNode: isConstantNode,\n    isFunctionAssignmentNode: isFunctionAssignmentNode,\n    isFunctionNode: isFunctionNode,\n    isIndexNode: isIndexNode,\n    isNode: isNode,\n    isObjectNode: isObjectNode,\n    isOperatorNode: isOperatorNode,\n    isParenthesisNode: isParenthesisNode,\n    isRangeNode: isRangeNode,\n    isSymbolNode: isSymbolNode,\n    isChain: isChain\n  }); // load config function and apply provided config\n\n  math.config = configFactory(configInternal, math.emit);\n  math.expression = {\n    transform: {},\n    mathWithTransform: {\n      config: math.config\n    }\n  }; // cached factories and instances used by function load\n\n  var legacyFactories = [];\n  var legacyInstances = [];\n  /**\n   * Load a function or data type from a factory.\n   * If the function or data type already exists, the existing instance is\n   * returned.\n   * @param {Function} factory\n   * @returns {*}\n   */\n\n  function load(factory) {\n    if (isFactory(factory)) {\n      return factory(math);\n    }\n\n    var firstProperty = factory[Object.keys(factory)[0]];\n\n    if (isFactory(firstProperty)) {\n      return firstProperty(math);\n    }\n\n    if (!isLegacyFactory(factory)) {\n      console.warn('Factory object with properties `type`, `name`, and `factory` expected', factory);\n      throw new Error('Factory object with properties `type`, `name`, and `factory` expected');\n    }\n\n    var index = legacyFactories.indexOf(factory);\n    var instance;\n\n    if (index === -1) {\n      // doesn't yet exist\n      if (factory.math === true) {\n        // pass with math namespace\n        instance = factory.factory(math.type, configInternal, load, math.typed, math);\n      } else {\n        instance = factory.factory(math.type, configInternal, load, math.typed);\n      } // append to the cache\n\n\n      legacyFactories.push(factory);\n      legacyInstances.push(instance);\n    } else {\n      // already existing function, return the cached instance\n      instance = legacyInstances[index];\n    }\n\n    return instance;\n  }\n\n  var importedFactories = {}; // load the import function\n\n  function lazyTyped() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return math.typed.apply(math.typed, args);\n  }\n\n  var internalImport = importFactory(lazyTyped, load, math, importedFactories);\n  math[\"import\"] = internalImport; // listen for changes in config, import all functions again when changed\n  // TODO: move this listener into the import function?\n\n  math.on('config', function () {\n    values(importedFactories).forEach(function (factory) {\n      if (factory && factory.meta && factory.meta.recreateOnConfigChange) {\n        // FIXME: only re-create when the current instance is the same as was initially created\n        // FIXME: delete the functions/constants before importing them again?\n        internalImport(factory, {\n          override: true\n        });\n      }\n    });\n  }); // the create function exposed on the mathjs instance is bound to\n  // the factory functions passed before\n\n  math.create = create.bind(null, factories); // export factory function\n\n  math.factory = factory; // import the factory functions like createAdd as an array instead of object,\n  // else they will get a different naming (`createAdd` instead of `add`).\n\n  math[\"import\"](values(deepFlatten(factories))); // TODO: deprecated since v6.0.0. Clean up some day\n\n  var movedNames = ['type.isNumber', 'type.isComplex', 'type.isBigNumber', 'type.isFraction', 'type.isUnit', 'type.isString', 'type.isArray', 'type.isMatrix', 'type.isDenseMatrix', 'type.isSparseMatrix', 'type.isCollection', 'type.isRange', 'type.isIndex', 'type.isBoolean', 'type.isResultSet', 'type.isHelp', 'type.isFunction', 'type.isDate', 'type.isRegExp', 'type.isObject', 'type.isNull', 'type.isUndefined', 'type.isAccessorNode', 'type.isArrayNode', 'type.isAssignmentNode', 'type.isBlockNode', 'type.isConditionalNode', 'type.isConstantNode', 'type.isFunctionAssignmentNode', 'type.isFunctionNode', 'type.isIndexNode', 'type.isNode', 'type.isObjectNode', 'type.isOperatorNode', 'type.isParenthesisNode', 'type.isRangeNode', 'type.isSymbolNode', 'type.isChain', 'type.BigNumber', 'type.Chain', 'type.Complex', 'type.Fraction', 'type.Matrix', 'type.DenseMatrix', 'type.SparseMatrix', 'type.Spa', 'type.FibonacciHeap', 'type.ImmutableDenseMatrix', 'type.Index', 'type.Range', 'type.ResultSet', 'type.Unit', 'type.Help', 'type.Parser', 'expression.parse', 'expression.Parser', 'expression.node.AccessorNode', 'expression.node.ArrayNode', 'expression.node.AssignmentNode', 'expression.node.BlockNode', 'expression.node.ConditionalNode', 'expression.node.ConstantNode', 'expression.node.IndexNode', 'expression.node.FunctionAssignmentNode', 'expression.node.FunctionNode', 'expression.node.Node', 'expression.node.ObjectNode', 'expression.node.OperatorNode', 'expression.node.ParenthesisNode', 'expression.node.RangeNode', 'expression.node.RelationalNode', 'expression.node.SymbolNode', 'json.reviver', 'error.ArgumentsError', 'error.DimensionError', 'error.IndexError'];\n  movedNames.forEach(function (fullName) {\n    var parts = fullName.split('.');\n    var path = initial(parts);\n    var name = last(parts);\n    var obj = traverse(math, path);\n    lazy(obj, name, function () {\n      warnOnce(\"math.\".concat(fullName, \" is moved to math.\").concat(name, \" in v6.0.0. \") + 'Please use the new location instead.');\n      return math[name];\n    });\n  });\n  lazy(math.expression, 'docs', function () {\n    throw new Error('math.expression.docs has been moved. ' + 'Please import via \"import { docs } from \\'mathjs\\'\"');\n  });\n  math.ArgumentsError = ArgumentsError;\n  math.DimensionError = DimensionError;\n  math.IndexError = IndexError;\n  return math;\n}","import Emitter from 'tiny-emitter';\n/**\n * Extend given object with emitter functions `on`, `off`, `once`, `emit`\n * @param {Object} obj\n * @return {Object} obj\n */\n\nexport function mixin(obj) {\n  // create event emitter\n  var emitter = new Emitter(); // bind methods to obj (we don't want to expose the emitter.e Array...)\n\n  obj.on = emitter.on.bind(emitter);\n  obj.off = emitter.off.bind(emitter);\n  obj.once = emitter.once.bind(emitter);\n  obj.emit = emitter.emit.bind(emitter);\n  return obj;\n}","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { typedDependencies } from './dependenciesTyped.generated';\nimport { createIsNumeric } from '../../factoriesNumber.js';\nexport var isNumericDependencies = {\n  typedDependencies: typedDependencies,\n  createIsNumeric: createIsNumeric\n};","/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { isNaNDependencies } from './dependenciesIsNaN.generated';\nimport { isNumericDependencies } from './dependenciesIsNumeric.generated';\nimport { typedDependencies } from './dependenciesTyped.generated';\nimport { createMode } from '../../factoriesNumber.js';\nexport var modeDependencies = {\n  isNaNDependencies: isNaNDependencies,\n  isNumericDependencies: isNumericDependencies,\n  typedDependencies: typedDependencies,\n  createMode: createMode\n};"],"sourceRoot":""}
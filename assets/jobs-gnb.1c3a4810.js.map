{"version":3,"sources":["webpack:///./src/components/ui/RotationTable.tsx","webpack:///./src/parser/core/modules/Cooldowns.js","webpack:///./src/components/ui/TimeLineChart.js","webpack:///./src/parser/core/modules/Combos.tsx","webpack:///./src/parser/jobs/gnb/modules/Ammo.tsx","webpack:///./src/parser/jobs/gnb/modules/Combos.tsx","webpack:///./src/parser/jobs/gnb/modules/Continuation.tsx","webpack:///./src/parser/jobs/gnb/modules/Cooldowns.tsx","webpack:///./src/parser/jobs/gnb/modules/NoMercy.tsx","webpack:///./src/parser/jobs/gnb/modules/OGCDDowntime.tsx","webpack:///./src/parser/jobs/gnb/modules/index.tsx"],"names":["RotationTable","React","Component","render","targets","notes","data","onGoto","headerTitle","this","props","compact","unstackable","celled","Header","Row","HeaderCell","collapsing","id","map","target","i","key","textAlign","header","note","Body","entry","start","targetAccessorResolver","accessor","targetsData","actual","expected","notesAccessorResolver","notesMap","TargetCell","Cell","positive","undefined","negative","end","rotation","style","marginRight","formatDuration","circular","size","icon","onClick","targetEntry","events","noteEntry","Cooldowns","Module","constructor","super","_cooldownGroups","_currentAction","_cooldowns","_groups","actions","_buildGroups","cooldownOrder","addHook","by","_onBeginCast","_onCast","_onComplete","groups","order","length","action","getAction","_buildGroup","content","name","group","merge","forEach","nestedGroups","opts","ItemGroup","showNested","timeline","addGroup","event","ability","guid","cooldown","startCooldown","cooldownGroup","startCooldownGroup","finishingCast","Object","keys","actionId","_addToTimeline","parseInt","cd","current","history","push","onGcd","use","shared","addItem","Item","type","timestamp","parser","fight","start_time","src","alt","getCooldown","originActionId","filter","sharedCooldown","currentFightDuration","currentTimestamp","resetCooldown","invulnTime","reduceCooldown","reduction","setInvulnTime","previousEndTimestamp","previousCooldown","isFirst","downtime","getDowntime","getCooldownRemaining","getTimeOnCooldown","considerInvulnTime","extension","reduce","time","status","getAdjustedTimeOnCooldown","duration","maximumDuration","handle","dependencies","DEFAULT_OPTIONS","aspectRatio","scales","xAxes","displayFormats","minute","second","millisecond","tooltipFormat","TimeLineChart","PureComponent","options","width","height","DEFAULT_GCD","GCD_TIMEOUT_MILLIS","ISSUE_TYPENAMES","uncomboed","combobreak","failedcombo","Combos","arguments","lastGcdTime","currentComboChain","issues","init","onCast","onComplete","lastComboEvent","issue","fabricateComboEvent","combo","fabricateEvent","recordBrokenCombo","context","isAllowableComboBreak","recordUncomboedGcd","recordFailedCombo","checkCombo","lastAction","from","Array","isArray","includes","breaksCombo","successfulHit","addJobSpecificSuggestions","comboBreakers","uncomboedGcds","suggestions","add","TieredSuggestion","suggestionIcon","tiers","1","SEVERITY","MINOR","2","MEDIUM","4","MAJOR","value","why","output","startTime","sort","a","b","completeContext","startEvent","endEvent","startAction","endAction","reason","whiteSpace","show","title","displayOrder","DISPLAY_ORDER","COMBOS","__decorate","dependency","__metadata","Data","prototype","Suggestions","Timeline","ON_CAST_GENERATORS","ACTIONS","BLOODFEST","ON_COMBO_GENERATORS","SOLID_BARREL","DEMON_SLAUGHTER","AMMO_SPENDERS","GNASHING_FANG","BURST_STRIKE","FATED_CIRCLE","SINGLE_TARGET_CIRCLE_SEVERITY_TIERS","MAX_AMMO","Ammo","ammo","ammoHistory","wasteBySource","RAISE","leftoverAmmo","totalGeneratedAmmo","erroneousCircles","pushToHistory","abilityId","Number","onCastGenerator","onComboGenerator","onSpender","onFatedCircle","to","onDeath","hasOwnProperty","hits","generatedAmmo","addGeneratedAmmoAndPush","waste","dumpRemainingResources","t","y","totalWaste","source","sum","checklist","Rule","description","requirements","Requirement","convertWasteMapToTable","rows","convertWasteEntryToRow","actionName","margin","padding","cartridgeWastePanels","ammoColor","Color","JOBS","GUNBREAKER","colour","chartData","datasets","label","steppedLine","backgroundColor","fade","borderColor","yAxes","ticks","beginAtZero","min","max","callback","Accordion","exclusive","panels","styled","fluid","displayMode","DISPLAY_MODE","FULL","Checklist","CoreCombos","BRUTAL_SHELL","RELEVANT_ACTIONS","JUGULAR_RIP","ABDOMEN_TEAR","EYE_GOUGE","RELEVANT_STATUSES","STATUSES","READY_TO_RIP","READY_TO_TEAR","READY_TO_GOUGE","Continuation","buffs","CONTINUATION","CoreCooldowns","ROYAL_GUARD","NO_MERCY","DANGER_ZONE","BLASTING_ZONE","BOW_SHOCK","ROUGH_DIVIDE","SUPERBOLIDE","CAMOUFLAGE","NEBULA","RAMPART","HEART_OF_LIGHT","HEART_OF_STONE","AURORA","REPRISAL","PROVOKE","SHIRK","INTERJECT","LOW_BLOW","ARMS_LENGTH","SEVERITIES","MISSING_EXPECTED_USES","8","TOO_FEW_GCDS","EXPECTED_USES","SONIC_BREAK","GCD","NO_MERCY_BUFF_DURATION","NoMercyState","isRushing","numGcds","numBlastingZones","numSonicBreaks","numRoughDivides","numGnashingFangs","numBowShocks","NoMercy","noMercyWindows","onRemoveNoMercy","ATTACK","noMercyState","fightTimeRemaining","end_time","lastNoMercy","getDataBy","missedGcds","window","Math","sumMissingExpectedUses","showName","gcds","blastingZone","sonicBreak","roughDivide","bowShock","gnashingFang","FIRST_USE_OFFSET_NO_MERCY","FIRST_USE_OFFSET_BLOODFEST","AbilityDowntime","CooldownDowntime","firstUseOffsetPerOgcd","trackedCds","cooldowns","firstUseOffset","OGCDDowntime"],"mappings":"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","file":"assets/jobs-gnb.1c3a4810.js","sourcesContent":["import { Trans } from '@lingui/react';\nimport Rotation from 'components/ui/Rotation';\nimport React from 'react';\nimport { Button, Table } from 'semantic-ui-react';\nimport { formatDuration } from 'utilities';\nexport class RotationTable extends React.Component {\n    render() {\n        const { targets, notes, data, onGoto, headerTitle, } = this.props;\n        return <Table compact unstackable celled>\n\t\t\t<Table.Header>\n\t\t\t\t<Table.Row>\n\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t<strong><Trans id=\"core.ui.rotation-table.header.time\">Time</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(targets || []).map((target, i) => <Table.HeaderCell key={`target_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{target.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t\t<Table.HeaderCell>\n\t\t\t\t\t\t<strong>{(headerTitle) ? headerTitle : <Trans id=\"core.ui.rotation-table.header.rotation\">Rotation</Trans>}</strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{(notes || []).map((note, i) => <Table.HeaderCell key={`note_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{note.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>)}\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Header>\n\t\t\t<Table.Body>\n\t\t\t\t{data.map((entry) => <RotationTable.Row key={entry.start} onGoto={onGoto} targets={targets || []} notes={notes || []} {...entry}/>)}\n\t\t\t</Table.Body>\n\t\t</Table>;\n    }\n}\nRotationTable.targetAccessorResolver = (entry, target) => {\n    if (typeof target.accessor === 'string' && entry.targetsData != null) {\n        return entry.targetsData[target.accessor];\n    }\n    else if (typeof target.accessor === 'function') {\n        return target.accessor(entry);\n    }\n    else {\n        return {\n            actual: 0,\n            expected: 0,\n        };\n    }\n};\nRotationTable.notesAccessorResolver = (entry, note) => {\n    if (typeof note.accessor === 'string' && entry.notesMap != null) {\n        return entry.notesMap[note.accessor];\n    }\n    else if (typeof note.accessor === 'function') {\n        return note.accessor(entry);\n    }\n    else {\n        return null;\n    }\n};\nRotationTable.TargetCell = ({ actual, expected }) => <Table.Cell textAlign=\"center\" positive={expected === undefined ? false : actual >= expected} negative={expected === undefined ? false : actual < expected}>\n\t\t\t{actual}/{expected === undefined ? '-' : expected}\n\t\t</Table.Cell>;\nRotationTable.Row = ({ onGoto, targets, notes, notesMap, start, end, targetsData, rotation }) => <Table.Row>\n\t\t\t<Table.Cell textAlign=\"center\">\n\t\t\t\t<span style={{ marginRight: 5 }}>{formatDuration(start / 1000)}</span>\n\t\t\t\t{typeof onGoto === 'function' && <Button circular compact size=\"mini\" icon=\"time\" onClick={() => onGoto(start, end)}/>}\n\t\t\t</Table.Cell>\n\t\t\t{targets\n    .map(target => RotationTable.targetAccessorResolver({ start, end, targetsData, rotation }, target))\n    .map((targetEntry, i) => <RotationTable.TargetCell key={`target_${i}`} {...targetEntry}/>)}\n\t\t\t<Table.Cell>\n\t\t\t\t<Rotation events={rotation}/>\n\t\t\t</Table.Cell>\n\t\t\t{notes\n    .map(note => RotationTable.notesAccessorResolver({ start, end, targetsData, notesMap, rotation }, note))\n    .map((noteEntry, i) => <Table.Cell key={`notes_${i}`} textAlign=\"center\">\n\t\t\t\t\t\t\t{noteEntry}\n\t\t\t\t\t\t</Table.Cell>)}\n\t\t</Table.Row>;\n","import _ from 'lodash';\nimport Module from 'parser/core/Module';\nimport { ItemGroup, Item } from './Timeline';\nimport React from 'react';\n// Track the cooldowns on actions and shit\nexport default class Cooldowns extends Module {\n    constructor(...args) {\n        super(...args);\n        this._cooldownGroups = {};\n        this._currentAction = null;\n        this._cooldowns = {};\n        this._groups = {};\n        this._cooldownGroups = _.groupBy(this.data.actions, 'cooldownGroup');\n        // Pre-build groups for actions explicitly set by subclasses\n        this._buildGroups(this.constructor.cooldownOrder);\n        this.addHook('begincast', { by: 'player' }, this._onBeginCast);\n        this.addHook('cast', { by: 'player' }, this._onCast);\n        this.addHook('complete', this._onComplete);\n    }\n    _buildGroups(groups) {\n        // If there's no groups, noop\n        if (!groups) {\n            return;\n        }\n        const ids = groups.map((data, i) => {\n            const order = -(groups.length - i);\n            // If it's just an action id, build a group for it and stop\n            if (typeof data === 'number') {\n                const action = this.data.getAction(data);\n                this._buildGroup({\n                    id: data,\n                    content: action && action.name,\n                    order,\n                });\n                return data;\n            }\n            // Build the base group\n            const group = this._buildGroup({\n                id: data.name,\n                content: data.name,\n                order,\n            });\n            if (data.merge) {\n                // If it's a merge group, we only need to register our group for each of the IDs\n                data.actions.forEach(id => {\n                    this._groups[id] = group;\n                });\n            }\n            else {\n                // Otherwise, build nested groups for each action\n                group.nestedGroups = this._buildGroups(data.actions);\n            }\n            return data.name;\n        });\n        return ids;\n    }\n    _buildGroup(opts) {\n        const group = new ItemGroup({ showNested: false, ...opts });\n        this.timeline.addGroup(group);\n        this._groups[opts.id] = group;\n        return group;\n    }\n    // cooldown starts at the beginning of the casttime\n    // (though 99% of CD based abilities have no cast time)\n    // TODO: Should I be tracking pet CDs too? I mean, contagion/radiant are a thing.\n    _onBeginCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.cooldown == null) {\n            return;\n        }\n        this._currentAction = action;\n        this.startCooldown(action.id);\n        if (!_.isNil(action.cooldownGroup)) {\n            this.startCooldownGroup(action.id, action.cooldownGroup);\n        }\n    }\n    _onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action || action.cooldown == null) {\n            return;\n        }\n        const finishingCast = this._currentAction && this._currentAction.id === action.id;\n        this._currentAction = null;\n        if (finishingCast) {\n            return;\n        }\n        this.startCooldown(action.id);\n        if (!_.isNil(action.cooldownGroup)) {\n            this.startCooldownGroup(action.id, action.cooldownGroup);\n        }\n    }\n    _onComplete() {\n        Object.keys(this._cooldowns).forEach(actionId => {\n            this._addToTimeline(parseInt(actionId, 10));\n        });\n    }\n    _addToTimeline(actionId) {\n        const cd = this._cooldowns[actionId];\n        if (!cd) {\n            return false;\n        }\n        // Clean out any 'current' cooldowns into the history\n        if (cd.current) {\n            cd.history.push(cd.current);\n            cd.current = null;\n        }\n        const action = this.data.getAction(actionId);\n        // If the action is on the GCD, GlobalCooldown will be managing its own group\n        if (!action || action.onGcd) {\n            return false;\n        }\n        // Ensure we've got a group for this item\n        if (!this._groups[actionId]) {\n            this._buildGroup({\n                id: actionId,\n                content: action.name,\n                order: actionId,\n            });\n        }\n        // Add CD info to the timeline\n        cd.history\n            .forEach(use => {\n            if (!use.shared) {\n                this._groups[actionId].addItem(new Item({\n                    type: 'background',\n                    start: use.timestamp - this.parser.fight.start_time,\n                    length: use.length,\n                    content: <img src={action.icon} alt={action.name}/>,\n                }));\n            }\n        });\n        return true;\n    }\n    getCooldown(actionId) {\n        return this._cooldowns[actionId] || {\n            current: null,\n            history: [],\n        };\n    }\n    startCooldownGroup(originActionId, cooldownGroup) {\n        const sharedCooldownActions = _.get(this._cooldownGroups, cooldownGroup, []);\n        sharedCooldownActions\n            .map(action => action.id)\n            .filter(id => id !== originActionId)\n            .forEach(id => this.startCooldown(id, true));\n    }\n    startCooldown(actionId, sharedCooldown = false) {\n        // TODO: handle shared CDs\n        const action = this.data.getAction(actionId);\n        if (!action) {\n            return;\n        }\n        // Get the current cooldown status, falling back to a new cooldown\n        const cd = this.getCooldown(actionId);\n        // If there's a current object, move it into the history\n        // TODO: handle errors on CD overlap\n        if (cd.current) {\n            const currentFightDuration = this.parser.currentTimestamp - this.parser.fight.start_time;\n            if (cd.current.timestamp < this.parser.fight.start_time && cd.current.length > currentFightDuration) {\n                // Pre-pull usage, reset the cooldown to prevent overlap on timeline since we don't know exactly when cooldown was used pre-pull\n                this.resetCooldown(actionId);\n            }\n            else {\n                cd.history.push(cd.current);\n            }\n        }\n        cd.current = {\n            timestamp: this.parser.currentTimestamp,\n            length: action.cooldown * 1000,\n            shared: sharedCooldown,\n            invulnTime: 0,\n        };\n        // Save the info back out (to ensure propagation if we've got a new info)\n        this._cooldowns[actionId] = cd;\n    }\n    reduceCooldown(actionId, reduction) {\n        const cd = this.getCooldown(actionId);\n        const currentTimestamp = this.parser.currentTimestamp;\n        // Check if current isn't current\n        if (cd.current && cd.current.timestamp + cd.current.length < currentTimestamp) {\n            cd.history.push(cd.current);\n            cd.current = null;\n        }\n        // TODO: Do I need to warn if they're reducing cooldown on something _with_ no cooldown?\n        if (cd.current === null) {\n            return;\n        }\n        // Reduce the CD\n        cd.current.length -= reduction * 1000;\n        // If the reduction would have made it come off CD earlier than now, reset it - the extra time reduction should be lost.\n        if (cd.current.timestamp + cd.current.length < currentTimestamp) {\n            this.resetCooldown(actionId);\n        }\n    }\n    setInvulnTime(actionId) {\n        const cd = this.getCooldown(actionId);\n        let previousEndTimestamp = this.parser.fight.start_time;\n        let previousCooldown = {};\n        let isFirst = true;\n        for (const cooldown of cd.history) {\n            if (isFirst) {\n                previousEndTimestamp = (cooldown.timestamp + cooldown.length);\n                isFirst = false;\n                previousCooldown = cooldown;\n            }\n            //We invuln time is the time the boss was invuln from when the CD came off CD and when it was next executed\n            previousCooldown.invulnTime = this.downtime.getDowntime(previousEndTimestamp, cooldown.timestamp);\n            previousEndTimestamp = (cooldown.timestamp + cooldown.length);\n            previousCooldown = cooldown;\n        }\n    }\n    resetCooldown(actionId) {\n        const cd = this.getCooldown(actionId);\n        // If there's nothing running, we can just stop\n        // TODO: need to warn?\n        if (cd.current === null) {\n            return;\n        }\n        // Fix up the length\n        cd.current.length = this.parser.currentTimestamp - cd.current.timestamp;\n        // Move the CD into the history\n        cd.history.push(cd.current);\n        cd.current = null;\n    }\n    getCooldownRemaining(actionId) {\n        const current = this.getCooldown(actionId).current;\n        if (!current) {\n            return 0;\n        }\n        return current.length - (this.parser.currentTimestamp - current.timestamp);\n    }\n    // TODO: Should this be here?\n    getTimeOnCooldown(actionId, considerInvulnTime = false, extension = 0) {\n        const cd = this.getCooldown(actionId);\n        const currentTimestamp = this.parser.currentTimestamp;\n        if (considerInvulnTime) {\n            this.setInvulnTime(actionId);\n        }\n        else {\n            cd.history.map(cooldown => {\n                cooldown.invulnTime = 0;\n            });\n        }\n        return cd.history.reduce((time, status) => time + this.getAdjustedTimeOnCooldown(status, currentTimestamp, extension), cd.current ? this.getAdjustedTimeOnCooldown(cd.current, currentTimestamp, extension) : 0);\n    }\n    getAdjustedTimeOnCooldown(cooldown, currentTimestamp, extension) {\n        // Doesn't count time on CD outside the bounds of the current fight, it'll throw calcs off\n        // Add to the length of the cooldown any invuln time for the boss\n        // Additionally account for any extension the caller allowed to the CD Length\n        const duration = currentTimestamp - cooldown.timestamp;\n        const maximumDuration = cooldown.length + cooldown.invulnTime + extension;\n        return _.clamp(duration, 0, maximumDuration);\n    }\n    get used() {\n        return Object.keys(this._cooldowns);\n    }\n}\nCooldowns.handle = 'cooldowns';\nCooldowns.dependencies = [\n    'data',\n    'downtime',\n    'timeline',\n];\n// Array used to sort cooldowns in the timeline. Elements should be either IDs for\n// top-level groups, or objects of the format {name: string, actions: array} for\n// nested groups. Actions not specified here will be sorted by their ID below.\n// Check the NIN and SMN modules for examples.\nCooldowns.cooldownOrder = [];\n","import _ from 'lodash';\nimport PropTypes from 'prop-types';\nimport React, { PureComponent } from 'react';\nimport { Line } from 'react-chartjs-2';\nconst DEFAULT_OPTIONS = {\n    aspectRatio: 3,\n    scales: {\n        xAxes: [{\n                type: 'time',\n                time: {\n                    displayFormats: {\n                        minute: 'm:ss',\n                        second: 'm:ss',\n                        millisecond: 'm:ss.SS',\n                    },\n                    // This tooltip format displays similar to a \"relative\" timestamp,\n                    // since react assumes UNIX epoch timestamps for the data.\n                    tooltipFormat: 'mm:ss.SSS',\n                },\n            }],\n    },\n};\nexport default class TimeLineChart extends PureComponent {\n    render() {\n        const options = _.merge({}, DEFAULT_OPTIONS, this.props.options || {});\n        return <Line data={this.props.data} options={options} \n        // Using this trash 'cus aspectRatio doesn't work with the react wrapper\n        width={options.aspectRatio} height={1}/>;\n    }\n}\nTimeLineChart.propTypes = {\n    data: PropTypes.object.isRequired,\n    options: PropTypes.object,\n};\n","// If you can make it through this entire file without hitting semantic saturation of the word \"combo\", hats off to you. IT DOESN'T LOOK REAL ANYMORE.\nimport { __decorate, __metadata } from \"tslib\";\nimport { t } from '@lingui/macro';\nimport { Plural, Trans } from '@lingui/react';\nimport { RotationTable } from 'components/ui/RotationTable';\nimport _ from 'lodash';\nimport Module, { dependency } from 'parser/core/Module';\nimport DISPLAY_ORDER from 'parser/core/modules/DISPLAY_ORDER';\nimport Suggestions, { SEVERITY, TieredSuggestion } from 'parser/core/modules/Suggestions';\nimport Timeline from 'parser/core/modules/Timeline';\nimport React from 'react';\nimport { Data } from './Data';\nconst DEFAULT_GCD = 2.5;\nconst GCD_TIMEOUT_MILLIS = 15000;\nconst ISSUE_TYPENAMES = {\n    uncomboed: <Trans id=\"core.combos.issuetypenames.uncomboed\">Uncomboed</Trans>,\n    combobreak: <Trans id=\"core.combos.issuetypenames.combobreak\">Broken Combo</Trans>,\n    failedcombo: <Trans id=\"core.combos.issuetypenames.failed\">Missed or Invulnerable</Trans>,\n};\nexport default class Combos extends Module {\n    constructor() {\n        super(...arguments);\n        this.lastGcdTime = this.parser.fight.start_time;\n        this.currentComboChain = [];\n        this.issues = [];\n    }\n    init() {\n        this.addHook('aoedamage', { by: 'player' }, this.onCast);\n        this.addHook('complete', this.onComplete);\n    }\n    get lastComboEvent() {\n        return _.last(this.currentComboChain) || null;\n    }\n    get lastAction() {\n        const lastComboEvent = this.lastComboEvent;\n        if (!lastComboEvent) {\n            return null;\n        }\n        return lastComboEvent.ability.guid;\n    }\n    get comboBreakers() {\n        return this.issues\n            .filter(issue => issue.type === 'combobreak')\n            .map(issue => issue.event);\n    }\n    get uncomboedGcds() {\n        return this.issues\n            .filter(issue => issue.type === 'uncomboed')\n            .map(issue => issue.event);\n    }\n    fabricateComboEvent(event) {\n        const combo = {\n            ...event,\n            type: 'combo',\n        };\n        delete combo.timestamp; // Since fabricateEvent adds that in anyway\n        this.parser.fabricateEvent(combo);\n    }\n    recordBrokenCombo(event, context) {\n        if (!this.isAllowableComboBreak(event, context)) {\n            this.issues.push({\n                type: 'combobreak',\n                event,\n                context,\n            });\n        }\n        this.currentComboChain = [];\n    }\n    recordUncomboedGcd(event) {\n        this.issues.push({\n            type: 'uncomboed',\n            event,\n            context: [],\n        });\n        this.currentComboChain = [];\n    }\n    recordFailedCombo(event, context) {\n        this.issues.push({\n            type: 'failedcombo',\n            event,\n            context,\n        });\n        this.currentComboChain = [];\n    }\n    /**\n     *\n     * @param combo\n     * @param event\n     * @return true if combo, false otherwise\n     */\n    checkCombo(combo /* Should be an Action type */, event) {\n        // Not in a combo\n        if (this.lastAction == null) {\n            // Combo starter, we good\n            if (combo.start) {\n                this.fabricateComboEvent(event);\n                return true;\n            }\n            // Combo action that isn't a starter, that's a paddlin'\n            if (combo.from) {\n                this.recordUncomboedGcd(event);\n                return false;\n            }\n        }\n        if (combo.start) {\n            // Broken combo - starting a new combo while in a current combo\n            this.recordBrokenCombo(event, this.currentComboChain);\n            return true; // Start a new combo\n        }\n        // Check if action continues existing combo\n        if (combo.from) {\n            const fromOptions = Array.isArray(combo.from) ? combo.from : [combo.from];\n            if (fromOptions.includes(this.lastAction)) {\n                // Combo continued correctly\n                this.fabricateComboEvent(event);\n                // If it's a finisher, reset the combo\n                return !combo.end;\n            }\n        }\n        // Action did not continue combo correctly and is not a new combo starter\n        this.recordBrokenCombo(event, this.currentComboChain);\n        return false;\n    }\n    onCast(event) {\n        const action = this.data.getAction(event.ability.guid);\n        if (!action) {\n            return;\n        }\n        // Only track GCDs that either progress or break combos so actions like Drill and Shadow Fang don't falsely extend the simulated combo timer\n        if (action.onGcd && (action.combo || action.breaksCombo)) {\n            if (event.timestamp - this.lastGcdTime > GCD_TIMEOUT_MILLIS) {\n                // If we've had enough downtime between GCDs to let the combo expire, reset the state so we don't count erroneous combo breaks\n                this.currentComboChain = [];\n            }\n            this.lastGcdTime = event.timestamp;\n        }\n        // If it's a combo action, run it through the combo checking logic\n        if (action.combo) {\n            if (!event.successfulHit) {\n                // Failed attacks break combo\n                this.recordFailedCombo(event, this.currentComboChain);\n                return;\n            }\n            const continueCombo = this.checkCombo(action.combo, event);\n            if (continueCombo) {\n                this.currentComboChain.push(event);\n            }\n            else {\n                this.currentComboChain = [];\n            }\n        }\n        if (action.breaksCombo && this.lastAction !== null) {\n            // Combo breaking action, that's a paddlin'\n            this.recordBrokenCombo(event, this.currentComboChain);\n        }\n    }\n    onComplete() {\n        if (this.addJobSpecificSuggestions(this.comboBreakers, this.uncomboedGcds)) {\n            return;\n        }\n        this.suggestions.add(new TieredSuggestion({\n            icon: this.constructor.suggestionIcon,\n            content: <Trans id=\"core.combos.content\">\n\t\t\t\t<p>Avoid breaking combos, as failing to complete combos costs you a significant amount of DPS and important secondary effects.</p>\n\t\t\t\t<p>Using a combo GCD at the wrong combo step, using non-combo GCDs while inside a combo, missing, or attacking a target that is invulnerable will cause your combo to break.</p>\n\t\t\t</Trans>,\n            tiers: {\n                1: SEVERITY.MINOR,\n                2: SEVERITY.MEDIUM,\n                4: SEVERITY.MAJOR,\n            },\n            value: this.issues.length,\n            why: <Plural id=\"core.combos.why\" value={this.issues.length} one=\"You misused # combo action.\" other=\"You misused # combo actions.\"/>,\n        }));\n    }\n    /**\n     * To be overridden by subclasses. This is called in _onComplete() and passed two arrays of event objects - one for events that\n     * broke combos, and one for combo GCDs used outside of combos. Subclassing modules can add job-specific suggestions based on\n     * what particular actions were misused and when in the fight.\n     * The overriding module should return true if the default suggestion is not wanted\n     */\n    addJobSpecificSuggestions(comboBreakers, uncomboedGcds) {\n        return false;\n    }\n    /**\n     * To be overridden by subclasses. This is called in recordBrokenCombo, and receives the event triggering the broken combo,\n     * and the context information for that break. Jobs can override this to indicate whether this broken combo is allowed. If so,\n     * the event and context will not be recorded, and the current combo will be cleared with no other side effects.\n     * Returning false will allow the break to be recorded, and displayed to the user\n     */\n    isAllowableComboBreak(event, context) {\n        return false;\n    }\n    output() {\n        if (this.issues.length <= 0) {\n            return false;\n        }\n        // Access Alias\n        const startTime = this.parser.fight.start_time;\n        const data = this.issues\n            .sort((a, b) => a.event.timestamp - b.event.timestamp)\n            .map(issue => {\n            const completeContext = [...(issue.context || []), issue.event];\n            const startEvent = _.first(completeContext);\n            const endEvent = _.last(completeContext);\n            const startAction = this.data.getAction(startEvent.ability.guid);\n            const endAction = this.data.getAction(endEvent.ability.guid);\n            return ({\n                start: startEvent.timestamp - startTime + (startAction?.cooldown ?? DEFAULT_GCD),\n                end: endEvent.timestamp - startTime + (endAction?.cooldown ?? DEFAULT_GCD),\n                rotation: completeContext,\n                notesMap: {\n                    reason: <span style={{ whiteSpace: 'nowrap' }}>{ISSUE_TYPENAMES[issue.type]}</span>,\n                },\n            });\n        });\n        return <RotationTable notes={[\n            {\n                header: <Trans id=\"core.combos.rotationtable.header.reason\">Reason</Trans>,\n                accessor: 'reason',\n            },\n        ]} data={data} onGoto={this.timeline.show}/>;\n    }\n}\nCombos.handle = 'combos';\nCombos.title = t('core.combos.title') `Combo Issues`;\nCombos.displayOrder = DISPLAY_ORDER.COMBOS;\n// This should be redefined by subclassing modules; the default is the basic 'Attack' icon\nCombos.suggestionIcon = 'https://xivapi.com/i/000000/000405.png';\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Data)\n], Combos.prototype, \"data\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Suggestions)\n], Combos.prototype, \"suggestions\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Timeline)\n], Combos.prototype, \"timeline\", void 0);\n","import { __decorate, __metadata } from \"tslib\";\nimport { t } from '@lingui/macro';\nimport { Plural, Trans } from '@lingui/react';\nimport Color from 'color';\nimport React, { Fragment } from 'react';\nimport { Accordion } from 'semantic-ui-react';\nimport { ActionLink } from 'components/ui/DbLink';\nimport TimeLineChart from 'components/ui/TimeLineChart';\nimport ACTIONS from 'data/ACTIONS';\nimport JOBS from 'data/JOBS';\nimport Module, { dependency, DISPLAY_MODE } from 'parser/core/Module';\nimport Checklist, { Requirement, Rule } from 'parser/core/modules/Checklist';\nimport Suggestions, { SEVERITY, TieredSuggestion } from 'parser/core/modules/Suggestions';\nconst ON_CAST_GENERATORS = {\n    [ACTIONS.BLOODFEST.id]: 2,\n};\nconst ON_COMBO_GENERATORS = {\n    [ACTIONS.SOLID_BARREL.id]: 1,\n    [ACTIONS.DEMON_SLAUGHTER.id]: 1,\n};\nconst AMMO_SPENDERS = {\n    [ACTIONS.GNASHING_FANG.id]: 1,\n    [ACTIONS.BURST_STRIKE.id]: 1,\n    [ACTIONS.FATED_CIRCLE.id]: 1,\n};\nconst SINGLE_TARGET_CIRCLE_SEVERITY_TIERS = {\n    1: SEVERITY.MINOR,\n    2: SEVERITY.MEDIUM,\n    4: SEVERITY.MAJOR,\n};\nconst MAX_AMMO = 2;\nclass AmmoState {\n}\nexport default class Ammo extends Module {\n    constructor() {\n        super(...arguments);\n        this.ammo = 0;\n        this.ammoHistory = [];\n        this.wasteBySource = {\n            [ACTIONS.SOLID_BARREL.id]: 0,\n            [ACTIONS.DEMON_SLAUGHTER.id]: 0,\n            [ACTIONS.BLOODFEST.id]: 0,\n            [ACTIONS.RAISE.id]: 0,\n        };\n        this.leftoverAmmo = 0;\n        this.totalGeneratedAmmo = 0; // Keep track of the total amount of generated ammo over the fight\n        this.erroneousCircles = 0; // This is my new NEW band name.\n    }\n    init() {\n        this.addHook('init', this.pushToHistory);\n        this.addHook('cast', {\n            by: 'player',\n            abilityId: Object.keys(ON_CAST_GENERATORS).map(Number),\n        }, this.onCastGenerator);\n        this.addHook('combo', {\n            by: 'player',\n            abilityId: Object.keys(ON_COMBO_GENERATORS).map(Number),\n        }, this.onComboGenerator);\n        this.addHook('cast', {\n            by: 'player',\n            abilityId: Object.keys(AMMO_SPENDERS).map(Number),\n        }, this.onSpender);\n        this.addHook('aoedamage', { by: 'player', abilityId: ACTIONS.FATED_CIRCLE.id }, this.onFatedCircle);\n        this.addHook('death', { to: 'player' }, this.onDeath);\n        this.addHook('complete', this.onComplete);\n    }\n    onFatedCircle(event) {\n        if (event.hasOwnProperty('hits') &&\n            event.hits.length < 2) {\n            this.erroneousCircles++;\n        }\n    }\n    onCastGenerator(event) {\n        const abilityId = event.ability.guid;\n        const generatedAmmo = ON_CAST_GENERATORS[abilityId];\n        this.addGeneratedAmmoAndPush(generatedAmmo, abilityId);\n    }\n    onComboGenerator(event) {\n        const abilityId = event.ability.guid;\n        const generatedAmmo = ON_COMBO_GENERATORS[abilityId];\n        this.addGeneratedAmmoAndPush(generatedAmmo, abilityId);\n    }\n    addGeneratedAmmoAndPush(generatedAmmo, abilityId) {\n        this.ammo += generatedAmmo;\n        this.totalGeneratedAmmo += generatedAmmo;\n        if (this.ammo > MAX_AMMO) {\n            const waste = this.ammo - MAX_AMMO;\n            this.wasteBySource[abilityId] += waste;\n            this.ammo = MAX_AMMO;\n        }\n        this.pushToHistory();\n    }\n    onSpender(event) {\n        this.ammo = this.ammo - AMMO_SPENDERS[event.ability.guid];\n        this.pushToHistory();\n    }\n    onDeath() {\n        this.wasteBySource[ACTIONS.RAISE.id] += this.ammo;\n        this.dumpRemainingResources();\n    }\n    dumpRemainingResources() {\n        this.leftoverAmmo = this.ammo;\n        this.ammo = 0;\n        this.pushToHistory();\n    }\n    pushToHistory() {\n        const timestamp = this.parser.currentTimestamp - this.parser.fight.start_time;\n        this.ammoHistory.push({ t: timestamp, y: this.ammo });\n    }\n    onComplete() {\n        this.dumpRemainingResources();\n        const totalWaste = Object.keys(this.wasteBySource)\n            .map(Number)\n            .filter(source => source !== ACTIONS.RAISE.id) // don't include death for suggestions\n            .reduce((sum, source) => sum + this.wasteBySource[source], 0)\n            + this.leftoverAmmo;\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.FATED_CIRCLE.icon,\n            content: <Trans id=\"gnb.ammo.single-target-circle.content\">\n\t\t\t\tAvoid using <ActionLink {...ACTIONS.FATED_CIRCLE}/> when it would deal damage to only a single target.\n\t\t\t</Trans>,\n            why: <Trans id=\"gnb.ammo.single-target-circle.why\">\n\t\t\t\t<Plural value={this.erroneousCircles} one=\"# use\" other=\"# uses\"/> of <ActionLink {...ACTIONS.FATED_CIRCLE}/> dealt\n\t\t\t\tdamage to only one target.\n\t\t\t</Trans>,\n            tiers: SINGLE_TARGET_CIRCLE_SEVERITY_TIERS,\n            value: this.erroneousCircles,\n        }));\n        this.checklist.add(new Rule({\n            name: 'Cartridge Usage',\n            description: <Trans id=\"gnb.ammo.waste.content\">\n\t\t\t\tWasted cartridge generation, ending the fight with cartridges loaded, or dying with cartridges loaded is a\n\t\t\t\tdirect potency loss. Use <ActionLink {...ACTIONS.BURST_STRIKE}/> (or <ActionLink {...ACTIONS.FATED_CIRCLE}/> if\n\t\t\t\tthere is more than one target) to avoid wasting cartridges.\n\t\t\t</Trans>,\n            requirements: [\n                new Requirement({\n                    name: <Trans id=\"gnb.ammo.checklist.requirement.waste.name\">\n\t\t\t\t\t\tUse as many of your loaded cartridges as possible.\n\t\t\t\t\t</Trans>,\n                    value: this.totalGeneratedAmmo - totalWaste,\n                    target: this.totalGeneratedAmmo,\n                }),\n            ],\n        }));\n    }\n    convertWasteMapToTable() {\n        const rows = [\n            this.convertWasteEntryToRow(ACTIONS.SOLID_BARREL),\n            this.convertWasteEntryToRow(ACTIONS.DEMON_SLAUGHTER),\n            this.convertWasteEntryToRow(ACTIONS.BLOODFEST),\n            this.convertWasteEntryToRow(ACTIONS.RAISE),\n        ];\n        return <Fragment key=\"wasteBySource-fragment\">\n\t\t\t<table key=\"wasteBySource-table\">\n\t\t\t\t<tbody key=\"wasteBySource-tbody\">\n\t\t\t\t\t{rows}\n\t\t\t\t</tbody>\n\t\t\t</table>\n\t\t</Fragment>;\n    }\n    convertWasteEntryToRow(action) {\n        let actionName = action.name;\n        if (action === ACTIONS.RAISE) {\n            actionName = 'Death';\n        }\n        return <tr key={action.id + '-row'} style={{ margin: 0, padding: 0 }}>\n\t\t\t<td key={action.id + '-name'}><ActionLink name={actionName} {...action}/></td>\n\t\t\t<td key={action.id + '-value'}>{this.wasteBySource[action.id]}</td>\n\t\t</tr>;\n    }\n    output() {\n        const cartridgeWastePanels = [];\n        cartridgeWastePanels.push({\n            key: 'key-wastebysource',\n            title: {\n                key: 'title-wastebysource',\n                content: <Trans id=\"gnb.ammo.waste.by-source.key\">Cartridge Waste By Source</Trans>,\n            },\n            content: {\n                key: 'content-wastebysource',\n                content: this.convertWasteMapToTable(),\n            },\n        });\n        const ammoColor = Color(JOBS.GUNBREAKER.colour);\n        /* tslint:disable:no-magic-numbers */\n        const chartData = {\n            datasets: [\n                {\n                    label: 'Cartridges',\n                    steppedLine: true,\n                    data: this.ammoHistory,\n                    backgroundColor: ammoColor.fade(0.8),\n                    borderColor: ammoColor.fade(0.5),\n                },\n            ],\n        };\n        const chartOptions = {\n            scales: {\n                yAxes: [{\n                        ticks: {\n                            beginAtZero: true,\n                            min: 0,\n                            max: 2,\n                            callback: ((value) => {\n                                if (value % 1 === 0) {\n                                    return value;\n                                }\n                            }),\n                        },\n                    }],\n            },\n        };\n        /* tslint:enable:no-magic-numbers */\n        return <Fragment>\n\t\t\t<TimeLineChart data={chartData} options={chartOptions}/>\n\t\t\t<Accordion exclusive={false} panels={cartridgeWastePanels} styled fluid/>\n\t\t</Fragment>;\n    }\n}\nAmmo.handle = 'ammo';\nAmmo.title = t('gnb.ammo.title') `Cartridge Timeline`;\nAmmo.displayMode = DISPLAY_MODE.FULL;\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Checklist)\n], Ammo.prototype, \"checklist\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Suggestions)\n], Ammo.prototype, \"suggestions\", void 0);\n","import ACTIONS from 'data/ACTIONS';\nimport CoreCombos from 'parser/core/modules/Combos';\nexport default class Combos extends CoreCombos {\n}\n// Overrides\nCombos.suggestionIcon = ACTIONS.BRUTAL_SHELL.icon;\n","import { __decorate, __metadata } from \"tslib\";\nimport { Trans } from '@lingui/react';\nimport React from 'react';\nimport { ActionLink } from 'components/ui/DbLink';\nimport ACTIONS from 'data/ACTIONS';\nimport STATUSES from 'data/STATUSES';\nimport Module, { dependency } from 'parser/core/Module';\nimport Checklist, { Requirement, Rule } from 'parser/core/modules/Checklist';\nconst RELEVANT_ACTIONS = [ACTIONS.JUGULAR_RIP.id, ACTIONS.ABDOMEN_TEAR.id, ACTIONS.EYE_GOUGE.id];\nconst RELEVANT_STATUSES = [STATUSES.READY_TO_RIP.id, STATUSES.READY_TO_TEAR.id, STATUSES.READY_TO_GOUGE.id];\nexport default class Continuation extends Module {\n    constructor() {\n        super(...arguments);\n        this.buffs = 0;\n        this.actions = 0;\n    }\n    init() {\n        this.addHook('cast', {\n            by: 'player',\n            abilityId: RELEVANT_ACTIONS,\n        }, () => this.actions++);\n        this.addHook('applybuff', {\n            by: 'player',\n            abilityId: RELEVANT_STATUSES,\n        }, () => this.buffs++);\n        this.addHook('complete', this.onComplete);\n    }\n    onComplete() {\n        this.checklist.add(new Rule({\n            name: 'Use a Continuation once per action in the Gnashing Fang combo',\n            description: <Trans id=\"gnb.continuation.checklist.description\">\n\t\t\t\tOne <ActionLink {...ACTIONS.CONTINUATION}/> action should be used for each <ActionLink {...ACTIONS.GNASHING_FANG}/> combo action.\n\t\t\t</Trans>,\n            requirements: [\n                new Requirement({\n                    name: <Trans id=\"gnb.continuation.checklist.requirement.continuation.name\">\n\t\t\t\t\t\t<ActionLink {...ACTIONS.CONTINUATION}/> uses per <ActionLink {...ACTIONS.GNASHING_FANG}/> combo action\n\t\t\t\t\t</Trans>,\n                    value: this.actions,\n                    target: this.buffs,\n                }),\n            ],\n        }));\n    }\n}\nContinuation.handle = 'continuation';\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Checklist)\n], Continuation.prototype, \"checklist\", void 0);\n","import ACTIONS from 'data/ACTIONS';\nimport CoreCooldowns from 'parser/core/modules/Cooldowns';\nexport default class Cooldowns extends CoreCooldowns {\n}\nCooldowns.cooldownOrder = [\n    // Stance\n    ACTIONS.ROYAL_GUARD.id,\n    // Buffs\n    ACTIONS.NO_MERCY.id,\n    ACTIONS.BLOODFEST.id,\n    // oGCD Damage\n    ACTIONS.JUGULAR_RIP.id,\n    ACTIONS.ABDOMEN_TEAR.id,\n    ACTIONS.EYE_GOUGE.id,\n    ACTIONS.DANGER_ZONE.id,\n    ACTIONS.BLASTING_ZONE.id,\n    ACTIONS.BOW_SHOCK.id,\n    ACTIONS.ROUGH_DIVIDE.id,\n    // Personal Mitigation\n    ACTIONS.SUPERBOLIDE.id,\n    ACTIONS.CAMOUFLAGE.id,\n    ACTIONS.NEBULA.id,\n    ACTIONS.RAMPART.id,\n    // Party Mitigation\n    ACTIONS.HEART_OF_LIGHT.id,\n    ACTIONS.HEART_OF_STONE.id,\n    ACTIONS.AURORA.id,\n    ACTIONS.REPRISAL.id,\n    // Tank Utility\n    ACTIONS.PROVOKE.id,\n    ACTIONS.SHIRK.id,\n    // Disrupt Utility\n    ACTIONS.INTERJECT.id,\n    ACTIONS.LOW_BLOW.id,\n    ACTIONS.ARMS_LENGTH.id,\n];\n","import { __decorate, __metadata } from \"tslib\";\nimport { t } from '@lingui/macro';\nimport { Plural, Trans } from '@lingui/react';\nimport _ from 'lodash';\nimport React from 'react';\nimport { ActionLink, StatusLink } from 'components/ui/DbLink';\nimport { RotationTable } from 'components/ui/RotationTable';\nimport ACTIONS from 'data/ACTIONS';\nimport STATUSES from 'data/STATUSES';\nimport Module, { dependency } from 'parser/core/Module';\nimport Suggestions, { SEVERITY, TieredSuggestion } from 'parser/core/modules/Suggestions';\nimport Timeline from 'parser/core/modules/Timeline';\nimport { getDataBy } from 'data';\nconst SEVERITIES = {\n    MISSING_EXPECTED_USES: {\n        1: SEVERITY.MINOR,\n        4: SEVERITY.MEDIUM,\n        8: SEVERITY.MAJOR,\n    },\n    TOO_FEW_GCDS: {\n        1: SEVERITY.MINOR,\n        2: SEVERITY.MEDIUM,\n        4: SEVERITY.MAJOR,\n    },\n};\nconst EXPECTED_USES = {\n    GNASHING_FANG: 1,\n    SONIC_BREAK: 1,\n    ROUGH_DIVIDE: 1,\n    BLASTING_ZONE: 1,\n    BOW_SHOCK: 1,\n    GCD: 9,\n};\nconst NO_MERCY_BUFF_DURATION = 20000; // in milliseconds\nclass NoMercyState {\n    constructor(start) {\n        this.rotation = [];\n        this.isRushing = false;\n        // Track these for pre-processing so we don't have to loop back over this\n        // a bunch of times later.\n        this.numGcds = 0;\n        this.numBlastingZones = 0;\n        this.numSonicBreaks = 0;\n        this.numRoughDivides = 0;\n        this.numGnashingFangs = 0;\n        this.numBowShocks = 0;\n        this.start = start;\n    }\n}\nexport default class NoMercy extends Module {\n    constructor() {\n        super(...arguments);\n        this.noMercyWindows = [];\n    }\n    get lastNoMercy() {\n        return _.last(this.noMercyWindows);\n    }\n    init() {\n        this.addHook('cast', { by: 'player' }, this.onCast);\n        this.addHook('removebuff', {\n            by: 'player',\n            to: 'player',\n            abilityId: [STATUSES.NO_MERCY.id],\n        }, this.onRemoveNoMercy);\n        this.addHook('complete', this.onComplete);\n    }\n    onCast(event) {\n        const actionId = event.ability.guid;\n        if (actionId === ACTIONS.ATTACK.id) {\n            return;\n        }\n        if (actionId === ACTIONS.NO_MERCY.id) {\n            const noMercyState = new NoMercyState(event.timestamp);\n            const fightTimeRemaining = this.parser.fight.end_time - event.timestamp;\n            noMercyState.isRushing = NO_MERCY_BUFF_DURATION >= fightTimeRemaining;\n            this.noMercyWindows.push(noMercyState);\n        }\n        // So long as we're in this window, log our actions to it.\n        const lastNoMercy = this.lastNoMercy;\n        if (lastNoMercy != null && lastNoMercy.end == null) {\n            lastNoMercy.rotation.push(event);\n            const action = getDataBy(ACTIONS, 'id', actionId);\n            if (!action) {\n                return;\n            }\n            // Pre-process on the number of certain things we did\n            if (action.onGcd) {\n                lastNoMercy.numGcds++;\n            }\n            switch (actionId) {\n                // Blasting Zone is just a traited version of Danger Zone\n                // Impossible to see both in the same log outside of hacking\n                case ACTIONS.BLASTING_ZONE.id:\n                case ACTIONS.DANGER_ZONE.id:\n                    lastNoMercy.numBlastingZones++;\n                    break;\n                case ACTIONS.SONIC_BREAK.id:\n                    lastNoMercy.numSonicBreaks++;\n                    break;\n                case ACTIONS.ROUGH_DIVIDE.id:\n                    lastNoMercy.numRoughDivides++;\n                    break;\n                case ACTIONS.GNASHING_FANG.id:\n                    lastNoMercy.numGnashingFangs++;\n                    break;\n                case ACTIONS.BOW_SHOCK.id:\n                    lastNoMercy.numBowShocks++;\n                    break;\n            }\n        }\n    }\n    onRemoveNoMercy(event) {\n        const lastNoMercy = this.lastNoMercy;\n        if (lastNoMercy != null) {\n            lastNoMercy.end = event.timestamp;\n        }\n    }\n    onComplete() {\n        // Exclude any window at the end of a fight which could not possibly have gotten all of its GCDs\n        const missedGcds = this.noMercyWindows\n            .filter(window => !window.isRushing)\n            .reduce((sum, window) => sum + Math.max(0, EXPECTED_USES.GCD - window.numGcds), 0);\n        // Sum up all the missing expected casts\n        const missedBlastingZones = this.noMercyWindows\n            .reduce((sum, window) => sum + Math.max(0, EXPECTED_USES.BLASTING_ZONE - window.numBlastingZones), 0);\n        const missedSonicBreaks = this.noMercyWindows\n            .reduce((sum, window) => sum + Math.max(0, EXPECTED_USES.SONIC_BREAK - window.numSonicBreaks), 0);\n        const missedRoughDivides = this.noMercyWindows\n            .reduce((sum, window) => sum + Math.max(0, EXPECTED_USES.ROUGH_DIVIDE - window.numRoughDivides), 0);\n        const missedGnashingFangs = this.noMercyWindows\n            .reduce((sum, window) => sum + Math.max(0, EXPECTED_USES.GNASHING_FANG - window.numGnashingFangs), 0);\n        const missedBowShocks = this.noMercyWindows\n            .reduce((sum, window) => sum + Math.max(0, EXPECTED_USES.BOW_SHOCK - window.numBowShocks), 0);\n        const sumMissingExpectedUses = missedBlastingZones + missedSonicBreaks + missedRoughDivides + missedGnashingFangs + missedBowShocks;\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.NO_MERCY.icon,\n            content: <Trans id=\"gnb.nomercy.suggestions.gcds.content\">\n\t\t\t\tTry to land 9 GCDs during every <ActionLink {...ACTIONS.NO_MERCY}/> window. A 20 second duration is sufficient\n\t\t\t\tto comfortably fit 9 GCDs with full uptime if you wait until the last one-third of your GCD timer to activate it.\n\t\t\t</Trans>,\n            why: <Trans id=\"gnb.nomercy.suggestions.gcds.why\">\n\t\t\t\t<Plural value={missedGcds} one=\"# GCD\" other=\"# GCDs\"/> missed during <StatusLink {...STATUSES.NO_MERCY}/> windows.\n\t\t\t</Trans>,\n            tiers: SEVERITIES.TOO_FEW_GCDS,\n            value: missedGcds,\n        }));\n        this.suggestions.add(new TieredSuggestion({\n            icon: ACTIONS.BLASTING_ZONE.icon,\n            content: <Trans id=\"gnb.nomercy.suggestions.expected-uses.content\">\n\t\t\t\tWatch your uses of certain abilities during <ActionLink {...ACTIONS.NO_MERCY}/>. Under ideal conditions, you should\n\t\t\t\tbe using <ActionLink {...ACTIONS.SONIC_BREAK}/>, a full <ActionLink {...ACTIONS.GNASHING_FANG}/> combo, and all of\n\t\t\t\tyour off-GCD skills - <ActionLink {...ACTIONS.BLASTING_ZONE}/>, <ActionLink {...ACTIONS.BOW_SHOCK}/>, and at least one\n\t\t\t\tcharge of <ActionLink {...ACTIONS.ROUGH_DIVIDE}/> - under the buff duration.\n\t\t\t</Trans>,\n            why: <Trans id=\"gnb.nomercy.suggestions.expected-uses.why\">\n\t\t\t\t<Plural value={sumMissingExpectedUses} one=\"# expected cast\" other=\"# expected casts\"/> missed during <StatusLink {...STATUSES.NO_MERCY}/> windows.\n\t\t\t</Trans>,\n            tiers: SEVERITIES.MISSING_EXPECTED_USES,\n            value: sumMissingExpectedUses,\n        }));\n    }\n    output() {\n        return <RotationTable targets={[\n            {\n                header: <Trans id=\"gnb.nomercy.table.header.gcds\">GCDs</Trans>,\n                accessor: 'gcds',\n            },\n            {\n                header: <ActionLink showName={false} {...ACTIONS.BLASTING_ZONE}/>,\n                accessor: 'blastingZone',\n            },\n            {\n                header: <ActionLink showName={false} {...ACTIONS.SONIC_BREAK}/>,\n                accessor: 'sonicBreak',\n            },\n            {\n                header: <ActionLink showName={false} {...ACTIONS.ROUGH_DIVIDE}/>,\n                accessor: 'roughDivide',\n            },\n            {\n                header: <ActionLink showName={false} {...ACTIONS.BOW_SHOCK}/>,\n                accessor: 'bowShock',\n            },\n            {\n                header: <ActionLink showName={false} {...ACTIONS.GNASHING_FANG}/>,\n                accessor: 'gnashingFang',\n            },\n        ]} data={this.noMercyWindows\n            .map(window => {\n            return ({\n                start: window.start - this.parser.fight.start_time,\n                end: window.end != null ?\n                    window.end - this.parser.fight.start_time\n                    : window.start - this.parser.fight.start_time,\n                targetsData: {\n                    gcds: {\n                        actual: window.numGcds,\n                        expected: EXPECTED_USES.GCD,\n                    },\n                    blastingZone: {\n                        actual: window.numBlastingZones,\n                        expected: EXPECTED_USES.BLASTING_ZONE,\n                    },\n                    sonicBreak: {\n                        actual: window.numSonicBreaks,\n                        expected: EXPECTED_USES.BOW_SHOCK,\n                    },\n                    roughDivide: {\n                        actual: window.numRoughDivides,\n                        expected: EXPECTED_USES.ROUGH_DIVIDE,\n                    },\n                    bowShock: {\n                        actual: window.numBowShocks,\n                        expected: EXPECTED_USES.BOW_SHOCK,\n                    },\n                    gnashingFang: {\n                        actual: window.numGnashingFangs,\n                        expected: EXPECTED_USES.GNASHING_FANG,\n                    },\n                },\n                rotation: window.rotation,\n            });\n        })} onGoto={this.timeline.show}/>;\n    }\n}\nNoMercy.handle = 'nomercy';\nNoMercy.title = t('gnb.nomercy.title') `No Mercy Windows`;\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Suggestions)\n], NoMercy.prototype, \"suggestions\", void 0);\n__decorate([\n    dependency,\n    __metadata(\"design:type\", Timeline)\n], NoMercy.prototype, \"timeline\", void 0);\n","import ACTIONS from 'data/ACTIONS';\nimport { CooldownDowntime } from 'parser/core/modules/CooldownDowntime';\n/* This offset allows for four weaponskills to be used before No Mercy in the\n * opener, as is currently recommended. Should be updated if openers change to\n * have later No Mercy.\n */\nconst FIRST_USE_OFFSET_NO_MERCY = 10000;\n/* This offset is large to account for the (mostly) single-weave opener, in\n * which Bloodfest is used after nine weaponskills.\n */\nconst FIRST_USE_OFFSET_BLOODFEST = 22000;\nexport default class AbilityDowntime extends CooldownDowntime {\n    constructor() {\n        super(...arguments);\n        this.firstUseOffsetPerOgcd = {\n            [ACTIONS.NO_MERCY.id]: FIRST_USE_OFFSET_NO_MERCY,\n            [ACTIONS.BLOODFEST.id]: FIRST_USE_OFFSET_BLOODFEST,\n        };\n        this.trackedCds = [\n            {\n                cooldowns: [ACTIONS.NO_MERCY],\n                firstUseOffset: 10000,\n            },\n            {\n                cooldowns: [ACTIONS.BLOODFEST],\n                firstUseOffset: 22000,\n            },\n            { cooldowns: [ACTIONS.BLASTING_ZONE] },\n            { cooldowns: [ACTIONS.ROUGH_DIVIDE] },\n            { cooldowns: [ACTIONS.BOW_SHOCK] },\n        ];\n    }\n}\n","import Ammo from './Ammo';\nimport Combos from './Combos';\nimport Continuation from './Continuation';\nimport Cooldowns from './Cooldowns';\nimport NoMercy from './NoMercy';\nimport OGCDDowntime from './OGCDDowntime';\nexport default [\n    Ammo,\n    Combos,\n    Continuation,\n    Cooldowns,\n    NoMercy,\n    OGCDDowntime,\n];\n"],"sourceRoot":""}